二杠九、通过示例探索 HTN 规划器
特洛伊・汉弗莱斯
引言

作为程序员，我们可能会一直寻找解决所遇到问题的 “更好解决方案”—— 更好的性能、可维护性或可用性。只有在实施这些解决方案后，我们才会理解随之而来的一些细微差别。通常，这些细微差别可能是我们选择解决方案的决定性因素。

在人工智能开发中，一个常见的问题是行为选择。有许多解决这个问题的方法，如有限状态机、行为树、基于效用的选择、神经网络和规划器。本文旨在通过在开发过程中可能遇到的实际示例，探索一种称为分层任务网络（HTN）的规划器的细微差别。

像 HTN 这样的规划架构将问题作为输入，并提供解决该问题的一系列步骤。在 HTN 术语中，这一系列步骤称为计划。使分层任务网络与其他规划器不同的是，它允许我们将问题表示为一个非常高级的任务，并通过其规划过程，将这个任务递归地分解为更小的任务。当这个过程完成时，我们留下了一系列原子任务，它们代表一个计划。将高级任务分解为更小的任务是解决许多类型问题的非常自然的方式。在我们的例子中，问题只是 “弄清楚该做什么”。凭借高度的模块化和快速的运行时执行，HTN 作为一种解决方案具有很大的吸引力。对于熟悉行为树的人来说，这些好处可能也看起来很熟悉。然而，与行为树不同的是，HTN 规划器能够推理可能行动的效果。这种对未来进行推理的能力使 HTN 规划器在描述行为时具有令人难以置信的表达能力。

已经有许多不同的系统用于 HTN 规划 [Erol 95]。我们将探索的系统是我们在《变形金刚：赛博坦的陨落》[HighMoon 12] 中使用的系统，它基于全序前向分解规划器。下面的示例将通过一个简化的虚构示例，介绍我们在开发过程中面临的一些挑战以及获得的好处。

对于我们的示例，我们将使用一个名为 “树干重击者” 的巨魔 NPC。设计师的初始描述是，他是一个高大、讨厌、笨拙的巨魔，巡逻着众多的桥梁，并使用一根大树干攻击路过的敌人。就像在现实世界中开发一样，这个设计肯定会改变。

12.2 HTN 的构建块

在为我们的树干重击者构建行为之前，重要的是回顾分层任务网络的基本构建块，以便您了解它的工作原理。一个 NPC，在我们的例子中是树干重击者，有一个规划器，该规划器使用域和世界状态来构建一系列任务，称为计划。这个计划将由树干重击者的计划运行器运行。世界状态由 NPC 的传感器和计划运行器成功完成的任务更新。该系统的图如图 12.1 所示。

12.2.1 世界状态

像任何类型的行为算法一样，分层任务网络需要某种类型的知识表示来描述当前的问题空间。对于我们的树干重击者来说，这将是一种描述我们的巨魔对世界和他在其中的自身了解的表示。其他类型的行为算法可能会查询世界中不同对象的实际状态。例如，查询对象的位置或它们的健康状况。但是对于 HTN，这些信息需要被编码为它能够理解的东西，称为世界状态。世界状态本质上是描述我们的 HTN 将要推理的属性的向量。这里是一些简单的伪代码。

正如您从伪代码中看到的，世界状态可以简单地是一个由 EHtnWorldStateProperties 等枚举索引的数组或向量。世界状态中的每个条目都可以有自己的一组值。在 WsIsTired 的情况下，字节可以表示布尔值零和一。对于 WsEnemyRange，使用 EEnemyRange 枚举中的值。需要注意的是，世界状态只需要表示 HTN 做出决策所需的内容。这就是为什么 WsEnemyRange 由抽象值表示，而不是实际范围。世界状态的目标不是代表游戏中每个可能对象的每个可能状态。它只需要代表我们的规划器做出决策所需的问题空间。当然，这对我们的例子意味着，它只需要代表树干重击者做出决策所需的内容。

12.2.2 传感器
如果您还记得，HTN 输出一个计划或任务序列。这些任务在执行时将对世界状态产生影响。然而，也有外部影响，如玩家或其他 NPC，它们也会影响世界状态。例如，敌人和巨魔都可以影响世界状态属性 WsEnemyRange。巨魔执行的任务如果移动巨魔，可能会更新此属性。但是，HTN 规划器中没有任何东西可以处理敌人移动所产生的的变化。
有许多不同的方法可以将这些变化转换为世界状态。一种更好的方法是一个简单的传感器系统，它管理一组时间分片的传感器。每个传感器可以管理不同的世界状态属性。一些不同传感器的例子包括视觉、听觉、范围和健康传感器。这些传感器的工作方式与任何其他人工智能系统相同，只是增加了一个步骤，将它们的信息编码为我们的 HTN 能够理解的世界状态。
12.2.3 原始任务
正如我们已经提到的，分层任务网络由任务组成。有两种类型的任务用于构建 HTN，称为复合任务和原始任务。原始任务代表我们的 NPC 可以执行的单个步骤。在我们的树干重击者示例中，连根拔起一棵树或用树干猛击攻击将是原始任务的例子。一组原始任务是我们最终从 HTN 中得到的计划。原始任务由一个操作符和一组效果和条件组成。
为了执行原始任务，其条件集必须有效。这允许任务的实现者确保任务运行的正确条件得到满足。需要注意的是，原始任务的条件不是 HTN 实现的要求。然而，建议使用它们来减少在 HTN 层次结构中更高层次需要的冗余检查。此外，这样做将避免由于必须在多个地方进行这些检查而可能出现的潜在错误。
原始任务的效果描述了任务的成功将如何影响 NPC 的世界状态。例如，任务 DoTrunkSlam 执行巨魔的树干近战攻击，并导致巨魔疲劳。DoTrunkSlam 的效果是我们描述此结果的方式。这允许 HTN 如前所述推理 “未来”。由于表示了 “疲劳” 的效果，我们的树干重击者能够更好地决定在 DoTrunkSlam 之后该做什么，或者它是否值得这样做。
操作符代表 NPC 可以执行的原子操作。这听起来可能与原始任务完全相同。区别在于，原始任务及其效果和条件描述了我们正在构建的 HTN 中操作符的含义。
例如，让我们以两个任务 SprintToEnemy 和 WalkToNextBridge 为例。这两个任务都使用 MoveTo 操作符，但两个任务以不同的方式改变我们的 NPC 的状态。在 SprintToEnemy 成功完成后，我们的 NPC 将在敌人处并且疲劳，这由任务的效果指定。WalkToNextBridge 任务的效果将把 NPC 的位置设置为桥梁，并且他会更无聊一点。正如您所看到的，我们能够使用相同的操作符，但在我们的网络中描述了它的两种不同用途。这里是我们将用于描述前进的原始任务的符号，以及 SprintToEnemy 和 WalkToNextBridge 任务的示例。

12.2.4 复合任务
复合任务是 HTN 获得 “分层” 性质的地方。您可以将复合任务视为具有多种完成方式的高级任务。以树干重击者为例，他可能有攻击敌人的任务。我们的重击者可能有不同的方式来完成这个任务。如果他有一根树干，他可能会跑到目标处，用它作为近战武器来 “重击” 他的敌人。如果没有树干可用，他可以从地上拔出大石头并向我们的敌人投掷。如果条件合适，他可能还有许多其他方法。
为了确定我们采用哪种方法来完成复合任务，我们需要选择正确的方法。方法由一组条件和任务组成。为了使该方法成为选定的方法，将根据世界状态验证条件。任务集或子任务代表该方法的方法。这个子任务集可以由原始任务以及复合任务组成。将复合任务放入其他复合任务的方法中的能力是分层任务网络获得分层性质的地方。这里是我们将用于描述前进的复合任务的符号的示例。

在我们之前的示例中，使用树干作为近战武器和投掷巨石都是攻击敌人复合任务的方法。我们决定使用哪种方法的条件取决于巨魔是否有树干。这里是使用上述符号的攻击敌人任务的示例。

通过了解复合任务的工作原理，很容易想象我们如何拥有一个大型层次结构，可能从一个名为 BeTrunkThumper 的复合任务开始，该任务被分解为一组更小的任务 —— 每个任务又被分解为更小的任务，依此类推。这就是 HTN 形成描述我们的巨魔 NPC 将如何行为的层次结构的方式。
重要的是要理解，复合任务实际上只是一组方法的容器，这些方法代表完成某些高级任务的不同方式。在计划执行期间，没有复合任务代码运行。
12.3 构建 HTN 域
现在我们已经概述了 HTN 的主要构建块，我们可以为我们的树干重击者构建一个简单的域来说明它是如何工作的。域是用于描述整个任务层次结构的术语。正如我们之前提到的，我们的巨魔有许多桥梁，他积极巡逻并使用一根大树干攻击敌人。我们从一个名为 BeTrunkThumper 的复合任务开始。这个根任务封装了成为树干重击者的 “主要思想”。

正如您在这个根复合任务中看到的，第一种方法定义了巨魔的最高优先级。如果他能看到敌人，他将使用 NavigateToEnemy 任务导航并使用 DoTrunkSlam 任务攻击他的敌人。如果不能，他将下降到下一种方法。下一种方法将运行三个任务：选择下一个要检查的桥梁，导航到该桥梁，并检查桥梁是否有敌人。让我们看看构成这些方法和域的其余部分的原始任务。

第一个任务 DoTrunkSlam 是一个原始任务如何根据 HTN 域描述操作符的示例。在这里，任务实际上是执行一个动画攻击操作符，并且动画名称作为一个术语传递进来。下一个任务 NavigateToEnemy 也是一个例子，但在这个任务成功完成后，世界状态 WsLocation 通过原始任务的效果设置为 EnemyLocRef。
12.4 寻找计划
有了由复合任务和原始任务组成的域，我们开始形成这些任务如何组合在一起代表一个 NPC 的图像。结合世界状态，我们可以谈论我们的 HTN 的主力，规划器。有三种情况会迫使规划器寻找新的计划：NPC 完成或失败当前计划，NPC 没有计划，或 NPC 的世界状态通过传感器发生变化。如果发生这些情况中的任何一种，规划器将尝试生成一个计划。为此，规划器从一个表示我们试图规划的问题域的根复合任务开始。使用我们之前的示例，这个根任务将是 BeTrunkThumper 任务。这个根任务被推到 TasksToProcess 堆栈上。接下来，规划器创建世界状态的副本。规划器将修改这个工作世界状态来 “模拟” 任务执行时会发生什么。
在完成这些初始化步骤后，规划器开始迭代要处理的任务。在每次迭代中，规划器从 TasksToProcess 堆栈中弹出下一个任务。如果它是一个复合任务，规划器尝试分解它 —— 首先，通过搜索其方法寻找第一个有效的条件集。如果找到一个方法，该方法的子任务将被添加到 TaskToProcess 堆栈中。如果没有找到有效的方法，规划器的状态将回滚到最后一个分解的复合任务。我们将在后面更详细地介绍恢复规划器的状态。
如果下一个任务是原始任务，我们需要根据工作世界状态检查其前提条件。如果条件满足，该任务将被添加到最终计划中，其效果将应用于工作世界状态。应用效果是因为规划器假设该任务将成功。这允许未来的方法考虑到这个新状态。如果原始任务的条件不满足，规划器的状态将像复合任务一样回滚。这个迭代过程将继续，直到 TasksToProcess 堆栈为空。完成后，规划器将最终得到一个原始任务列表，或者规划器将回滚得足够远，结果是没有计划。下面是显示此过程的示例伪代码。

在 RecordDepositionOfTask 和 RestoreToLastDecomposedTask 函数中有一些魔法，应该更详细地解释。记录函数将规划器的状态记录到 DecompHistory 堆栈上。这包括 TasksToProcess 和 FinalPlan 容器以及为分解选择的方法及其所属的复合任务。通过通过恢复函数将这个记录的状态弹出到规划器，规划器可以在复合任务无法分解或原始任务的条件不满足时回溯。
正如您可能已经意识到的，规划器使用深度优先搜索来找到一个有效的计划。这确实意味着您可能必须探索整个域来找到一个有效的计划。然而，重要的是要记住，您正在遍历任务的层次结构。这个层次结构允许规划器通过复合任务的方法剔除网络的大部分部分。因为我们没有使用启发式或成本 —— 如 A * 和 Dijkstra 搜索 —— 我们可以跳过任何类型的排序。这些功能使《变形金刚：赛博坦的陨落》中的 HTN 规划器比我们在《变形金刚：赛博坦之战》[HighMoon 10] 中使用的 GOAP 系统快得多。
现在已经解释了规划器，我们可以扩展我们的示例，看看树干重击者域的修改版本可能如何分解（图 12.2）。这个域的根任务仍然是 BeTrunkThumper，但 DoTrunkSlam 现在是一个复合任务。DoTrunkSlam 有两种方法 —— 每种方法执行不同版本的树干猛击。为了简单起见，两个复合任务的方法的条件都被省略了。在域的下面，您可以看到规划器的迭代从顶部到底部进行。对于每次迭代，您可以看到 TasksToProcess 堆栈中最左边的任务正在被处理。
12.5 运行计划
运行 HTN 计划非常简单。NPC 的计划运行器将尝试按顺序执行每个原始任务的操作符。随着每个任务的成功完成，规划器将任务的效果应用于世界状态。如果任务由于其运行的操作符的特定原因而失败，计划也将失败并强制重新规划。
如果当前或任何剩余任务的条件变得无效，计划也可能失败。计划运行器根据 “工作世界状态” 监视这些任务的前提条件，就像规划器一样。当它确认每个任务的前提条件时，其效果将应用于工作世界状态。重要的是要应用这些效果，因为后续任务的前提条件可能依赖于这些效果的应用才能有效。这种计划验证允许 HTN 域对世界状态的变化更具表达能力和反应能力。
12.6 使用递归实现更强的表达能力
在游戏中看到我们的巨魔后，设计师认为树干攻击有点过于强大。他们建议树干在三次攻击后断裂，迫使巨魔寻找另一个。首先，我们可以向世界状态添加属性 WsTrunkHealth。
通过将攻击方法包装到自己的复合任务中并添加一点递归，我们将能够修改巨魔的攻击行为。更改后的域现在将是：

当我们的巨魔能看到敌人时，他将像以前一样攻击 —— 只是现在，行为被包装在一个名为 AttackEnemy 的新复合任务中。这个任务的高优先级方法执行导航和猛击，就像原始域一样，但现在有一个条件，即树干有一些健康值。对 DoTrunkSlam 任务的更改将在每次成功攻击时减少树干的健康值。这允许规划器在需要适应断裂的树干时下降到较低优先级的方法。
AttackEnemy 的第二种方法处理获取新的树干。它首先选择一棵新的树使用，导航到那棵树，连根拔起，然后能够攻击敌人。这就是递归的地方。当规划器再次分解 AttackEnemy 任务时，它现在可以再次考虑这些方法。如果树干的健康值仍然为零，这将导致规划器无限循环。但是新任务 UprootTrunk 的效果将 WsTrunkHealth 设置回 3，允许我们有计划 FindTrunk → NavigateToTrunk → UprootTrunk → NavigateToEnemy → DoTrunkSlam。这个新域允许我们重用域中已有的方法，让巨魔回到重击状态。
12.7 为不受任务控制的世界状态变化进行规划
到目前为止，我们构建的所有计划都依赖于原始任务的效果来改变世界状态。然而，当世界状态在原始任务的控制之外发生变化时会发生什么呢？为了探索这个问题，让我们再次修改我们的示例。假设设计师注意到，当巨魔看不到敌人时，他只是回到桥梁巡逻。设计师要求您实现一种行为，让他追逐敌人，并在再次看到敌人时做出反应。让我们看看我们可以对域进行哪些更改来处理这个问题。

通过这次重新设计，如果树干重击者看不到敌人，规划器将下降到依赖于 WsHasSeenEnemyRecently 世界状态属性的新方法。该方法的任务将导航到敌人最后被看到的地方，如果他再次看到敌人，将执行一个大型动画 “咆哮”。这里的问题是，RegainLOSRoar 任务的前提条件是 WsCanSeeEnemy 为真。这个世界状态由巨魔的视觉传感器处理。当规划器将 RegainLOSRoar 任务添加到最终任务列表时，它将无法通过前提条件检查，因为域中没有任何东西表示导航完成时预期的世界状态。
为了解决这个问题，我们将引入预期效果的概念。预期效果是仅在规划和计划验证期间应用于世界状态的效果。这里的想法是，您可以表达基于任务执行应该发生的世界状态的变化。这允许规划器根据它认为沿途将完成的事情对未来进行更远的规划。请记住，规划器在决策方面的一个关键优势是它可以推理未来，帮助它做出下一步做什么的更好决策。为了适应这一点，我们可以将域中的 NavToLastEnemyLoc 更改为：

现在，当这个任务从分解列表中弹出时，工作世界状态将用预期效果更新，并且 RegainLOSRoar 任务将被允许继续向链中添加任务。这种简单的行为可以通过几种不同的方式实现，但在《变形金刚：赛博坦的陨落》的开发过程中，预期效果多次派上用场。它们是在 HTN 域中更具表达能力的一种简单方法。
12.8 如何处理更高优先级的计划
到目前为止，我们一直在根据任务方法的顺序分解复合任务。这往往是我们进行搜索的自然方式，但考虑一下我们对树干重击者域的这些攻击更改。

经过一些游戏测试后，我们的设计师评论说我们的巨魔非常惩罚性。只有当它去抓另一根树干时，它才会停止对玩家的攻击。设计师建议在树干猛击后添加一个恢复动画，并添加一个新的条件，即如果巨魔最近攻击过，则不允许猛击攻击。设计师还注意到，如果巨魔无法导航到敌人（例如，由于障碍物），它的行为会很奇怪。他决定在这种情况下添加一个低优先级的攻击，即投掷巨石。
这些行为更改似乎都非常直接，但我们需要更仔细地看看在运行树干猛击计划时可能会发生什么。在实际的猛击动作之后，我们开始运行 RecoveryRoar 任务。如果在执行此咆哮时，世界状态发生变化并导致重新规划，RecoveryRoar 任务将被中止。原因是，当规划器到达处理猛击的方法时，由于 DoTrunkSlam 成功完成，AttackRecently 世界状态将被设置为 true。这将导致规划器跳过 “猛击” 方法任务，并下降到新的 “投掷巨石” 方法，从而导致一个新的计划。这将导致 RecoveryRoar 任务在执行过程中被中止，即使当前运行的计划仍然有效。
在这种情况下，我们需要一种方法来识别正在运行的计划的 “优先级”。有几种方法可以解决这个问题。由于 HTN 是一个图，我们可以使用某种形式的基于成本的搜索，例如 A * 或 Dijkstra。这将涉及为我们的任务甚至方法绑定某种成本。不幸的是，在实践中调整这些成本可能非常棘手。不仅如此，我们现在必须为我们的规划器添加排序，这将减慢其执行速度。
相反，我们希望保持 “按顺序优先级” 的简单性和可读性，用于我们的方法。问题是计划不知道规划器为到达该计划而分解复合任务的顺序 —— 它只执行原始任务的操作符。
所有可能的计划与树干重击者域以及每个计划的方法遍历记录，按优先级排序。
复合任务方法的顺序是我们想要用来定义优先级的 —— 但计划不知道复合任务是什么。为了解决这个问题，我们可以在搜索计划时对通过 HTN 域的遍历进行编码。这个方法遍历记录（MTR）简单地存储为创建计划而分解的每个复合任务选择的方法索引。现在我们有了 MTR，我们可以用两种不同的方式使用它来帮助我们找到更好的计划。最简单的方法是正常规划，并将新找到的计划的 MTR 与当前运行计划的 MTR 进行比较。如果新计划中选择的所有方法索引都等于或更高优先级，我们就找到了新的计划。图 12.3 显示了一个示例。
我们也可以选择在规划过程中使用当前计划的 MTR，当我们在新搜索中分解复合任务时。我们可以在搜索有效方法时使用 MTR，只允许等于或更高优先级的方法。这允许我们根据当前计划的 MTR 剔除我们的 HTN 的整个分支。我们的第一种方法是两种方法中较容易的一种，但如果您发现您在规划器上花费了大量处理时间，第二种方法可以帮助加快速度。
现在我们有能力中止当前运行的计划以支持更高优先级的计划，但有一个微妙的实现细节可能会导致您的 NPC 出现意外行为。如果您设置规划器在世界状态发生变化时重新规划，规划器将在任务成功执行应用其效果时尝试重新规划。考虑下面树干重击者域的这个更改部分。

这个新行为旨在让巨魔在执行 DoTrunkSlam 三次后执行 DoWhirlwindTrunkAttack 任务。这是通过让 DoTrunkSlam 任务的效果每次执行时将 WsPowerUp 属性增加 1 来实现的。乍一看，这似乎没问题，但您会有设计师告诉您，巨魔现在每次都会直接将树干猛击组合成旋风攻击。问题出在 DoTrunkSlam 的第三次执行上。任务的效果被应用，规划器强制重新规划。当 WsPowerUp 等于 3 时，规划器将选择更高优先级的旋风攻击方法。这取消了旨在打破攻击的 DoRecovery 任务，让玩家有一些时间来反应。
通常，旋风方法应该能够取消较低优先级的计划。但是当前运行的计划仍然有效，并且出现此错误的唯一原因是规划器在所有世界状态变化时重新规划，包括成功完成的原始任务效果引起的变化。简单地在世界状态通过原始任务应用的效果发生变化时不重新规划就可以解决这个问题 —— 这很好，因为计划是在考虑到这些世界状态变化的情况下找到的。虽然这是一个很好的改变，但它不会是完整的解决方案。计划运行器正在执行的任务之外的任何世界状态变化都将强制重新规划并导致错误再次出现。
这里的真正问题是域及其当前的设置方式。我们可以通过几种不同的方式来解决这个问题，而您如何看待它真的很重要。有人可能会说恢复动画是攻击的一部分，所以可能值得将该动画合并到攻击动画中。这样，恢复动画总是在猛击攻击后播放。这会损害域的模块化。如果设计师想要连续三次猛击然后进行恢复怎么办？
一个更好的方法是使用世界状态来描述需要 DoRecovery 任务的原因。考虑下面的更改：

使用 WsIsTired 世界状态，我们可以正确描述我们需要 DoRecovery 任务的原因。DoTrunkSlam 任务现在使树干重击者疲劳，并且他在有机会恢复之前无法执行 DoWhirlwindTrunkAttack。现在，当世界状态发生变化时，DoRecovery 任务不会被中断，并且我们保留了 DoTrunkSlam 和 DoRecovery 的模块化。在实现优先级计划选择时，这些微妙的细节真的会给您的 HTN 行为带来麻烦。当您遇到这些类型的行为问题时，问问自己是否正确地表示了世界是很重要的。正如我们在这个例子中看到的，一个简单的世界状态就是所需要的一切。
12.9 管理同时发生的行为
许多不同的行为选择算法非常擅长一次做一件事，但当涉及到同时做两件事时，就会出现复杂情况。幸运的是，有几种方法可以用 HTN 处理这个问题。
一个人的第一反应可能是将多个操作符组合成一个。这将起作用，但有几个陷阱：它消除了重用我们已经开发的操作符的能力，多个操作符的组合带来了增加的复杂性，损害了可维护性，并且如果不正确处理，对这个组合操作符的任何变化都可能迫使我们复制代码。您可能会遇到需要同时做多件事情的行为，而且经常会遇到，您会想要避免这种方法。
一种更直观的处理方式是构建一个单独的 HTN 域来处理您的 NPC 的不同组件。使用我们的巨魔示例，我们可能有一个行为，我们需要他导航到他的敌人，但同时保护自己免受来袭的远程攻击。我们可以将其分解为多个操作符，控制身体的不同部位 —— 一个导航操作符来处理下半身，一个守卫操作符来处理上半身。知道了这一点，我们可以构建两个域并使用两个规划器来处理上半身和下半身。
您可能会很早就发现这可能很难实现。出现的问题是您需要同步每个规划器中的任务。您可以通过确保您有描述每个规划器中正在发生的事情的世界状态来实现这一点。在我们的巨魔示例中，我们可以有一个名为 Navigating 的世界状态，当任何下半身导航任务运行时，它将被设置为 true。这将允许上半身规划器根据此信息做出决策。下面是这两个域可能的设置示例。

现在这很好用，但有几个小问题。第二个规划器会增加一些性能开销。保持这些域的同步会损害它们的可维护性。最后，当其他程序员遇到您刚刚用多个规划器创建的调试头痛时，您不会赢得任何朋友 —— 相信我。
对于我们的巨魔屏蔽示例，还有另一种替代方案，不涉及两个规划器。目前，导航任务在成功到达目的地后完成。相反，我们可以让导航任务开始路径跟踪并立即完成，因为路径跟踪在后台发生，而不是作为计划运行器中的任务。这使我们能够在导航期间进行规划，从而允许我们举起手臂来保护巨魔免受来袭的火力。只要我们有一个描述我们正在导航和到目的地的当前距离的世界状态，这就可以工作。有了这个，我们可以检测到何时到达并相应地进行规划。下面是域的样子的示例。

正如您所看到的，这个域与我们的双域方法类似。两种方法都依赖世界状态来正确工作。在双域中，Navigating 世界状态用于保持规划器同步。在后面的方法中，世界状态用于表示在后台发生的路径跟踪，但不需要两个域和两个规划器运行。
12.10 使用部分计划加速规划
假设我们已经将树干重击者的域构建成一个相当大的网络。在优化规划器本身之后，您发现需要从规划时间中减少几毫秒。我们仍然可以通过几种方法从其中获得更多性能。正如我们所解释的，HTN 自然地通过复合任务中的方法剔除了大部分搜索空间。然而，在某些情况下，我们可以添加更多方法来剔除更多搜索空间。为了做到这一点，我们需要有正确的世界状态表示。
如果这些技术不能为您提供所需的速度，部分规划应该可以。部分规划是 HTN 最强大的功能之一。简单地说，它允许规划器不完全分解完整计划的能力。HTN 能够做到这一点，因为它使用前向分解或前向搜索来查找计划。也就是说，规划器从当前世界状态开始，并从那时起向前规划。这允许规划器只提前规划几步。
另一方面，GOAP 和 STRIPS 规划器变体使用后向搜索 [Jorkin 04]。这意味着搜索从期望的目标状态向当前世界状态进行。以这种方式搜索意味着规划器必须完成整个搜索才能知道采取的第一步。我们将回到树干重击者域的一个简单版本，演示如何将其分解为部分计划域。

在这里，我们有一个方法，如果 WsCanSeeEnemy 为真，它将扩展 NavigateToEnemy 和 DoTrunkSlam 任务。由于构成 NavigateToEnemy 的任何任务可能需要很长时间，因此将其拆分为部分计划将是一个不错的选择。计划太远的未来没有太大意义，因为世界状态很有可能发生变化，迫使我们的巨魔做出不同的决定。我们可以将这个特定的计划转换为部分计划：

在这里，我们将之前的方法拆分为两个方法。新的高优先级方法将仅在巨魔当前不在近战范围内时导航到敌人。如果巨魔不在近战范围之外，他将执行树干猛击攻击。导航任务也是部分计划的主要目标，因为它们通常需要很长时间才能完成。重要的是要指出，只有在有世界状态可用于区分拆分时，才能拆分此计划。
这种部分规划的方法要求域的作者自己创建拆分。但是有一种方法可以自动化这个过程。通过将 “时间” 的概念分配给原始任务，规划器可以跟踪它已经规划到未来的多远。然而，这种方法有几个问题。考虑这个域。

在这个域中，假设构成导航的原始任务超过了规划器中设置的时间阈值。这将导致巨魔开始导航到敌人。但是，如果世界状态属性 WsStamina 为零，由于其前提条件，巨魔无论如何都无法执行 DoTrunkSlam。自动化的部分计划拆分消除了正确验证计划的能力。当然，可以编写该方法来包括耐力检查以避免此问题。但是，由于两种方式都是有效的，最好确保两者都产生相同的结果。不这样做会在您的游戏中导致微妙的错误。
即使您觉得这不是一个真正的问题，还有如何从部分计划停止的地方继续的问题。我们可以从根重新规划，但这将要求我们以某种方式更改域，以理解它已经完成了完整计划的第一部分。在我们的例子中，我们必须添加一个更高优先级的方法，检查我们是否在近战攻击范围内。但是，如果我们必须这样做，那么自动化部分规划的意义是什么呢？
一个更好的解决方案是记录未处理列表的状态。有了这个，我们可以修改规划器，从一个任务列表开始，而不是一个根任务。这将允许我们从我们离开的地方继续搜索。当然，我们将无法回滚到计划第二部分开始之前。遇到这种情况意味着您已经运行了不应该运行的任务。因此，如果用户遇到这种情况，他们不能使用部分规划，因为计划后面的任务需要进行验证才能获得正确的行为。
在《变形金刚：赛博坦的陨落》中，我们只是将部分计划构建到域中。对我们来说，将微妙的错误放入游戏的机会很高，并且我们发现，当完全计划验证不必要时，我们自然会在我们的 NPC 域中放置部分计划。我们的许多 NPC 都使用了 12.9 节中的最后一个示例进行导航，这也是部分规划的一个示例。

12.11 结论

创建一个简单 NPC 的过程可以让您真正了解任何行为选择系统实现所涉及的细节。希望我们已经充分探索了分层任务网络，以展示其描述行为的自然方法、原始任务的可重用性和模块化。HTN 推理未来的能力允许一种只有规划器才能找到的表达能力。我们还试图指出开发人员在实现它时可能遇到的潜在问题。分层任务网络对《变形金刚：赛博坦的陨落》的人工智能程序员来说是一个真正的好处，我们相信它对您也会如此。
