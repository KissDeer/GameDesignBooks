二杠十、多单位战斗机动的分层计划空间规划
威廉・范德斯特伦
13.1 引言
在战斗模拟器和战争游戏中，制定一个好的计划是成功的一半。好的计划使人工智能成为更具说服力的对手和更可靠的助理指挥官。好的计划对于战斗单位之间朝着共同目标进行清晰有效的协调至关重要。
本章描述了一种人工智能规划器的设计，该规划器能够制定计划，将多个单位协调成战场上的联合机动。首先，它探讨了为多个单位规划与为单个单位规划的不同之处。然后介绍了分层计划空间规划的基本思想。这些思想对于战斗机动的情况更加具体。文章最后对设计进行了评估，并提出了分层计划空间规划的进一步应用思路。
13.2 为多个单位规划
为多个单位创建计划与为单个单位规划不同。显然，计划需要满足所有单位而不是单个单位的需求，并且将涉及更多的行动。在许多情况下，这些单位将同时执行其行动。
但还有更多的不同之处：在大多数情况下，这些单位将不得不相互交互以实现目标。为了协调这种交互，计划需要说明谁需要与谁、在哪里以及何时进行交互。
另一个不同之处在于计划的传达：构成单个单位计划的行动通常不需要额外的解释。然而，当多个单位共同努力实现一个目标时，通常需要额外的解释（例如，作为图 13.1 中简报的一部分）。工作如何在子组之间分配？谁在协助谁？每个组的角色是什么？对于战斗计划，总体概念是什么？
鉴于这些差异，我们能否采用像 GOAP [Orkin 06] 或 HTN 规划器 [Ghallab et al. 04, Humphreys 13] 这样的单单位规划器来为多个单位创建计划？出于所有实际目的，我们不能。这两种规划器都逐个行动地构建其计划，并遍历由世界状态组成的搜索空间（状态空间 [StateSpaceSearch]）。我们的问题是多个单位同时行动导致的巨大状态空间。例如，假设一个单位有四个替代行动来移动或操纵其环境，并且我们需要一个五步计划。对于这种 “单单位” 情况，总状态空间由个状态组成，并且可以轻松搜索。如果我们试图解决涉及六个单位同时行动的类似问题，状态空间大小将爆炸到种组合。GOAP 和，在较小程度上，标准的 HTN 规划器在如此大的状态空间中难以有效地进行搜索。
与其在状态空间中搜索，我们可以尝试在计划空间中搜索（见图 13.2）。计划空间表示所有不完整和完整的计划。这听起来可能很模糊，但实际上它与人类项目规划者解决规划问题的方式非常相似。项目规划者将总体问题分解为较小的任务，这些任务共同实现目标。然后，他们反复分解这些较小的任务，直到最终的活动足够小，可以由单个单位的行动来完成。图 13.3 显示了一个完全详细计划的示例。
在计划空间中工作在解决多单位规划问题时提供了三个关键优势。首先，我们可以通过推理任务和子任务在比单个行动更高的层次上做出规划决策。其次，我们可以自由地以我们喜欢的任何顺序详细说明计划，这使我们能够首先关注最关键的任务。第三，我们可以在计划中明确表示协调（作为涉及多个单位的任务）和同步（作为在前一个子任务的所有行动完成之前无法开始的任务）。有了这些优势，我们能够为多个单位生成描述协调行动的计划，即使对于大的搜索空间也是如此。
本文继续详细介绍这种针对如图 13.1 所示的战斗机动问题的分层计划空间规划方法。
13.3 计划空间中的分层规划：要素
我们需要四个要素来实现计划空间中的分层规划：规划器主循环、表示计划的任务和行动、一组规划器方法，这些方法可以通过详细说明计划中的一个任务来细化部分计划，以及最后保存和排名所有部分计划的计划空间。我们将按此顺序研究这些要素。
13.4 规划器主循环：通过计划空间的 A*搜索
规划器主循环执行通过计划空间的搜索。搜索从一个由单个顶级任务（“任务”）组成的计划开始。接下来，主循环反复从计划空间的开放计划中选择最有希望的计划，并尝试通过细化计划的任务来扩展该计划。当找到一个完整的计划时，主循环成功退出。当没有开放计划可扩展时，主循环以失败退出。图 13.4 显示了规划器主循环的伪代码。
主循环如下扩展所选计划。它首先从计划中选择一个需要细化的任务。然后，它从规划器方法目录中选择可以细化此选定任务的方法。这些方法中的每一个都分别应用，导致零个或多个替代扩展计划（我们将在后面更详细地讨论）。每个扩展的替代计划都被分配一个成本并添加到开放列表中。
“主循环非常通用，类似于 A * 路径搜索。在这里，我们将计划扩展为一个或多个更接近完全详细计划的相邻计划，而不是将路径扩展为一个或多个更接近目的地的相邻位置。我们以最佳优先的方式扩展计划，这在查看计划空间时会更详细地解释。
13.5 任务计划
一个计划由相互依赖的任务组成。一个任务代表一个或多个单位的活动并消耗时间。对于我们的战斗机动领域，我们需要任务来表示基本单位行动，我们需要任务来表示更高层次的活动。表 13.1 列出了这两种任务的示例，底部行是单位级任务。范围反映了军事中做出决策和分解问题的各个级别：任务、目标、团队、战术、单位、单位。
基本单位任务简单地遵循一个单位（如步兵班、坦克排或武装直升机分队）能够执行的活动。我们称这些任务为 “原始” 任务，因为我们无法分解它们。更高层次的任务旨在帮助我们做出更高层次的规划决策并分解计划（如图 13.3 所示）。一般来说，这些任务是关于为子目标分配资源和协调子任务。我们战斗机动领域的具体示例包括一个完整的团队移动到集结位置、炮兵和飞机的预备打击或伞降。这些任务被称为 “复合” 任务，因为我们可以将它们分解为更小的任务。
任务有开始时间和持续时间。对于原始任务，任务的持续时间计算为活动持续时间；对于已经细化为子任务的任务，任务的持续时间计算为最晚子任务的结束时间减去最早子任务的开始时间；对于尚未细化的复合任务，任务的持续时间为估计持续时间。我们稍后将研究这些估计。
在计划中，任务被组织为一个图。除了根任务外，每个任务都有一个父任务。复合任务有子任务（实现其父任务的子任务）。任务可能有先前的任务，这些任务需要在该任务开始之前完成。例如，一个团队编队攻击在所有相关单位的集结任务完成之前无法开始。两个任务之间的这些优先关系也意味着第一个任务的所有子任务都优先于第二个任务。任务可能以相同的方式有后续任务。
任务用输入进行参数化，并可能提供输出。在我们的战斗机动领域，所有任务都将涉及的单位作为输入，通常在任务开始时使用计划状态（位置、弹药水平）的单位。原始任务处理单个单位；复合任务通常采用单位数组。许多任务需要额外的输入，例如，表示合作单位、分配的目标或区域或目标状态（任务结束时单位的位置）。
图 13.5 显示了两种任务的示例，每个任务都有输入。LoadTask 表示运输单位（如装甲运兵车排）的装载活动。LoadTask 有三个输入。start_state 输入标识运输单位及其初始状态，包括其位置和任何已装载的乘客单位的标识符。target_state 输入与 start_state 类似，但表示乘客单位已装载。passenger 输入标识乘客单位。
AttackAfterFormUpTeamTask 表示从集结位置进行的多单位地面攻击。它有三个输入。start_state 输入采用将执行攻击的单位数组。objective 输入和 avenue_of_approach 输入提供了来自 “上级” 的额外指导，说明如何细化这个团队级任务。
AttackAfterFormUpTeamTask 也提供输出，许多其他任务也是如此。输出的目的是为其他任务的输入提供值，使它们能够从结果单位状态或诸如攻击路线的战术决策中工作。
任务输入不必在任务创建时设置。它可以保持打开状态，直到任务被细化。或者它可以连接到另一个任务的输入或输出，并在连接的另一侧设置时接收值。图 13.6 说明了这一点。
在图 13.6 中，创建了一个涉及坦克排 A 和 C 的 TeamFormationAttack 任务。该任务被赋予一个起始状态，包括 A 和 C 单位及其起始位置。任务的目标状态表明坦克排应移动到目标 Z 的远端位置。TeamFormationAttack 的结束状态输出故意保持打开状态，将坦克排的详细定位留给更专业的子任务。当规划器细化 TeamFormationAttack 时，例如，通过添加两个 UnitAttack 任务，它将 UnitAttack 的结束状态输出连接到 TeamFormationAttack 的结束状态输出。当规划器细化 UnitAttacks 时，它将用代表靠近所需目标状态但在树林外的位置的值设置结束状态。一旦这些 UnitAttack 的结束状态被设置，它们将传播到 TeamFormationAttack 的结束状态（并进一步传播，如果其他输入已连接到该结束状态）。
因此，任务输出用于沿着任务链传递规划决策和状态。输出和输入之间的连接决定了任务如何共享值。连接可以将输入和输出作为一个整体链接，也可以（对于数组）在每个元素的基础上链接。在图 13.6 中，每个 UnitAttack 任务都设置了 TeamFormationAttack 结束状态中的一个元素。
我们将所有值都已设置的任务输入称为 “基础” 任务。“未基础” 任务的输入缺少一个或多个值。在讨论任务细化的顺序时，我们将再次讨论这种区别。
13.6 规划器方法
当规划器想要细化部分计划中的任务时，它会选择适用于该任务的规划器方法。然后，它分别在部分计划的克隆上应用这些规划器方法中的每一个，并让规划器方法生成部分计划的替代和更细化版本。
卡车排 C 的任务是接载步兵班 A 和 B，并将他们运送到集结区 X。A 和 B 将在那里下车，然后所有单位都将移动到他们的目标位置。
这需要决定：

- 在哪里接载 A，以及在哪里接载 B
- 是否先接载 A 再接载 B
- 在哪里放下 A 和 B
- A、B 和 C 的最终确切位置（如果尚未给出）
  运输移动 [BC]
  移动 [A]
  装载 [A, C] 卸载 [A, C] 移动 [A]
  骑行 [A, C]
  移动 [B]
  移动 [B]
  装载 [B, C] 骑行 [B, C] 卸载 [B, C]
  加载 [C, A] 移动 [C] 加载 [C, B] 移动 [C]
  移动 [C] 卸载 [C, A, B]
  移动 [C]
  图 13.7
  细化运输移动任务时的决策和子任务。
  规划器方法（从现在起我们将简称为 “方法”）的作用是细化计划中的特定任务。方法本身表明它们能够细化哪个任务或哪些任务。如果要细化的任务是原始任务，方法应该计算并设置该任务的输出。图 13.6 显示了坦克排的 UnitAttack 如何获得一个输出（目标远端树林外的一个目的地位置），该输出与坦克单位的移动能力相匹配。
  如果要细化的任务是复合任务，那么方法的责任是决定如何实现该任务，创建必要的子任务，并连接任务和子任务的输入和输出。该方法应确保细化任务的输出已设置或已连接到它们。图 13.7 说明了运输移动方法为了细化一个非平凡的运输移动任务而需要做出的决策、任务、关系和输入 / 输出连接的示例。
  为了分解卡车排 C 和两个步兵班 A 和 B 的运输移动任务（在图 13.7 中），运输移动方法首先做出一些决策。该方法选择卡车排接载班 A 和 B 的位置。这样的接载位置需要卡车排能够到达，并且最好靠近步兵班。如果步兵班在开阔地带，卡车排可能会在班的初始位置接载它。然而，在这个例子中，步兵位于树林中，需要移动到开阔地带才能被接载。在集结区 X 附近的下车点以类似的方式选择。第三个决策是关于先接载 A 还是 B，或者反过来。基于一些路径查找查询，选择先接载 A。最后一个决策涉及选择 A、B 和 C 的最终位置（如果尚未给出）。
  基于这些决策，运输移动方法可以为两个步兵班和卡车排创建任务。通过使一个任务成为另一个任务的前趋任务，该方法为每个单位创建了一系列任务。此外，它通过使其他单位的特定行动成为这些任务的前趋任务，来同步装载 / 装载行动和卸载 / 卸载行动。例如，C 装载 A 的行动不能在 C 和 A 都完成向接载位置的移动之前开始。同样，步兵班不能在卡车排到达下车位置之前下车。
  由于此示例中的运输移动方法已经为所有涉及的单位和任务做出了大部分决策，因此它可以简单地为大多数任务设置输出值和输入值。
  为了完全覆盖我们的战斗机动领域，我们需要方法来为每个原始单位任务设置结束状态，并且我们需要方法来分解每个复合任务。为了将复合任务分解为更小的任务，我们反映为任务选择的层次结构，从任务级方法到单位级方法。作为一个经验法则，方法将任务分解为下一级的任务，有时会多一级。在每个级别，方法的责任略有不同，如表 13.2 所示。
  对于大多数任务，将有一个相应的方法能够分解该任务。对于一些任务，有多种方法来细化任务是有意义的，每种方法专门用于一种战术方法。为了保卫一个目标，一种方法会创建子任务，使可用的排各自占据目标周围的静态位置。另一种方法可以创建子任务，使步兵排从静态位置进行防御，并将装甲排留在后方进行反击。
  使用实现不同战术的单独方法的一个好处是能够通过启用或禁用某些规划方法来配置规划器的战术方法（学说）。
  在图 13.7 的示例中，运输移动方法能够考虑两种组合（先接载 A 再接载 B，以及先接载 B 再接载 A）并选择最佳组合，因为它理解任务将如何在原始任务方面实现。处理更高级任务的方法通常缺乏对计划如何详细工作的理解，并且在面对多种组合时自己难以做出最佳（甚至 “足够好”）的选择。在这些情况下，方法将向规划器主循环指示它看到不止一种替代方案来细化计划。然后，规划器主循环将迭代这些替代方案，并通过克隆父计划并要求方法为给定的替代方案细化计划来创建新计划（见图 13.4）。尽管这给规划器主循环增加了一点复杂性，但好处是我们开发人员只需编写和维护一个方法来分解特定的复合任务。
  一种方法可能无法设置任务输出或分解复合任务，并且无法生成更细化的计划。例如，如果一个炮兵单位在计划早期的两个炮兵任务中已经用完了所有弹药，就不应该计划执行第三个炮兵任务。如果一个由三个机械化排组成的团队被任务以编队攻击，但必须通过一座狭窄的桥梁这样做，这将不是一次编队攻击，方法不应该细化该任务。
  当一种方法无法细化任务时，如果没有其他方法能够在同一计划中细化同一任务，这只是规划中的局部死胡同。请记住，我们正在使用 A*搜索替代计划：这里的死胡同并不意味着没有另一个，也许非常不同的，可行计划的变体。
  13.7 计划空间
  计划空间是所有生成的（部分）计划的集合。我们跟踪所有可以进一步细化的计划在开放列表中。开放列表按成本最低排序（图 13.8）。
  我们可以选择使用什么来计算成本：计划持续时间在大多数情况下都适用，并且特别适合战斗机动，因为时间在计划质量中起着相当大的作用。我们发动攻击的速度越快，或者我们的防御单位占领阵地的速度越快，越好。
  我们计算计划持续时间的方式与项目规划者相同，在可用时使用来自原始任务的准确数据，并为尚未详细说明的复合任务使用估计。从根任务开始，我们反复选择一个没有前趋任务且没有开始时间和结束时间的子任务。对于这个子任务，我们将其前趋任务的最大结束时间设置为开始时间，并递归地计算其持续时间和结束时间（开始时间加上持续时间）。在对所有子任务执行此操作后，我们可以设置任务的结束时间。根任务的结束时间减去开始时间给出了计划的持续时间。
  每次更新计划时，我们都需要重新计算计划的持续时间。新添加的原始任务的持续时间可能与它们的复合父任务估计的不同。然而，我们可以为复合任务的特定输入一旦计算出的估计进行缓存。
  我们将复合任务持续时间的估计留给任务本身。每个复合任务都应该实现一个 “估计持续时间” 函数。这些函数使用启发式方法来得出合理的估计。由于我们使用 A*在计划空间中搜索，估计应该是一个接近的估计，而不会高估持续时间。图 13.9 说明了如何得出一个好的估计。
  图 13.9 显示了与图 13.7 相同的情况和运输移动任务。现在我们感兴趣的是在不考虑细化任务时所考虑的所有决策和细节的情况下估计持续时间。一个好的估计是 C 以最高速度移动到 A，然后到 B，最后到 X，加上装载和卸载 A 和 B 的时间。在估计中，我们可以根据简单的几何比较决定先移动到 A 再到 B：A 比 B 更接近 C。或者，我们可以评估两种情况下的路径持续时间，并选择最低的估计。在大多数情况下，我们低估了实际成本，因为由于地形原因，实际移动速度将比 C 慢。
  与 A*路径查找一样，我们通过人为地增加风险行动的持续时间来使规划器避免某些任务和计划。例如，为了使攻击者避免使用软皮车辆将步兵运送到集结位置，我们可以增加软皮卡车移动任务的持续时间。当规划器也有装甲运兵车可用时，他将更有可能使用这些车辆运输步兵。
  对于计划所需但与计划质量无关的任务，我们可能希望人为地缩短持续时间。例如，对于战斗机动，我们通常在运输直升机将空降步兵插入着陆区后对它们的返回飞行时间没有任何用处。我们不希望它们的返回飞行时间掩盖步兵地面攻击任务的任何持续时间差异。为了忽略不相关的返回飞行，我们可以为返回飞行任务使用一个小而固定的持续时间。
  13.8 提高规划效率
  如前所述，我们为多个单位创建计划时面临的最大风险是组合问题（更著名的是组合爆炸）。我们的分层计划空间规划器为我们提供了几种减少考虑的选项数量的方法，使为多个单位进行规划变得可行和高效。
  首先，我们使用 A*搜索通过计划空间，首先扩展成本最低的 “最佳” 计划。这有助于我们比标准 HTN 规划器使用的深度优先回溯方法考虑更少的选项。
  其次，我们能够控制单个计划的扩展方式，并将其转变为 “先做高级决策” 的方法。在大多数情况下，一个计划将有多个需要细化且基础的任务（所有输入都已设置）。图 13.3 中的规划器主循环需要选择一个任务进行细化。对于战斗机动领域，其中每个任务都与一个命令范围相关联，我们可以让规划器主循环始终选择范围最高的任务作为首先细化的任务。
  在图 13.10 中，说明了这种首先选择最高范围任务的情况。部分计划由许多需要细化的复合任务组成。其中一些，如攻击和重组任务，由于需要来自先前任务的输入，因此还无法细化。
  任务 [ABC]
  任务
  任务范围
  清除目标 [ABC]
  目标
  集结 [ABC]
  移动 [ABC]
  团队
  运输移动 [BC]
  复合任务，需要细化，
  所有输入已设置，
  范围 = 团队
  复合任务，需要细化，
  一些输入未设置
  复合任务，
  需要细化，
  所有输入已设置，
  范围 = 单位
  单位
  移动 [A]
  图 13.10
  选择所有输入都已设置的最高范围任务：集结。
  有两个任务是基础的并且准备好进行细化：运输移动，范围为 “单位”，以及集结，范围为 “团队”。由于 “团队” 范围更高，规划器将选择集结任务作为首先细化的任务。细化集结任务将设置重组任务的输入，允许该任务接下来进行细化。
  首先细化更高级任务的好处是，这些任务对计划可行性（我们的机械化排是否有足够的机动空间进行联合攻击？）和计划成本有更大的影响。在攻击计划尚未充实之前，规划器不应该忙于详细安排前往集结位置的座位安排。通过首先做出高级决策，规划器需要更少的步骤来找到一个好的计划。
  考虑更少计划的第三种方法是分层计划空间规划器从 “中间向外” 规划的能力。在军队中，规划专家混合了正向规划和反向规划，有时从中间的关键步骤开始。当从中间开始（例如，进行空降或复杂攻击）时，他们随后向前规划到任务完成，向后规划到任务开始。军队这样做是因为从关键步骤开始大大减少了需要考虑的规划选项的数量。
  我们可以通过更改任务之间的输入 / 输出关系并将一些决策从一种方法转移到另一种方法来模仿这一点。请记住，唯一可以细化的任务是基础任务。图 13.11 显示了一个连接任务的示例，以实现中间向外规划。
  在图 13.11 中，显示了一个清除目标任务，该任务已分解为移动、集结、集结后攻击和重组。这些任务将按此顺序执行。然而，这些任务的细化应该从集结后攻击开始。任务之间的输入 / 输出连接使得集结后攻击是第一个所有输入都已设置的任务。集结和重组任务的输入依赖于集结后攻击任务的输出。移动任务依赖于集结任务的输出。细化集结后攻击任务的方法已被修改为使用初始单位位置和目标，并定义从集结位置通过目标的攻击移动。集结后攻击任务输出所选的集结位置和集结后涉及单位的位置。它还输出攻击通过目标后单位的位置。这些输出使集结和重组任务能够被细化。细化集结任务的方法定义了单位应进入集结区域的位置，并通过该输出使移动任务能够被细化。
  中间向外规划需要对任务和方法进行更改，但它可以通过首先做出关键决策大大减少需要考虑的计划数量。对于战斗机动，中间向外规划也类似于军事实践，这使得将军事学说转化为任务和规划器方法更容易。
  13.9 结论
  我们能够成功地规划涉及十几个机械化排、装甲部队、武装直升机分队和炮兵连的战斗机动，同时考虑到战术偏好和时间。通过在计划空间而不是状态空间中工作，通过将问题分解为高级和低级任务和决策，并通过使用基于成本的最佳优先搜索首先扩展高级任务，我们可以避免组合爆炸并在短时间内提供一个好的计划。最终的计划不仅包括每个单位的行动，还包括这些行动之间的协调关系以及所有高级决策。将这样的计划转化为人类可理解的解释或简报是微不足道的。
  这里描述的规划器设计自 2009 年中期以来一直在运行，从用户输入生成了数以万计的战斗机动作为可下载任务 [PlannedAssault 09]。当前的实现是在 Ruby 中，在 Intel Core2Quad Q8400 上的 Java VM（通过 JRuby）上运行单线程，生成 4×3 公里地形的机动需要大约 10 秒到 30 秒，大部分 CPU 时间用于地形分析和路径查找，而不是计划扩展。大多数计划在不到 200 次规划器主循环迭代中构建。
  13.10 未来工作
  在计划空间中规划的一个很好的副作用是，在最终计划中，除了每个单位的行动之外，所有更高层次的任务和决策都可用。这种可用性不仅使将计划转化为人类可读的简报更容易，而且使最终计划非常适合用于监控计划的执行。原始计划包含所有信息，用于决定谁受到任务延迟的影响，计划的哪个部分需要修复，以及计划部分的替代实施的最大允许持续时间是多少。