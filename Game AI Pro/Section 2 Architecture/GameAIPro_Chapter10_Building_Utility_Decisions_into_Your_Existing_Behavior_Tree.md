二杠七、将效用决策构建到您现有的行为树中
比尔・梅里尔
10.1 引言
虽然没有一种 “万能” 的方法来编写人工智能行为，但行为树在实现的容易性、可视化的容易性以及对新团队成员的适应性方面往往能够达到很强的整体平衡。构建支持工具很简单，并且可以在相对较短的时间内建立快速的工作流程。另一方面，行为树有一个基本的限制。它们不善于建模类似不确定性这样的模拟概念，例如在多个有效选项之间的不确定性。游戏角色对玩家来说只是有趣和吸引人的机器，玩家可以与之互动甚至利用，但需求仍然常常需要不仅仅是严格的布尔选择逻辑。因为在需要的任何地方手动编码模拟选择逻辑很快就会变得混乱，所以需要一个更好的解决方案。
基于效用的决策直接解决了这个问题。我们可以应用现有的、有良好文档记录的技术，以优雅的方式处理 “灰色区域” 的决策，而不是通过随机性来创造变化或迫使智能体任意选择一个有效选项而不是另一个。最令人满意的是，我们可以做到这一切，而无需通过强加结构变化来根除现有的实现，并且我们不必放弃行为树的任何最理想的特征。
本文提出了一些简单的组件，使效用考虑能够集成到行为树的正常选择过程中。这种集成的明确目标是在不牺牲行为树优势的情况下，克服行为树架构的许多最大弱点。
10.2 为什么选择行为树？
行为树的受欢迎程度一直在稳步增长，这是有充分理由的。简单地说，它们为决策提供了一种非常务实的方法。我发现它们的简单性是最有价值的，在一个软件日益复杂的世界里，简单性不应被低估。现代游戏中构成人工智能的系统的集合正在变得庞大，而且短期内不会缩小。找到适合团队的方法并尽量避免不必要地强制新的学习曲线是很重要的。
行为树在行业中已成为某种标准。许多 AAA 工作室使用行为树技术，包括 Bungie 的《光环》系列 [Bungie 07] 和 Crytek 的《孤岛危机 2》[Crytek 11]。网上有关于行为树的丰富信息，对于希望快速入门的开发人员，现有的工具包可供使用 [Champandard 08, Brainiac 09]。本章包含的实现是基本的，但也是相对完整的，可免费用于任何用途。要了解更多关于开发人员如何不断改进传统行为树的信息，Alex Champandard 的行为树工具包提供了如何实现您的行为树以优化控制台等系统的性能和内存访问模式的提示，这些系统需要额外的关注 [Champandard 12]。
对于我的团队来说，行为树的可访问性和可扩展性使我们将其用作决策的主要机制。生产力在很大程度上取决于设计师、脚本编写者和动画师对给定角色意图如何行为和对变化做出反应的清晰理解。在使用基于 STRIPS 的规划器或之前的有限状态机（FSM）时，我们从未完全实现这一点。在这两种情况下，除了人工智能程序员之外，对于其他任何人来说，“引擎盖下” 发生的大部分事情都是不透明的。就规划器而言，它对设计师来说太有机和神秘了。此外，大多数时候，涌现行为仍然不是一个理想的特征。当需要按定义的顺序将特定的行动序列串在一起时，规划器也会使其变得困难。至于 FSM，缺乏真正的模块化、复杂的状态逻辑以及变得混乱的趋势对设计师和程序员都产生了负面影响。随着 NPC 角色随着时间的推移而发展，需要更复杂的过渡逻辑，这一点尤其如此。特殊情况似乎成为常态，在我们试图与过去的项目和其他游戏团队共享功能时，一路上产生了许多不受欢迎的惊喜。
使用行为树，我们的设计师可以有效地实时可视化正在发生的事情，并可以直观地应用更改或添加，对期望的结果有清晰的了解。程序员也可以轻松监督这些更改。树结构是一个熟悉且相对容易理解的概念，许多行业内的设计师已经在他们工作流程的主要方面以某种形式使用它们。这使我们能够为设计师提供易于采用的调试和创作工具。在开发过程中，当创建复杂工具和追踪bug 会占用宝贵的迭代和内容创建资源时，这是非常宝贵的。
10.3 并非全是美好
游戏所需的功能不断变化，给代码库中的几乎每个系统都带来了压力。人工智能尤其容易受到这个问题的影响，因为它直接由设计驱动，并且在项目过程中比其他具有类似广度和复杂性的系统变化更快。作为程序员，我们有责任质疑我们的解决方案在解决手头问题时的适用性。就决策而言，我发现自己在实现那些没有容易量化的静态优先级或不能直观地归结为简单的是 / 否标准的行为时，经常质疑行为树的适用性。
在标准的行为树中，优先级是静态的。它被直接构建到树中。这种简单性是受欢迎的，但在实践中，它可能会令人沮丧地受到限制。相同的行为可能需要不同的相对优先级，具体取决于上下文。确保我们的怪物猎人的主要武器有完整的弹夹应该始终是一个考虑因素，即使我们只是在丛林中随意巡逻。但是，如果我们与一只凶猛的怪物交战，我们绝对有必要继续造成伤害。行为树的作者经常通过在不同的分支上复制树的部分来处理这个难题，具有不同的条件和 / 或优先级。即使有流畅的子树实例化或引用，这仍然会变得低效、冗长，并且可能脆弱。
当不容易确定简单的是与否决定时，甚至会出现更麻烦的情况。如果我们的战斗选择器正在评估其选项，它应该选择让我们与我们的医生会合并使用他的太空时代治疗技术，还是应该全力以赴迅速击败威胁要吃掉我们所有人的巨大外星野兽？这种决策最好在考虑了潜在的广泛输入组合后做出。
决策很少是二元的，许多行为根本没有我们可以舒适地离线建立的优先级。让我们从一个简单的示例行为树开始（图 10.1）。没有射击能力是寻求医生行为的前提条件，这迫使我们复制该行为，如图 10.2 所示。我们可以首先给寻求医生更严格的条件并使其优先于射击，但这可能会产生相反的问题，即怪物猎人在条件通过的瞬间立即采取寻求医生的行动。这是我们希望通过集成效用解决的基本问题。
怪物猎人
战斗
放松
重新装填 射击 寻求医生
吃饭 小睡 巡逻
图 10.1 这是怪物猎人的一个简单、最小的行为树。
怪物看不见；健康状况非常低
战斗
射击 寻求医生
寻求医生
图 10.2 为了根据运行时条件以两种不同的优先级实现寻求医生，我们只能在树中进行复制。
10.4 什么是效用理论？
就其应用于游戏人工智能行为而言，效用理论只是测量特定行动的相对适用性的过程 [Mark 09]。为了做出好的决策，我们需要量化一个选项在考虑所有相关事实时的价值，而不仅仅是根据有效性做出决定。提倡使用效用理论的行业老手喜欢提醒我们，很少只有一个正确的决策。那么问题是：为什么我们仍然偏爱无法优雅地解决这个问题的决策架构？
实际上，一个中等复杂程度的智能体可能同时有数十个潜在选项。甚至可能有几个完全合理的选项。效用理论认识到决策很少是黑白分明的，并试图正式解决将各种模拟信息组合在一起做出最终决定的复杂性。弄清楚如何以逻辑方式识别和比较信息是很大的挑战。最重要的目标是确保在任何输入组合的情况下，总体计算都是可靠的，并且总是导致合理的选择。
10.5 在决策中应用效用
游戏智能体是游戏特定设计范围内自主实体的近似。因此，在大多数游戏中，为了人工智能决策而深入分析大量数据是不值得的。输入过于广泛实际上会稀释它们的意义，导致模糊甚至不合逻辑的公式。我们所关心的只是在游戏背景下为玩家构建一种可信且吸引人的体验。
首先，努力以一种能够直接比较的方式表示输入值是值得的。这有助于避免令人困惑的苹果与橙子的困境。一种简单的方法是确定一个共同的测量单位。这很像解决一个方程组。我们可以用其他一些更容易理解的变量的组合来代替一个变量。如果我们要组合两个输入，将它们都表示为时间、健康、弹药、增长 / 消耗率或更抽象的东西是有意义的。例如，如果我们的怪物猎人健康状况不佳，并希望考虑与小队的医生会合以获得健康提升，我们可以用获得的健康点数来衡量接受治疗的好处。然而，疯狂地跑到安全位置可能会引起外星野兽的注意，使我们处于危险之中。如果我们可以通过预测我们在运输过程中可能失去的健康来衡量风险，那么现在两个输入都以健康点数为单位，可以直接组合和 / 或比较，如公式（10.1）所示。我们可以简单地将它们相加，如果净值为正，采取这个行动就有一些我们可以与其他行动权衡的好处。

更理想的情况是，通过给我们在运输过程中失去的健康量附加更多的权重，我们可以确保只有在我们期望获得大量健康净值时才采取这个行动，如公式（10.2）所示。毕竟，收支平衡将是浪费我们原本可以用来杀死怪物的时间。我们还希望高度确信，即使我们的预测过于乐观，我们也不太可能最终健康净值为负，结果看起来相当愚蠢。当然，我们还可以做更多的事情，例如对 HealthLost 应用指数尺度，这会导致效用随着风险的增加而更快地下降，如公式（10.3）所示。

如果我们无法以如此容易关联的单位表示输入值，并且我们希望考虑的不仅仅是健康的净变化，会发生什么？解决这种情况的一种方法是将各种影响组合成更高层次、更抽象的值，如 “士气”、“威胁” 等。跑去看我们的医生的效用也可以考虑我们本来可以用来伤害怪物的损失时间。具体来说，我们可以采用上面的公式，对结果进行归一化，并将其分类为 “治疗” 因素。接下来，我们可以生成第二个公式来表示这个损失的时间，对其进行归一化，并将其分类为 “延迟”。我们现在有两个表示更高层次估值的归一化数量，我们可以将它们组合成最终的效用值。
Utility = \frac{\left({\left.\right. ^{*} \square - Delay ^{*} DelayPower \right)}{{\square + DelayPower }} \quad(10.4)
在上面的示例中，我忽略了归一化的概念。然而，为了逻辑地比较苹果和橙子，归一化过程从根本上是重要的，因为它本质上将更复杂的底层计算 “烘焙” 成一个单一的可用值。通常，这涉及将原始值（健康、时间、弹药、伤害等）通过归一化函数运行，以生成从 0 到 1 的实数。归一化函数最常见的是线性、指数或 S 形，但可以是任何形式。在单个公式不足以表示所需归一化的情况下，响应曲线是一种优雅的解决方案，允许将曲线分解为段，可以进一步微调 [Mark 10]。您选择的曲线会极大地影响结果，因此通常是即时调整的目标。出于这个原因，我建议将这些公式构建到您可以表示为可重新加载数据的组件中，您和您的设计师可以进行调整。归一是一个深入的主题，在可用的材料中可以发现很多智慧。[GameAI.com](https://gameai.com/)、GDC Vault 上的论文以及本文引用的阅读材料都为基于效用的人工智能和行为建模提供了出色的背景。
10.6 效用选择器
行为树结构非常适合扩展性。毕竟，它只不过是一个树遍历，其中节点本身负责并能够自定义树的扩展。树已经具有一个用于选择在执行期间采取哪些分支的组件，即选择器。为了引入基于效用的选择，我们将简单地创建一种新的专门类型的选择器，它不仅考虑其子节点的二元有效性，还考虑它们的相对效用。我们将巧妙地将新节点类型称为效用选择器。
为了简单起见，让我们考虑一个普通的行为树实现。每次执行都会遍历树，直到遇到一个忙碌的节点，此时执行将暂停，直到下一次更新。当效用选择器执行时，它首先查询每个子树的效用值。如果我们首先收集这些结果，我们可以应用几种选择方法中的任何一种。首先，我们可以简单地选择效用最高的子节点。或者，我们可以将子节点分类到桶中并进行加权随机选择。根据场景，我们甚至可以在效用值超过某个阈值的子节点中应用未加权随机选择，超过该阈值的选项被认为是可取的。我们所做的本质上是在标准选择器中添加效用收集，并使用数据动态确定优先级。通过最小的努力，我们打破了可以说是基于行为树架构的最大缺点 —— 静态优先级。事实上，我们可以通过将战斗转换为效用选择器来解决我们与寻求医生的问题，如图 10.3 所示。
战斗作为效用选择器
战斗 射击 寻求医生 重新装填
在原始树中将战斗转换为效用选择器，解决了射击与寻求医生的难题。

10.7 传播效用
效用选择器只是查询其子节点的效用值。通常只有叶行为会进行效用计算，但效用选择器的子节点可以是任何节点类型，包括复合节点甚至另一个效用选择器。为了使效用信息直观地在树中传播，我们需要为所有复合节点类型重写 CalculateUtility ()。
对于选择器和序列器，最简单的方法是返回从其自己的子节点收集的最高效用值。因此，为了收集必要的效用数据，效用选择器必须展开其子树中的所有节点，可能在一次遍历中进行大量的效用计算。这可能是一个问题，也可能不是，具体取决于您的工作规模，但对于在对随机内存访问模式敏感的平台上的大型行为树中进行复杂的效用计算，这肯定不是理想的。
值得庆幸的是，有一些方法可以缓解这个问题。首先，我们可以将效用计算限制在我们的叶行为实现中的某个间隔内，并返回缓存的值。或者，我们可以在一个完全独立的遍历中为我们树的所有叶节点计算效用值，并进行自己的负载平衡，只留下缓存的值在调用 CalculateUtility () 时使用。
10.7.1 在传播过程中转换效用
为了增加灵活性，节点可以选择在效用在树中上升时修改它。装饰器是行为树中的一个基本概念，指的是可以用于引入各种有用行为特征的单子节点。一些常见的例子包括重复子节点 n 次、监视运行时条件或限制子节点的执行时间，但它们是一种通用工具，具有无限的潜在用途。事实上，没有什么能阻止我们创建一个效用装饰器，它对其子节点的效用值应用某种转换。也许它可以将其子节点的效用乘以某个因子用于加权目的，或者它可以将该值通过自定义函数运行。
为了提供一个简单的例子，假设我们的重新装填行为是一个黑盒，它在内部计算一个归一化的效用值。在大多数情况下，我们可能选择直接将重新装填的效用与它的兄弟节点的效用进行比较。然而，在我们的游戏中，我们可能会遇到一种情况，我们希望限制重新装填的效用，直到我们迫切需要弹药。我们可以通过在重新装填上方添加一个效用装饰器来实现这个目标，该装饰器将效用值通过一个简单的 square () 或 cube () 函数运行，如图 10.4 和 10.5 所示。
10.8 行为树的转变：评估与执行
本章中结合的行为树与一些传统实现不同，它将树的评估与实际执行的概念分开，这也是我在专业工作中使用的版本。这样做提供了一些改进机会，超过了典型的行为树实现。其中一个机会是更优化地集成基于效用的决策。最值得注意的是，效用选择器能够在计算效用之前评估其子节点，这意味着它必须仅为有效的子节点更新效用。这可以在随附的源代码的 UtilitySelector 实现中看到。此外，具有昂贵效用计算的叶节点可以在验证其条件时进行工作，并在 CalculateUtility () 中返回缓存的值。
另一个有用的好处是能够独立于智能体的行为执行来评估树。当智能体正在积极执行行为时，我们可以自由地并行评估树，而不会干扰执行节点，并且只有在结果与当前执行计划不同时才进行干预。
对树进行整体评估还意味着我们可以选择执行有限版本的前瞻规划，因为我们可以确保整个计划至少在评估时是有效的，然后再将其提交给智能体。在不希望这样做的情况下，节点仍然可以推迟验证，直到它们被执行，使它们能够像在典型的行为树流程中一样行为。
10.9 结论
行为树和效用都是强大的概念，由于它们易于实现和实验，因此变得实用。如果您还没有这样做，我强烈建议您在专业工作中将它们作为潜在的解决方案进行尝试。当结合效用行为树时，这两种原本不相关的技术可以帮助解决跨类型和范围的各种行为问题。
我们从一个直接的行为树实现开始，并且没有进行任何根本性的更改，我们引入了仅在需要的地方融入基于效用的决策的能力，在其他地方保留树的默认行为。虽然这里的示例范围有限以确保清晰，但希望您已经确定了在实际应用行为树时可以帮助您解决实际问题的情况。除此之外，希望您可以利用基于效用的决策来进一步改善您的角色的行为。
我正在一个非常苛刻的商业项目中继续开发行为树和效用的共存，以满足我自己的需求，该项目具有数十个独特的 NPC 角色，涵盖广泛的分类。我想分享我到目前为止的发现，因为在实践中结果令人惊喜。我们能够代表从简单的野生动物到具有大量特殊能力的自主野兽，再到具有独特和模糊能力的士兵，他们必须有效地模仿人类玩家，所有这些都具有相同的行为基础和工具集。例如，巨大的野兽可以动态地权衡针对多个目标的不同类型的攻击，人类士兵可以评估并使用他们的深度库存来合作击败目标、治疗和复活队友，并结合策略。效用的集成在减轻复杂性方面非常有帮助，因为角色可以在决策过程中权衡多个因素，这种方式直观且 “合理”。与其与单一教科书架构的限制作斗争，一个易于实现的混合体提供了大量的能力，而不会牺牲可用性。
