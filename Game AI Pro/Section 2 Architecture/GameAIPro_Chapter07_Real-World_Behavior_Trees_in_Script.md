二杠四、脚本中真实世界的行为树
迈克尔・达维
7.1 引言
虽然人工智能程序员有许多不同的架构可供选择，但行为树因其编码和使用简单，是游戏中实现 NPC 动作选择最受欢迎的算法之一。它们可以从零开始快速实现，并且可以根据需要扩展以添加额外的功能或提供特定于游戏的功能。虽然它们不像有限状态机那么简单，但它们仍然足够简单，其他团队成员也可以轻松调试和设计，因此适合在有大型团队实施行为的游戏中使用。
在《阿玛拉王国：惩罚》中，我们编写了一个行为树系统，该系统使用脚本编写的行为，而算法本身在 C++ 引擎中处理。这使得设计团队能够快速迭代行为，而编程团队则保留对算法功能以及引擎如何处理行为树的控制。在这里，我们展示了该算法简化版本的功能实现。它可以 “按原样” 使用，也可以扩展以满足更苛刻的应用需求。此外，我们讨论了在《惩罚》的开发中使用这样一个系统的一些优缺点。
7.2 架构概述
示例代码中实现的行为树算法非常简单，只需要了解树的数据结构。树中的每个节点都是一个行为，具有定义该行为何时运行的前置条件和定义智能体执行该行为应做什么的动作。定义了一个根行为作为起点，并按顺序列出子行为。从根节点开始，检查行为的前置条件，如果确定该行为应该运行，则执行该动作。算法将继续处理该行为的任何子节点。如果前置条件确定行为不应运行，则依次检查该行为的下一个兄弟节点。通过这种方式，算法递归地沿着树向下，直到运行最后一个叶行为。该算法的伪代码如清单 7.1 所示。可以根据需要经常运行行为树的这个过程以提供行为的保真度，无论是每帧还是对于较低的细节级别则较少运行。
在代码示例中，我们为每个行为定义了类，以及一个 BehaviorMgr 来跟踪加载的每个行为。BehaviorTree 也是它自己的类，因此我们可以定义多个使用相同行为的树并分别处理它们。由于每个 BehaviorTree 由一系列行为组成，因此运行相同行为树的多个角色可以运行 BehaviorTree 类的单独实例。
7.3 定义脚本行为
在脚本中定义行为有几个令人信服的原因。首先，在开发智能体时，快速迭代通常是决定最终行为质量的关键因素。拥有一个可以编写、更改和重新加载行为而无需重新启动游戏的环境是非常理想的。使用脚本语言的另一个原因可能是利用团队的优势。在《惩罚》中，很大一部分设计团队具有编程背景，使得他们能够在脚本中实现行为，而无需太多的编程输入或监督。虽然需要一些编程时间来支持创建在 C++ 引擎和脚本之间来回传递信息的新方式，但总体而言，工程师在行为创建过程中花费的时间比其他方式要少得多。
为了编写我们的行为树以利用脚本编写的行为，我们首先需要将脚本语言集成到 C++ 引擎中。对于《惩罚》，我们选择了 Lua，这是游戏行业中流行的脚本语言。由于 Lua 是用 C 编写的，它可以很容易地插入到现有的引擎中，并且由于它的源代码是免费分发的，甚至可以根据需要进行修改并编译到游戏中。
Lua 定义了一个原生数据结构 —— 表（table），它类似于其他语言中的字典或映射。对于每个行为，我们定义了一个带有该行为名称的表（以避免名称冲突）。表的成员是名为 “precondition” 和 “behavior” 的函数。通过已知的名称，C++ 算法可以在正确的时间查找并调用适当的函数。
7.4 代码示例
除了行为类，本文使用的代码示例还定义了一个 LuaWrapper 类来管理 Lua 集成，以及一个 NTreeNode 类作为通用树类。在 main () 中，创建了一个 LuaWrapper 并用于加载 Scripts 目录中的所有 *.lua 文件，其中每个 *.lua 文件都是一个定义良好的行为。虽然 LuaWrapper::load_all_scripts () 函数是为 Windows 系统编写的，但所有操作系统特定的调用都在该函数中，因此移植到不同的系统应该仅限于该函数。
从那里，根据加载的脚本文件创建一个测试行为树。使用 add_behavior_as_child_of () 函数，可以从头开始创建整个行为树。最后，使用 process () 运行树，它只是在行为树的根节点启动递归函数，并依次测试每个行为。
7.5 集成到游戏引擎中
虽然提供的示例是功能齐全的，但如果将其插入到完整的游戏引擎中，它将拥有更强大的功能。Behavior 和 BehaviorTree 类可以 “按原样” 使用，并根据需要进行扩展。LuaWrapper 也可以按原样使用，但理想情况下，引擎将包括在运行时重新加载 Lua 状态的功能，以便利用能够重写行为并在不重新启动或重新编译游戏的情况下进行测试的优势。
每个智能体都可以定义自己的 BehaviorTree，无论是在代码中还是作为某种数据文件。在《惩罚》中，行为树和行为一样都是资产，因此树有自己的管理器和数据定义，以便于在多种不同类型的 NPC 之间共享。如果行为编写得足够通用，许多不同的智能体不仅可以共享行为，甚至可以共享整个树。
7.6 脚本关注点
虽然具有脚本定义行为的好处是显而易见的，但如果使用这种方法，还需要注意一些特定的问题。
对于游戏程序员来说，首先想到的可能是性能。虽然 Lua 是用 C 编写的，但它仍然是一种垃圾回收语言，并且在 Lua 环境中所有数字都使用浮点数表示。考虑到这一点，《惩罚》采取了一些预防措施来保护游戏的帧率不受不良脚本性能的影响。
首先，由于 Lua 可以直接编译到游戏引擎中，所有 Lua 分配都可以通过引擎实现的任何分配方案进行路由，这意味着可以利用小块分配器来避免一般的碎片问题。通过在已知时间进行预垃圾回收，可以防止 Lua 垃圾回收器在不利的情况下随时运行。特别是，《惩罚》在每帧的预定时间运行垃圾回收器，以避免由 Lua 自行决定时可能发生的帧中回收。
为了在 Lua 中进一步提高性能，对源代码进行了更改，使 Lua 的内部数字系统使用传统整数而不是浮点数。这对脚本编写者产生了一些后果，最明显的是处理百分比的整数，即使用数字 “56” 而不是 “0.56” 表示 56%。一旦这一点得到了很好的沟通，这仅仅是一个脚本风格的问题。
然而，三角函数和几何运算在 Lua 中变得无法完成，虽然这正是计划的结果，但这是一个更大的工作流程变化。由于目的是避免在脚本中进行任何复杂的数学运算，因此计划每当行为或其他脚本需要解决三角或几何问题时，它将向 C++ 引擎请求答案。这意味着虽然大多数数学计算都被排除在脚本之外，但每当需要新的结果时，程序员需要花费更多的时间来编写和测试脚本所需的必要函数。
总的来说，尽管让设计师编写更多的脚本行为仍然是一个积极的时间收益，但程序员在行为开发过程中不能完全放手。在《惩罚》完成后，设计师和程序员都同意在脚本过程中需要更多的正式工程监督；因此，虽然游戏中的大多数行为是由设计师编写的，但团队认为需要更多的协作。一个建议的工作流程是让工程团队的成员对脚本签入进行代码审查，尽管定期审查也可以。
7.7 增强功能
虽然示例可以 “按原样” 使用，但行为树的吸引力之一是根据自己的项目需要实现扩展。可以向这个基本树添加各种各样的附加功能。以下是在《惩罚》中使用的一些示例。
7.7.1 行为资产管理
虽然这个示例只是在给定目录中加载文件，但如果行为树系统需要与大量行为交互，那么拥有某种行为资产管理器来加载和跟踪每个行为会变得更容易。虽然最初这只是将加载行为的责任转移到新的资产管理器，但管理器可以通过为每个行为创建唯一的 ID 来添加新的功能。树可以通过这个 ID 引用行为，而管理器可以确保行为名称的唯一性。通过在一个集中的地方对脚本进行错误检查，可以更容易地发现和从数据错误中恢复。
为您的行为拥有一个资产管理器还有其他优点。虽然这个示例将创建树作为程序的一部分，但理想情况下，树是由游戏开始时读取的某种数据文件定义的。这允许开发外部工具来创建树或甚至定义包含其他树的树。
7.7.2 行为定义额外信息
如前所述，我们的行为定义只是 Lua 中的表，类似于字典或映射。表可以保存任意数据，这个实现利用了这一事实，通过在我们的行为表中存储函数。然而，由于数据没有限制，我们还可以存储与行为相关的任何数据，除了前置条件和行为函数本身。例如，行为可以存储一个单独的参数化数据表供行为内部使用，或供行为树使用的数据。在《惩罚》中，行为根据它们再次运行的重要性向行为级别细节系统指定了一个提示。例如，执行战斗行为的生物比仅仅走向目的地的生物更有可能处理它们的树。
7.7.3 行为类改进
行为类本身可以改进，以允许更快地处理树。在这个例子中，行为必须定义一个前置条件函数和一个行为函数，否则树将无法正确处理。可以使用 lua_isfunction () 系列函数来确定行为或前置条件函数是否存在，然后再调用它们。虽然行为树可以将已知的函数位置推到 Lua 堆栈上，以在每帧确定其存在，但更好的解决方案是行为本身在首次加载时检查和跟踪定义了哪些函数。然后，行为树可以根据行为本身的标志调用或跳过行为函数调用，而在处理树时不会产生显著的性能成本。
7.7.4 先前运行的行为
在调试行为树时，通常知道在给定帧上运行了哪些行为是很有用的。行为树可以跟踪在上一帧或之前的任意帧数上运行的行为。实现这一点的最小方法是使用位字段。通过利用行为树每次运行的布局方式相同的事实，我们可以将位字段的第一个位置分配给根节点，然后是它的第一个子节点，接着是该子行为的任何子节点，然后类似地继续。从算法上讲，我们可以在检查行为前置条件时标记要运行的行为，然后在处理完成后保存该位字段。
实际上，使用这种技术可以大大压缩行为树。例如，一旦行为由资产系统加载并获得唯一的 ID，而不是将行为存储在树中，BehaviorTree 类可以存储指向行为的指针数组，树可以存储该数组的索引，这简化了位字段方法。
7.7.5 on_enter/on_exit 行为
一旦建立了先前运行的行为列表，行为就可以定义一个首次设置的函数或一个在停止运行时进行清理的函数。作为《惩罚》的一部分，我们为每个行为定义了 on_enter 和 on_exit 函数。为了实现这些，行为树类需要在后续的 process () 调用中跟踪上一次哪些行为在运行，如上所述。如果保留了上一个 tick 中运行的行为列表，那么在开始新行为之前，上一个列表中但不在当前列表中的任何行为都可以调用其 on_exit 函数。然后按顺序调用 on_enter 和行为函数。
7.7.6 附加选择器
算法还可以通过改变选择行为的方式来扩展。在《惩罚》中使用的一些不同选择器包括非排他性、顺序和刺激行为。这些选择器中的每一个都略微改变了选择运行行为的方式或改变了运行行为后树的进展逻辑。
非排他性行为像正常行为一样运行，但树在执行后会继续检查该树级别上的兄弟行为。例如，非排他性行为可能会播放声音或设置一些知识跟踪，同时让其他兄弟行为确定实际行动。
顺序行为只要其子行为的前置条件返回 true，就会按顺序运行它们的每个子行为。例如，一个执行近战攻击的行为，其子行为可能是接近目标、发起攻击，然后后退。只要父近战行为返回 true，树就会按顺序执行子行为。
刺激行为是将行为树连接到游戏内事件系统的一种方式，以便智能体可以定义对周围发生的事件的反应行为。每个刺激行为定义了一个特定的刺激，例如发现玩家或听到声音，它可以对此做出反应。刺激行为是专门化常用前置条件的一种方式。在《惩罚》的实现中，刺激行为被视为具有单独前置条件函数的正常行为，该函数会检查运行树的角色上的定义刺激。这个专门的前置条件还会在完成后处理刺激的清理。
任何类型的选择算法都可以与行为树一起工作，这是该系统的主要优势之一。例如，基于效用的选择器可以根据其子行为的效用分数在它们之间进行选择，或者可以实现一个目标系统，根据子行为的后置条件进行选择。虽然任何选择算法都可以工作，但它们通常会通过选择器所需的额外函数或数据来改变行为的定义方式。使用任何类型的选择器的灵活性必须与实现每个不同算法的时间和成本仔细权衡。
7.8 结论
行为树是一种灵活、强大的结构，可作为智能体决策过程的基础，而利用脚本是推动更快迭代和更轻松创建行为的一种方法。能够在运行时编辑和重新加载行为在优化和调试行为时是一个巨大的优势，并且采用数据驱动的行为创建方法可以将该过程向团队中更广泛的人员开放，有助于提高生产速度。此外，由于行为树算法非常灵活，可以快速实现改进和特定于游戏的功能，并且通过在脚本中实现行为，每个行为都可以更新以快速利用新功能。可以在不重新编译或重新启动游戏的情况下更改它们的参数，因此可以快速完成对这些功能的测试。
如果行为树适合游戏，为实现行为提供脚本支持将提供极大的灵活性。虽然在使用脚本语言时必须仔细分析性能成本，但可以采用策略来最小化影响，同时保持拥有快速迭代行为开发环境的优势。