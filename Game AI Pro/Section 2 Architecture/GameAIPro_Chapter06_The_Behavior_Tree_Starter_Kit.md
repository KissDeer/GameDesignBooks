二杠三、行为树入门套件
亚历克斯・J・尚潘达尔和菲利普・邓斯坦
6.1 引言
你已经做了功课，发现行为树（BTs）是一种经过验证和成熟的技术，游戏开发者经常使用它来构建他们的人工智能。行为树不仅为你提供了坚实的基础，还为你提供了很大的灵活性，可以以一种让你完全控制行为和性能的方式包含其他技术。现在你准备好开始编码了！
本文介绍了可以称为行为树的最简单的代码片段，并逐步构建它。相关的源代码称为行为树入门套件 [BTSK 12]，旨在作为一个工作行为树的示例，供你学习。由于它是在开源许可证下，你可以将其作为自己项目的起点。然而，这不是一个可重用的中间件库，重要的是你理解核心概念并掌握代码的所有权。
本文的第一部分描绘了行为树的大局，介绍了一个简单的示例树，并解释了如何构建行为树以及如何使用它们进行人工智能决策。第二部分深入探讨了第一代行为树的实现，包括其所有构建块（例如，序列和选择器）以及对 API 的讨论。最后，第三部分解释了第二代行为树的原理以及它们提供的改进。你将学习到内存优化和事件驱动的实现，这些在现代硬件上的扩展性要好得多。
在本文中，提供了源代码示例来演示这些概念。请注意，本文中的代码清单是为了打印而编辑的，特别是使用了 C++11 语法，并且为了简洁起见采取了一些捷径。有关原始实现，请参阅http://github.com/aigamedev上的源代码。
6.2 大局
为了帮助演示构成行为树的组件，首先看一下这样的树可能是如何构建的是很有用的。以下是一个简单的行为树如何为一个追捕玩家的机器人守卫设计的示例。
6.2.1 一个简单的示例
这个人工智能被分为三个主要行为。首先，如果机器人守卫能够看到玩家，那么如果玩家足够近，它将向玩家射击三次，或者靠近玩家。其次，如果机器人最近看到了玩家但现在看不到了，它将移动到玩家最后已知的位置并四处查看。第三，如果机器人有一段时间没有看到玩家，那么后备行为是移动到某个随机位置并四处查看。

上面的示例展示了使用树构建器模式将行为树的构建与行为树节点分开。（这个示例已为打印进行了编辑。）树构建器及其示例的完整源代码可以在 6.1 节中描述的行为树入门套件源代码的其余部分中找到。
6.2.2 更新行为树
给定一个行为树，游戏逻辑如何更新它？多久更新一次，每次都需要从根节点遍历树吗？这些是关于行为树的常见问题。为了帮助更新行为树，引入一个 BehaviorTree 对象是很有用的，它将作为存储和更新树的中心点。BehaviorTree 对象通常由 BehaviorTreeBuilder 创建，如 6.2.1 节中的示例所示，或者使用另一个从文件加载树的构建器创建。

这是第一代行为树，因此，BehaviorTree 类仍然很简单。它包含一个指向行为树根节点的指针，以及一个 tick () 函数，该函数执行树的遍历。这是行为树的入口点，每当需要更新时都会被调用。通常不需要在每个游戏帧更新行为树，许多游戏决定每隔一帧或每 5Hz 更新每个行为树，以便可以在多个游戏帧中分摊更新所有角色的行为树的负载。
虽然这个例子看起来很简单，并且实现只是将 tick () 委托给根节点，但本文的 6.4 节展示了这样一个集中式 BehaviorTree 类的优势。它启用了几个高级功能，例如通过控制 BT 节点的内存分配来提高运行时性能（6.4.3 节），以及一个事件驱动的遍历，它修改了 tick () 函数的功能以减少节点访问。
6.3 构建块
从大局出发，本节跳到实现的最低级别，自底向上推进，通过新功能逐步增加复杂性。
6.3.1 行为
从编程的角度来看，思考行为的最简单方式是将其视为一个可以激活、运行和停用的抽象接口。在树的叶节点，动作（例如，“开门”、“移动到掩护处”、“重新装填武器”）和条件（例如，“我有弹药吗？”、“我受到攻击了吗？”）提供了这个接口的具体实现。树中的分支可以被视为高级行为，通过分层组合较小的行为来提供更复杂和有趣的行为。
以下是在 BTSK 中如何实现这样一个接口的：

这个 API 是任何行为树的核心，你必须为这些操作建立一个明确的规范，这一点至关重要。例如，代码期望以下契约得到遵守：
・onInitialize () 方法只在第一次调用行为的 update 方法之前被调用一次。
・update () 方法在每次行为树更新时恰好被调用一次，直到它通过返回状态表明它已终止。
・onTerminate () 方法在之前的 update 表明它不再运行后立即被调用一次。
当构建依赖于其他行为的行为（例如本节后面描述的序列和选择器行为）时，记住这些 API 契约很重要。为了帮助确保你不会违反这些假设，可以将这些函数包装到一个单一的入口点中。

这种方法稍微慢一些，因为你必须在每个 tick () 中使用条件分支。大多数复合行为可以更有效地处理这个问题，因为它们无论如何都会处理返回状态。然而，有这样一个包装函数可以避免许多初学者的错误。
6.3.2 返回状态
每个行为在执行时都会返回一个返回状态。返回状态是任何行为树的关键部分，没有它，行为树根本无法工作。实际上，返回状态有两个作用：
・完成状态 - 如果行为已经终止，返回状态表明它是否达到了目的。最常用的两个完成状态是 SUCCESS（表示一切按预期进行）和 FAILURE（表示显然出了问题）。
・执行提示 - 当行为正在运行时，行为的每次更新也会返回一个状态码。大多数时候，这是 RUNNING，但现代行为树可以利用这个状态码提供更高效的实现。例如，SUSPENDED 状态码是事件驱动行为树的重要组成部分，如你将在 6.4.4 节中看到的。
在某些特殊情况下，你可能会想在列表中添加其他返回状态。例如，有些实现区分了预期问题（FAILURE）和意外问题（ERROR）。然而，这会使树的其余部分的代码变得更加复杂，并且不会使行为树更强大。处理失败的更方便的方法是让行为检查它们预期的特定类型的失败，并在树的返回状态之外处理这些情况。
6.3.3 动作
在行为树中，叶节点负责从世界中获取信息并对世界进行更改。进行此类更改的叶行为称为动作。
当一个动作成功地在世界中进行更改时，它返回 SUCCESS；否则就是 FAILURE。RUNNING 状态码表示正在进行处理。动作只不过是一个行为，除了初始化和关闭需要额外的注意。
・初始化 - 除了最简单的动作之外，所有动作都需要与其他系统和对象进行接口以完成工作。例如，特定动作可能需要从黑板获取数据，或向动画系统发出请求。在定义良好的模块化架构中，访问这些其他游戏系统可能会有问题。在设置行为树动作时需要额外的工作，以提供这些动作将使用的系统。这通常通过在节点实例化期间传递额外参数或使用访问者软件设计模式来解决。
・关闭 - 与初始化一样，由于动作依赖于外部系统，关闭动作可能会有问题。在关闭动作时必须特别小心，以确保释放资源不会干扰其他行为。例如，你不能在一个动作关闭后简单地重置动画系统，因为该动作的另一个实例可能最近在其他地方被激活了。
如果需要，可以设置辅助函数来促进动作的初始化和关闭。在大多数情况下，动作将简单地从基类 Behavior 继承功能。
在 6.2.1 节中介绍的机器人守卫示例中使用的一个动作是，如果机器人不再能看到玩家，则移动到玩家最后已知的位置。这个动作可能会指示导航系统将机器人移动到该位置并返回 SUCCESS 状态码。如果由于某种原因导航系统无法执行请求 - 例如，门关闭了，导航系统无法找到到达目标位置的路径 - 动作将返回 FAILURE 状态码。
6.3.4 条件
条件也是树的叶节点，是树检查世界中信息的主要方式。例如，条件将用于检查附近是否有掩护，敌人是否在范围内，或对象是否可见。所有条件实际上都是布尔型的，因为它们依赖于行为的返回状态（成功和失败）来表示真和假。
实际上，条件在两种特定情况下使用：
・即时检查模式 - 根据当前世界的状态，查看条件是否为真。检查立即运行一次，条件终止。
・监控模式 - 随着时间的推移不断检查条件，并在条件为真时每帧都保持运行。如果它变为假，则以 FAILURE 代码退出。
除了能够指定条件的执行模式外，提供一个否定参数也很有用，该参数有效地告诉代码执行完全相反的操作。这允许更简单地重用现有代码，例如检查敌人是否在范围内，以创建一个测试相反情况的条件，即敌人不在范围内。在检查模式下，这是布尔否定，但在监控模式下，条件将在为假时继续运行。
6.3.5 装饰器
构建有趣的行为树的下一步是用其他行为包装行为，为其逻辑添加细节、微妙和细微差别。以面向对象设计模式命名的装饰器行为允许你这样做。可以将它们视为树中只有一个子节点的分支，例如，一个重复其子行为 n 次的行为，一个隐藏其子节点失败的行为，或者一个即使其子行为退出也永远继续的行为。所有这些都是装饰器，对于使用行为树的技术型开发人员非常有用。

基本的装饰器类提供了所有常见功能，以便有效地实现装饰器，例如只存储一个子节点。特定类型的装饰器作为派生类实现；例如，Repeat 装饰器的 update 方法可能实现如下。

在这个例子中，重复行为会一直执行其子行为，直到达到限制。如果子行为失败，装饰器也会失败。当子行为成功时，一旦它被重置，它的下一次执行会立即在同一个 update 中发生。
6.2.1 节中介绍的机器人守卫示例使用 Repeat 条件，如果玩家在射击范围内，则射击三次。像这样的装饰器为行为树引入微妙的行为模式提供了一种简单的方法，而无需在树中复制节点。
6.3.6 复合行为
行为树中具有多个子节点的分支称为复合行为。这遵循软件工程中的组合模式，该模式指定了对象如何组合在一起形成集合以构建复杂性。在这种情况下，我们通过将更简单的行为组合在一起来创建更有趣、更智能的行为。
通常，为复合行为拥有一个基类是一个好主意，以避免子类中的冗余代码。在这个基类中，添加、删除和清除子节点的辅助函数可以只实现一次。

常见的复合行为，如序列和选择器，从这个基类派生。
6.3.7 序列
序列是两种最常见的分支类型之一。序列允许行为树有目的地遵循由设计人员手动指定的 “计划”。序列按顺序执行其每个子行为，直到所有子行为都成功执行或其中一个子行为失败。
6.2.1 节中介绍的机器人守卫的示例行为树在几个点上使用序列将行为组合成更大的行为。一个例子是当玩家不可见时，守卫用于在玩家最后已知位置附近搜索的分支。在这个分支中，第一个行为节点是一个条件节点，用于检查机器人是否有玩家的疑似位置。如果这个条件成功，将运行移动到疑似位置并在该位置周围搜索的动作。否则，如果条件失败，序列节点将失败，行为树将继续执行序列之外的下一个分支 - 搜索随机位置。
在下面的代码中，序列是一个复合行为，它恰好将其子行为一个接一个地链接在一起。

序列的初始化代码从子节点数组的开头开始。update 方法逐个处理列表中的每个子行为，如果其中任何一个失败，则退出。如果所有子行为都成功执行，序列将返回 SUCCESS 状态。
关于这个实现有一个重要的注意事项；在前一个子行为成功后，立即处理下一个子行为。这对于确保行为树在找到要运行的低级动作之前不会错过整个帧至关重要。
6.3.8 过滤器和前置条件
过滤器是树中的一个分支，在特定条件下不会执行其子行为。例如，如果攻击有冷却时间以防止其执行过于频繁，或者行为仅在离目标特定距离内有效等。设计人员可以轻松使用过滤器来定制常见行为的执行 - 例如，为特定角色或情况定制它们。
使用 BTSK 的模块化方法，将过滤器实现为一种序列非常简单。假设过滤器有一个条件，你可以将其附加到序列的开头 - 确保它首先被执行（因此，被检查）。如果过滤器有一个分支（或动作），它将在序列的下一个位置。当然，同样容易设置一个具有多个前置条件和多个动作分支的序列。

你也可以轻松创建条件的布尔组合来添加到过滤器中，这证明了像序列（AND）和选择器（OR）这样的核心行为树节点的强大功能。
6.3.9 选择器
选择器是另一种最常见的分支类型。选择器允许行为树对世界中的障碍做出反应，并有效地触发不同后备行为之间的转换。选择器按顺序执行其每个子行为，直到找到一个成功或返回 RUNNING 状态的子行为。
在 6.2.1 节中描述的机器人守卫行为树示例中，选择器用于决定应该选择三个主要行为分支中的哪一个。首先执行第一个分支 - 攻击玩家。如果这个分支失败 - 例如，如果玩家不可见 - 序列节点将执行第二个分支，在玩家最后已知位置附近搜索。如果该行为也失败，序列将执行最终行为 - 搜索随机位置。
从代码的角度来看，选择器是序列的对应物；代码不仅从复合行为派生，而且看起来非常相似。只有处理特定返回状态的两行不同。

选择器的其余部分与序列的实现相同。同样，请注意，选择器在同一个update()中继续搜索后备行为，直到找到合适的行为或选择器失败。这允许整个行为树在单个帧内处理失败而无需暂停。
6.3.10 并行
并行节点是树中另一种类型的复合分支，它允许你进行更高级的控制结构，例如在执行行为时监视假设是否无效。与其他复合行为一样，它由多个行为组成；然而，这些行为都是同时执行的！这允许同时执行多个行为（包括条件），并且如果其中一些或所有行为失败，则可以中止这些行为。
并行节点与多线程或优化无关。从逻辑上讲，所有子行为都是同时运行的。如果你跟踪代码，它们的更新函数将在同一帧中依次被调用。

对于并行节点，非常精确地指定它是很重要的，这样它可以被直观地理解并可靠地依赖，而无需猜测实现。在这种情况下，有两个参数；一个指定并行成功的条件，另一个指定失败的条件。它是要求所有子节点失败 / 成功，还是只要求一个子节点失败 / 成功？除了枚举，你还可以添加计数器，允许特定数量的行为终止并行，但这会使并行的日常使用变得复杂，而没有任何额外的功能。使用装饰器对子节点进行修改其返回状态，如果必要的话，大多数有用的行为树结构可以用这些参数来表示。

并行的实现遍历每个子行为，并更新它。为所有终止的行为保留计数器，因此可以在之后检查失败策略和成功策略。请注意，失败优先于成功，因为行为树本身应该假设最坏的情况并处理它，而不是不顾一切地继续进行。此外，在这个实现中，一旦满足任何策略，并行就会终止，即使还有行为尚未运行。
当并行因为其终止条件满足而提前终止时，所有其他正在运行的行为必须被终止。这是在 onTerminate () 函数中完成的，该函数遍历所有子节点并处理它们的终止。

并行是更高级行为树控制结构的基础，因此往往会揭示各种各样的小问题，例如如何干净地关闭（见 6.3.3 节）以及如何处理中断行为。对于如何处理在自行终止之前需要中断的行为，例如，当它们在并行节点中一起运行时，有两种思路。
・所有行为都应该有选择继续运行的选项，如果它们愿意，实际上有一个不可中断标志，这将导致父行为等待终止。在这种情况下，abort () 函数成为一个请求，如果在适当的时候，在下次 update () 中会考虑到这个请求。低级行为树，特别是那些直接处理动画控制的行为树，往往受益于这个选项。
・所有行为都应该支持立即终止，尽管它们可以选择使用 onTerminate () 进行清理，onTerminate () 可以可选地给予一个特殊的 ABORTED 状态码。高级行为树最好这样工作，因为它们不想微观管理低级状态；不可中断的动画可以在支持系统的其他地方处理。
BTSK 采用第二种方法。当行为树从一个分支切换到另一个分支时，这是立即完成的，并且任何转换（例如，音频、动画）都必须在切换期间设置并由外部系统管理。然后，在下一个分支中，如果请求相同的系统，它将简单地延迟行为树的请求，直到转换结束（例如，播放声音，播放动画）。
6.3.11 监视器
可以说，持续检查假设是否有效（即监控条件）是涉及并行运行行为的最有用模式。许多行为往往有一些假设，在行为活跃时应该保持这些假设，如果发现这些假设无效，整个子树应该退出。一些例子包括使用对象（假设对象存在）或近战攻击（假设敌人在范围内），以及许多其他例子。
设置这个的最简单方法是重用并行节点的实现，因为监视器节点可以被认为是一个具有两个子树的并行行为；一个包含表示要监控的假设的条件（只读），另一个是行为的子树（读写）。将条件与行为分开在不同的分支中，可以防止同步和竞争问题，因为只有一个子树会运行在世界中进行更改的动作。

与 Filter 完全相同，监视器提供了简单的辅助函数，以确保首先设置条件在并行中。在执行动作之前，这些条件将首先被检查，如果有任何问题，将提前退出。这个 API 仅在你在 C++ 中创建行为树时有用，但很可能你会在你的行为树编辑工具中强加这些顺序。
6.3.12 主动选择器
在生产行为树中，你最可能需要的最后一个构建块是一个 “主动” 选择器，它在做出决策后，会定期主动重新检查其决策。这与传统的 “被动” 选择器不同，它使用另一种形式的并行来重试比之前选择的更高优先级的行为。你可以使用这个功能来动态检查树的某些部分中的风险或机会，例如，如果报告有干扰，则用搜索行为中断巡逻。
在 6.2.1 节的短行为树示例中，主动选择器出现了两次。在行为树的顶层，使用主动选择器来允许攻击可见敌人的高优先级行为中断搜索玩家或随机巡逻等低优先级行为。当守卫机器人看到玩家时，在评估行为时会出现第二个主动选择器的实例。在这里，使用主动选择器，以便如果玩家在范围内，射击玩家的更高优先级行为将抢占如果玩家不在范围内则向玩家移动的低优先级行为。
实现这一点的一种简单方法是在 6.3.9 节的被动选择器中重用一个监视节点，如果更高优先级行为的前置条件满足，则终止低优先级节点。对于具有一个条件的简单情况，这种类型的实现可能更容易，并且对于 6.4.4 节中讨论的事件驱动实现也能有效地工作。然而，你很可能需要一个专门的实现来处理更复杂的情况。

这个主动选择器的实现重用了底层选择器代码的大部分，并通过调用 onInitialize () 强制它每 tick 运行一次。然后，如果选择了不同的子节点，则在之后关闭前一个子节点。另外，m_Current 迭代器初始化为子节点向量的末尾。请记住，如果你不小心，强制中止低优先级行为可能会产生不必要的副作用；见 6.3.3 节。
6.4 高级行为树实现
随着行为树在游戏行业中的普及，实现形式变得越来越多样化，从《光环 2》中的原始实现 [伊斯拉 05] 到《子弹风暴》的事件驱动版本 [PSS 11]。尽管存在多样性，但在过去几年中，行为树的实现方式发生了一些常见的变化。这些变化导致我们在 2011 年巴黎射击游戏研讨会 [PSS 11] 上创造了第一代和第二代行为树的术语。
6.4.1 第一代与第二代树
虽然没有严格的规则来分类行为树的实现，但原始实现和更现代的实现背后有一些常见的模式。一般来说，第一代行为树具有以下特点：
・树小而浅，节点相对较少。
・用 C++ 编写的大型行为，具有 “复杂” 的职责。
・多个行为树实例之间没有（或很少）数据共享。
・实现简单，不担心性能。
・通常写在一个.h 和.cpp 文件中，不一定在 AI 之外可重用。
・行为树的概念主要用作编写 C++ 的模式。
相比之下，第二代树必须应对控制台硬件的转变以及具有额外复杂性和规模的设计。它们的定义如下：
・树更大更深，节点更多。
・更强大的小节点，更好地组合在一起。
・尽可能在多个实例之间共享行为树数据。
・高度优化的实现，以提高可扩展性。
・编写为可重用库，可以应用于任何游戏逻辑。
・行为树成为具有高效解释器的领域特定语言（DSL）。
需要指出的是，第一代实现并不一定比其后续版本差，它们只是满足不同的需求。如果你可以使用更简单的实现来避免第二代的复杂性，那么不要犹豫这样做！
6.4.2 在实体之间共享行为树
对第一代行为树的一个强大扩展是能够在多个实例之间共享数据，特别是树的结构或公共参数。这可以显著减少基于行为树系统的内存需求，特别是在有大量复杂角色的场景中。
共享数据的最重要要求是分离两个概念：
・节点 - 表示行为树节点的静态数据，例如复合节点的子节点指针或公共参数。
・任务 - 执行每个行为树节点所需的瞬态节点数据。例如，序列需要当前行为指针，动作通常需要上下文。
实际上，Task 是运行时实例数据和管理执行的基类。

Task 引用存储共享数据的树节点，包括树结构和参数。然后，Node 实现实际上成为在运行时创建这些任务的工厂，当节点由树执行时。

为了使这两个类与 6.3.1 节中的 Behavior 兼容，只需要将 Node 和 Task 作为成员变量一起保存，并跟踪它们的 Status。节点的工厂函数 create () 必须在行为的 tick () 函数第一次运行之前调用，destroy () 在任务终止后调用。
虽然将行为树数据的这两种形式分开在机械上相对简单，但它对其余代码产生了深远的影响。例如，所有复合节点必须能够在执行之前将节点 “转换” 为任务。这可以在所有复合节点中本地完成，或者 Task 实例可以在类似于 6.2.2 节的 BehaviorTree 类中集中管理。然后，决定是动态分配这些实例还是预先分配它们 - 这通常取决于树的大小和复杂性。下一节将讨论与构成树结构的 Node 对象的分配相关的类似内存问题。
6.4.3 提高内存访问性能
第一代行为树在现代硬件上的一个显著缺点是执行行为树时表现出的内存访问模式。这在当前一代控制台硬件上尤其成问题，因为它们的缓存大小较小，硬件内存预取有限。
内存访问模式不佳的主要原因是行为树节点的动态内存分配。如果没有精心管理，行为树节点存储可能会分散在内存中，导致行为树执行从一个节点移动到下一个节点时频繁的缓存未命中。通过改变行为树节点在内存中的布局，可以显著提高行为树的内存性能。
6.4.3.1 节点分配
改变行为树节点内存布局的核心机制是向 6.2.2 节中介绍的中央 BehaviorTree 对象引入集中式内存分配 API。这些额外的分配函数将负责所有节点的分配。
当这个对象被构造时，它会分配一块内存，所有的行为树节点都将被分配在这块内存中。要实例化一个行为树节点，使用模板化的 allocate 函数而不是正常的分配函数。这个函数使用原地新分配在 BehaviorTree 对象拥有的内存块中分配新节点。

通过使用自定义分配函数分配所有的行为树节点，可以确保一棵树的所有节点都分配在内存的同一个局部区域。此外，通过控制节点的分配顺序（深度优先或广度优先），可以优化布局，减少遍历过程中的缓存未命中。改善行为树遍历时的内存使用模式可以对运行时性能产生重大影响。
6.4.3.2 复合节点实现
由于此更改仅影响节点内存分配，因此 6.3 节中描述的许多行为树节点的内部实现完全不受影响。然而，还可以对其中一些实现进行额外的优化，以进一步改善最终的内存布局。
进一步优化的主要候选者是复合节点：序列、选择器和并行。在 6.3.6 节中描述的简单实现中，这些节点类型中的每一个都在 Composite 基类的 vector<Behavior*> 中存储它们的子节点，导致 vector 类为数据存储进行额外的堆分配。这可以通过将 vector 存储替换为内部静态数组来避免，如下面的代码所示。

在这个例子中，子节点将子节点地址信息作为主要节点数据的一部分存储。每个复合节点包含 n 个子节点的静态存储。在大多数树中，子节点的最大数量限制为 7 通常就足够了。在子节点数量超过此限制的情况下，通常可以使用其他复合节点来拆分较大的复合节点（例如，多个嵌套的序列或选择器）。
除了存储每个子节点的指针外，还可以利用内存中节点的空间局部性，只存储每个子节点相对于复合节点的偏移量。随着支持 64 位指针的编译软件变得越来越普遍，这可以导致显著的内存节省。这里显示的 Composite 节点示例需要 32 字节的内存，而存储指针的朴素实现需要 64 字节，占用当前一代控制台缓存行的一半。
6.4.3.3 瞬态数据分配
在 6.4.3.2 节中应用于行为树节点内存布局的相同转换也可以同样应用于每个节点执行时存储的瞬态数据。
将此瞬态数据视为一个堆栈是很有用的。当一个节点被执行时，它的瞬态数据被推到堆栈的顶部。当一个节点执行终止时，瞬态数据从堆栈中弹出。这种类似堆栈的数据结构非常适合行为树中使用的深度优先迭代。它允许非常简单地管理瞬态数据，并导致非常缓存友好的内存访问模式。
6.4.4 事件驱动的行为树
优化行为树遍历的最后一种方法涉及事件驱动技术。为什么不将树从根节点遍历每帧，只是为了找到以前活跃的行为，而是将它们维护在一个列表中（大小为一个或多个）以快速访问呢？你可以将这个列表视为一个调度程序，它保持活跃的行为并对需要更新的行为进行 tick。
这是事件驱动方法的本质，有两种方法来维护它：
・如果当前执行的行为终止，或者世界（或其黑板）发生变化，则从头开始遍历整个树。这有效地在必要时从头重新填充任务列表，类似于规划器的方式。
・随着行为成功或失败，逐步更新活跃行为的列表。行为终止的父节点可以被请求决定下一步做什么，而不是遍历整个树到根节点。
第一种方法是对传统第一代行为树的简单优化，但第二种方法需要更仔细地实现调度程序，我们将在以下部分深入探讨。
6.4.4.1 行为观察者
事件驱动行为树最重要的部分是观察者的概念。当一个行为终止时，更新它的调度程序也会向父节点发送通知，父节点可以适当地处理信息。

在 BTSK 中，观察者使用基于模板的快速委托实现，但这可以被任何函子实现所取代。
6.4.4.2 行为调度程序
负责管理事件驱动行为树执行的核心代码称为调度程序。

它可以是一个独立的类，也可以留给 BehaviorTree 类来实现，如 BTSK 中所示。本质上，这个类负责在一个中心位置更新行为，而不是让每个复合节点管理和运行自己的子节点。下面的示例对象扩展了 6.2.2 节中首次介绍的 BehaviorTree 类 API，以提供对 BT 任务的管理。

调度程序存储一个活跃行为的列表，在这种情况下，在一个双端队列中，当行为被更新时，从前面取出并推到后面。主要入口点是 tick () 函数，它处理所有行为，直到找到更新结束标记。

这个实现的许多好处之一是支持行为的单步执行。如果必要，可以直接通过 step () 函数来完成。

至于管理行为的执行，start () 的实现只是将一个行为推到队列的前面，stop () 设置其状态并手动触发观察者。
6.4.4.3 事件驱动的复合行为
事件驱动范式在树中的复合节点中最为明显。每个复合节点都必须向调度程序请求更新其子节点，而不是直接执行它们。
例如，让我们看看序列是如何实现的。

由于复合节点依赖于调度程序来更新子节点，因此不需要 update () 函数。序列中第一个子节点的设置由 onInitialize () 函数完成。

序列中每个后续子节点的设置在 onChildComplete () 回调中完成。

事件驱动的代码以更复杂而闻名，但这个复合代码一眼就很容易理解。然而，与第一代行为树实现不同，仅仅通过查看调用堆栈来跟踪行为树会有点困难。
6.4.4.4 事件驱动的叶行为
许多动作和条件不受事件驱动实现的影响，尽管有些可以优化为使用事件驱动方法而不是轮询。例如，等待导航系统回调以终止的监控条件不需要每帧都更新。相反，这个条件可以重写为返回 SUSPENDED 状态，在这种情况下，调度程序在 tick 期间会忽略该行为。
在收到外部通知（例如，来自导航系统）后，事件驱动的条件可以告诉调度程序重新激活它并在更新的下一步中处理它。这种逻辑在更新期间需要特别注意行为的顺序，但可以节省许多不必要的函数调用。
6.5 结论
在本文中，你看到了行为树的多种变体，包括一个简单的第一代实现供你学习，以及一个第二代版本，你可以在自己的项目中用作起点。代码中反复出现一些原则：
・具有简单（独特）职责的模块化行为，组合在一起形成更复杂的行为。
・行为定义非常明确（甚至经过单元测试），易于理解，即使是非技术设计师也能理解。
虽然在实践中这些规则总是有例外，但这种方法对于创建游戏中的行为是可靠的。如果你在代码重复、向设计师解释错误或无法理解行为之间的交互方面遇到问题，那么最好将代码分解为更简单的行为。
本文的原始未编辑源代码可以在开源许可证下在线找到 [BTSK 12]。如果你想查看细节，特别是本文无法涵盖的内容，强烈建议你查看代码！