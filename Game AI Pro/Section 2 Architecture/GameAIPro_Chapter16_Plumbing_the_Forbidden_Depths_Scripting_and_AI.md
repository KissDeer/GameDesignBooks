二杠十三、探索禁忌深渊：脚本与 AI
迈克・刘易斯
16.1 引言
潜藏在当代人工智能工作迷雾深处的是一种备受争议且热议的技术 —— 一种 “黑魔法”，据传它能实现奇妙的事情，但代价高昂。这种被禁止的能力对游戏行业历史上一些最珍贵的游戏 AI 负责…… 同时也对一些最糟糕的尴尬局面负责。我说的是脚本化 AI。
然而，脚本并不需要被恐惧。就像任何好的黑魔法一样，它必须被理解和掌握才能安全地使用 [Tozour 02]。在这里，我们将探讨与开发游戏 AI 相关的脚本的好、坏和危险方面 —— 所有这些都着眼于提供现代玩家所要求的那种动态、适应性强、具有挑战性但又有趣的体验。
当然，有多种方法可以将脚本技术集成到游戏的架构中，但在大多数情况下，它们包括两种基本理念。这些相互竞争的观点可以被认为是 “主人” 和 “仆人” 的意识形态。虽然两者都有其合适的位置，但考虑脚本在给定游戏实现中将扮演的角色是非常有用的。同样重要的是，在开发过程中尽可能保持对该角色的坚持，原因将在后面考虑。
同样，脚本系统的复杂性范围很广，从简单的触发线 / 响应机制到成熟的编程语言。再次，每种可能的方法都有其优点和缺点。与任何技术或工具一样，必须仔细检查和考虑当前的情况，以决定如何最好地部署脚本系统以及它们的实现应该是什么样子。
16.2 主人与仆人
从使用 AI 脚本机制的一开始，理解系统在游戏整体架构中的位置就很重要 —— 不仅是它如何与其他 AI 功能交互，还有它在游戏系统的整体功能方面将如何发挥作用。此外，在开发过程中始终坚持这一决定是非常有益的。如果没有这种纪律，脚本可能会迅速成为难以控制的怪物，消耗大量的调试时间，提供次优的游戏体验，甚至拖累整个开发。
最成功的脚本方法通常属于两个阵营之一。第一种是 “脚本为主人” 的观点，其中脚本控制代理决策和规划的高级方面。另一种方法将 “脚本视为仆人”，其他一些架构控制代理的整体活动，但有选择地部署脚本来实现特定的设计目标或创建某些戏剧性效果。
一般来说，主脚本系统在以下两种情况之一中效果最佳。在最佳情况下，已经存在一个现成的工具库，脚本可以成为将这些技术组合成一个连贯而强大的代理行为总体模型的 “胶水”。即使在没有这样的库的情况下，如果事先知道代理必须能够在许多不同的决策或规划技术之间流畅地转换，主脚本通常也是更好的方法。
相比之下，当设计需要代理行为具有高度的特异性时，仆人脚本最为有效。这是通常认为交互是 “脚本化” 的典型意义；设计师设想了一组可能的场景，AI 实现团队为应对每个场景实施了特殊情况的逻辑。然而，仆人脚本不一定完全是反应性的；简单的脚本化循环和行为模式可以为优秀的环境或 “背景” AI 做出贡献。
大多数游戏设计自然会倾向于主人 / 仆人分歧的一方或另一方。即使游戏本身没有明确倾向于首选方法，人为因素几乎总是会这样。不同的团队在一种风格或另一种风格下工作会更有效，这取决于许多情况：程序员与设计师的比例、从事 AI 工作的工程师的相对经验、时间和预算限制等等。
一个值得考虑的因素是实施任何一种方法所需的投资。主系统往往最适合那些能够利用各种技巧来充实 AI 整体实现的开发人员。仆人系统在代码方面更容易设计和实现，但需要游戏设计方面的额外关注，以避免陷入产生感觉像纸板剪纸的代理的经典陷阱。
当然，也存在其他哲学，但它们可能很难驾驭。将 “脚本化” 逻辑与其他架构方法混合使用往往会导致创建出那种（理所当然地）给脚本带来坏名声的僵硬、不灵活的代理。如果没有明确的边界和责任，不同的系统将开始争夺主导地位 —— 要么在代码的设计和细节的抽象层面，要么在最坏的情况下，在游戏进行时。
16.2.1 脚本作为仁慈的霸主
主脚本哲学的力量源于一个基本原则：授权。脚本的责任不是规定代理行为的每一个细节，甚至不是预测游戏体验中可能发生的每一种情况。相反，一个好的主脚本试图对情况进行分类和优先排序，并将平凡的细节责任移交给其他系统。
分类就是在给定时刻识别模拟中正在发生的事情的性质。知识表示通常是有效地做到这一点的关键；代理必须对他们所居住的世界有连贯和可信的想法，以便他们能够以与他们的世界观一致的方式解释事件，并从而采取适当的行动。请注意，代理不需要有准确或精确的信念，只要他们做的事情从玩家的角度来看是合理的。构建高度复杂的知识系统可能很诱人，但这往往会导致难以理解的决策过程，最终对外部观察者来说感觉是任意或神秘的。
另一方面，优先排序归结为选择如何处理代理对周围环境和情况的了解。对于主脚本，这不是选择行为或状态本身的问题。相反，在优先排序期间，主脚本检查一组低级控制机制，决定哪些机制最适合当前时刻，并选择一个或多个这些机制来为最终决策过程做出贡献。
例如，考虑一个典型的开放世界角色扮演游戏，其中大量代理填充一个城镇。主脚本不应该太关注代理在任何给定时刻碰巧在做的细节。相反，它就像一种抽象的状态机，控制着在任何时间点哪些系统可能控制单个代理。
在和平时期，主人可能会在静止的铁匠代理的简单空闲动画循环之间进行选择，或者可能会分配一个基于效用的系统来监控该代理的欲望和需求，并根据这些需求选择活动。脚本可能会聚集一组代理来扮演城镇民兵的角色，巡逻附近的威胁并维持街道治安；这些代理可能使用群体战术推理和移动系统进行控制，而一只流浪狗可能只是随机游荡并试图吃它在世界上遇到的各种东西。
所有这些都是简单的优先排序。主人监督 “和平” 环境并将代理的责任委托给特定的子系统。这与传统的包容架构完美地协同工作，在包容架构中，代理活动的细节被划分为越来越抽象的层。在最高层，主脚本扮演着仁慈的霸主的角色，协调低级代理和系统的活动，并在必要时处理对于更具体的层来说否则是问题或无法克服的情况。
当和平的小村庄卷入与当地一群流浪哥布林的恶性战斗时，分类就会发挥作用。突然，主脚本必须检测到它一直分配给其仆从的曾经明智的行动不再合适。正是在这里，抽象状态机进行转换，并开始发布一组不同的优先排序和命令。
铁匠，曾经快乐地在铁砧上敲打，可能会突然从制作马蹄铁转变为制作剑。这可以通过改变他的空闲动画来实现，或者简单地调整他的效用输入中制剑的相对优点。民兵必须停止担心当地市场上的扒手，开始建立防线抵御掠夺的哥布林；他们仍然作为一个战术单位行动，但现在具有非常不同的优先事项和行为，可能与他们的维和模式不太匹配。即使是可怜的、肮脏的流浪狗也不能被遗忘：它不再在垃圾堆里寻找食物，而是可能会被发现在城镇的栅栏门后面，对着外面潜伏的阴影敌人竖起毛发并咆哮。
请注意，主脚本不需要以任何特定方式转换到战时状态；事实上，正是选择这种转换方式的自由使脚本成为这种场景的强大工具。如果游戏倾向于沙盒风格，主脚本可能只是检查城镇附近的哥布林数量，并在其 “威胁级别” 超过某个阈值时触发转换。在一个更具叙事性的标题中，主脚本可能会在玩家进入该区域后等待二十分钟，然后发起入侵。
在任何情况下，主脚本的重要灵活性在于脚本活动的一般抽象性。在这个例子中，主脚本很少（如果有的话）处于实际控制任何给定代理的逐次活动的位置。当然，这始终是一种选择，但应该谨慎使用。主架构的整个目的是使更合适的控制方案能够在必要时发挥作用。正是通过这种哲学，主脚本避免了脆弱、可预测、无聊的行为的陷阱。由于脚本只是指导模拟的大致轮廓，其他系统保留了根据模拟的细节以有趣和有意义的方式行动的自由。
16.2.2 脚本作为谦卑的契约劳工
当然，脚本系统不一定需要保持对代理在模拟中行为方式的高级 “主人” 概述。一个完全可行的替代方案是颠倒优先级层次，让传统的行为控制系统负责模拟的总体流程，同时将脚本降级为处理某些特定细节。这是脚本的 “仆人” 方法。
在这种观点中，只有当其他技术无法以易于配置的方式实现设计所需的精确行为时，才会部署脚本逻辑。最常见的是，仆人脚本用于填补设计要求非常具体结果的空白。例如，标准行为树可用于在模拟的大部分时间内规定代理的行为，而脚本在树的特定节点（通常是叶节点）被激活，以实现故事进展的步骤，或对特定刺激做出高度精心制作的响应，等等。
仆人脚本的大部分力量来自于它们的特异性。与旨在完全相反的主脚本不同，仆人脚本通常旨在处理模拟中的狭窄场景范围。这些脚本的 “触发器”，在大多数情况下，寻找事件或输入的非常精确的组合，并且脚本本身创建的代理反应（甚至主动行为）只有在该确切上下文中才有意义。
作为一种用于完善用于创建强大 AI 的技术套件的工具，仆人脚本当然有其地位。以这种方式使用脚本的主要危险在于，仆人脚本在作为其他行为控制系统的补充时使用得越谨慎，效果就越好。
从玩家的角度来看，过度使用仆人脚本会产生脆弱、可预测的行为，并且在与脚本的第一次几次相遇后，行为会变得陈旧。一种常见（且相当合理）的对脚本使用的批评是 “触发线” 技术，其中代理无意识地重复某种特定的行动模式，直到玩家越过沙地上的无形界限，这会将脚本切换到下一组行为。
触发线本身当然并不坏；问题在于在真空中使用仆人脚本。当没有高级系统产生有趣的行为时，脚本化的行为就不再是例外。一旦脚本化行为成为模拟中的常态，玩家可能会很快对与 AI 的重复和过度模式化的交互感到沮丧或无聊。
严重依赖仆人脚本需要对细节的精确关注和预测玩家可能创建的各种情况的详尽能力。这当然是可能的，并且一些值得注意的游戏通过广泛的脚本创建了非常令人难忘和可信的体验。然而，一个严重的风险是创造出 “恐怖谷” 效应。好的脚本可以产生非常沉浸式的结果，直到玩家做了脚本无法预料的事情。在那时，现实感被打破，玩家常常会因为幻觉的不连续性而感到失望。
就像在主脚本中一样，必须保持选择其他技术来产生有趣和引人注目的 AI 行为。这两种方法的关键区别仅仅是脚本控制的极端程度 —— 广义或特定场景。
16.2.3 交叉污染的危害
如前所述，成功管理一群 AI 脚本需要始终坚持仆人或主模型中的任何一个。偏离这些原则可能会带来灾难性的后果。
这主要是由于组织原因。如果没有关于脚本如何部署的明确指导方针，项目几乎不可避免地会在脚本的确切作用方面变得不一致和多样化。结果，模拟中与 AI 代理的不同交互将感觉非常不同。有些可能是高度脚本化和精确控制的，而其他则是松散的，并依赖其他 AI 技术来变得有趣。
在最好的情况下，这种随意使用脚本会给玩家带来不连贯和不一致的体验。在最坏的情况下，交互的混乱和质量的巨大差异会使体验痛苦和不愉快。
前面提到的恐怖谷效应几乎肯定会出现，如果代理的可信度高度可变。当然，出于实际原因，我们可能无法在玩家体验的整个过程中以水晶般清晰的细节来塑造每个代理的整个生命。事实上，大多数大规模模拟被迫接受 “环境” 或 “一次性” 代理的想法，这些代理仅作为背景或填充物存在，通常是低细节级别的生物。
然而，细节级别和保真度级别之间有一条细线。在大多数情况下，玩家愿意接受放弃在模拟中进行极其详细存在的代理。然而，造成问题的是这些代理行为的保真度缺乏。一个特别严重的缺陷是将特定代理的精心编写的行为与作用于同一代理的其他控制技术交织在一起，而不考虑玩家对变化的感知。这是破坏沉浸感的经典配方。代理在对模拟刺激的反应中会感到不一致、任意甚至随机，其净效果几乎总是负面的。
这并不是说所有脚本都必须保持在一个极端或另一个极端；可以肯定的是，可以在模拟的广义或特定控制的不同程度上注入脚本逻辑，如果仔细规划，甚至可以产生很好的效果。关键是要始终注意这对最终用户体验的影响。为此，大量的设计、监督以及不断的测试和迭代至关重要。
16.2.4 对比案例研究：X 系列
在 Egosoft 的太空模拟游戏 “X 系列” 中，我们使用了一系列脚本技术来实现代理 AI。在三个标题的过程中，脚本的总体理念发生了巨大变化，尽管它在主 / 仆范式方面从未真正找到明确的立足点。
对于《X2：威胁》，代理通过随意混合的仆人脚本进行控制。游戏中的每个单独的 “任务” 或小故事情节都是一个单独的脚本化遭遇。此外，内容可以在三个层次中的任何一个实现：C++ 核心引擎、称为 KC 的基于字节码的语言，或仅称为 “脚本引擎” 的第三层，它又在 KC 之上实现。
这迅速创造了前面描述的那种恐怖谷体验；由于代理及其行为的质量和保真度不一致，游戏提供了一个通常不太引人注目的内容拼凑。结果，玩家倾向于被吸引到游戏世界中一小部分被最关注细节实现的地方。
该游戏的续作《X3：重聚》引入了所谓的 “上帝模块”，这至少在一定程度上代表了向主脚本风格的转变。这个模块的目的是观察模拟游戏宇宙的状态，并任意引入事件，这些事件将在一定程度上改变世界。在最极端的情况下，整个空间站区域可以在游戏过程中被这个主脚本构建或摧毁。
不幸的是，由于时间限制，主理念并未始终应用于所有 AI 开发。许多旧的仆人风格仍然存在，并且游戏的很大一部分内容再次遭受质量和细节的持续缺乏。这在发布后通过一些可下载的补丁得到了解决。然而，即使经过广泛的更新，代理行为的不连贯保真度仍然是玩家的常见抱怨。
最后，在《X3：地球人冲突》中，我们引入了一个称为 “任务导演” 的系统。有趣的是，这代表着比名称所暗示的更多地回归到仆人式脚本。任务导演不是试图从高层控制体验，而是允许开发人员 —— 最终是有进取心的玩家 —— 使用通用框架和工具集编写高度简洁和表达力强的脚本。
任务导演的最终结果是使仆人理念得以蓬勃发展。通过访问快速开发工具和关于如何创建新游戏内容的统一策略，《地球人冲突》发布时拥有比任何前作都多得多的手工制作的 AI 行为和任务。
最终，从这个经验中得出的最引人注目的结论是，设计理念的实际选择不如一致应用该决策重要。同样，选择一种非常适合给定项目可用开发资源的设计方法也是非常有益的。
16.3 实现技术
一旦为给定项目选择了脚本角色的指导理念，就该开始考虑实现细节了。在某种程度上，有许多机制可以被视为 “脚本” 的不同程度。这些范围从简单的观察和反应系统一直到嵌入在更大模拟中的成熟编程语言。
在大多数情况下，实现选择与前面概述的哲学选择正交。一般来说，以下部分中详细介绍的任何技术都可以同样适用于主脚本或仆人脚本模型。有一些例外情况，将特别指出，但选择脚本实现方法的主要因素与团队有关，而不是主 / 仆区别本身。
在开始构建脚本系统的旅程之前，值得花一些时间评估情况的具体情况，以确保选择最合适的技术。例如，当模拟的 “脚本” 逻辑的大部分需要由设计师或非程序员人员放置时，观察 / 反应系统具有明显的优势。在另一个极端，滚动自定义语言最好留给具有先前语言创建经验的工程师 —— 尽管根据自定义语言的性质，受众可能不一定需要太多的技术编程经验，正如我们稍后将看到的。
在实现决策的领域，有比这里可以详尽列举的更多潜在有利的方法。相反，我们将查看实现频谱的两个极端，然后检查一个可以部署的中间介质，以平衡其他方法的优点和缺点。
16.3.1 观察和反应系统
典型的观察 / 反应系统是 “触发线”。这是一种简单的机制，用于观察代理在模拟世界空间中的位置，当代理进入（或退出）特定区域时，会触发反应 [Orkin 02]。
在大多数引擎的背景下，触发线的实现非常简单，因为它们只依赖于测试代理的边界体积与模拟空间中其他（通常是不可见的）边界体积的交集。这种功能几乎对于模拟的其他方面都是必要的，例如通用物理或碰撞检测和响应，因此为了实现简单的触发线，几乎不需要编写新代码。
最简单的触发线类似于超市入口处无处不在的自动滑动门；当有东西移动到传感器体积中时，门打开，当一段时间没有东西移动时，门再次关闭。对于琐碎的交互来说，这很好 —— 触发线变得有趣的地方在于选择性反应。
假设我们想在门上安装一个安全系统，以便只有携带适当钥匙卡的人进入传感器体积时门才会打开。这可能会根据模拟的其他部分的性质而变得任意复杂。“钥匙卡” 只是代理上的布尔标志，还是代理可能有需要枚举的库存以找到钥匙？为了有选择地激活触发线，突然需要与模拟的大部分其他逻辑进行接口。
这里的挑战在于提供适当丰富的工具。负责创建 AI 技术的人必须确保实际使用该技术的人拥有完成项目设计目标所需的所有钩子、旋钮、杠杆和设备。虽然可能很想投入所有东西，但在游戏系统本身及其与触发线 AI 系统的交互的前期精心设计中会有巨大的好处。否则，工具可能会变得过于复杂和详细，甚至掩盖了最常用的功能。
在做出这些决策时，上下文至关重要。对于为授权目的创建通用引擎的团队来说合适的东西，与对于以每年几个的速度生产移动游戏的小型灵活团队来说最有意义的东西将有很大不同。虽然两个系统在大致轮廓上可能非常相似，但如果在前期明确界定了模拟的范围，通常很容易将触发线系统的功能集保持在最小化。
观察 / 反应系统可能有许多有用的考虑因素。同样，在选择它们时，上下文非常重要。然而，有一些模式非常广泛适用，值得考虑 —— 即使只是将它们变异为对当前项目更具体有用的东西。
第一个也是最常见的考虑因素是分类。简单地说，这个考虑因素检查刚刚触发传感器的 “事物” 的 “种类”：也许它只检查玩家代理，或只检查 AI 代理，或只检查蓝队的代理等等。一个更强大的选项是允许除代理之外的其他事物触发传感器。如果一个传感器体积随着代理移动，并且该体积被 “调整” 为在手榴弹进入时触发响应，那么使用观察 / 反应架构将手榴弹规避逻辑构建到代理中就变得微不足道。
分类的姐妹技术是属性检查。属性检查可能会查找特定库存项目的存在（或不存在），或根据某个阈值比较值，等等。当需要做出非严格二元的决策时，属性检查也很方便。例如，属性检查可能会在触发响应以根据感知到的威胁派出敌人小队之前查看玩家的健康和弹药水平。
另一个有用的考虑因素是排序。序列要求一个触发线在另一个触发线激活之前被激活。排序允许设计师创建连接事件的线性流。结合可配置的时间，排序可用于仅根据一个事件在逻辑上跟随另一个事件来展开整个故事弧。
去重是另一个方便的技术。这是一个简单的状态标志，它确保特定触发线不会被触发多次，或以超过某些规定速率的频率被触发。这避免了 AI 系统的经典错误，即当英雄在城市大门的门槛上来回走动时，反复向他打招呼。
值得注意的是，与 “脚本化 AI” 这个术语通常所唤起的图像相反，观察 / 反应并不一定会导致严格的线性行为。使用属性检查和序列可以轻松实现分支逻辑。去重可用于确保逻辑不会重复应用于模拟。最后但并非最不重要的是，如前面的手榴弹规避示例所示，可以使用可移动的触发区域。
如果单个代理应用了一组触发线，它可以很快准备好处理模拟世界中的各种突发事件。实际上，限制主要在于设计师的远见和创造力，而不是技术细节。
显然，然而，如果复杂模拟中的所有内容都由各种触发线处理 —— 特别是如果涉及复杂的非线性讲故事 —— 所需的触发线数量很容易呈指数级爆炸。这是简单观察 / 反应系统的主要弱点；由于它们本质上是数据驱动的机制，它们与模拟必须呈现和 / 或响应的情况数量成比例地扩展。即使触发线技术的功能集是简约而优雅的，实现复杂项目可能需要的实际触发数量也可能令人望而却步。
16.3.2 领域特定语言
在实现技术的另一个极端是领域特定语言，或 DSL。DSL 只是一种用于表达特定类型逻辑的工具。严格来说，DSL 的范围可以从仅比文本定义的观察 / 反应系统多一点，到与完整的传统编程语言的复杂性相媲美的复杂怪物。
然而，正如名称所希望暗示的那样，领域特定语言应该正是如此：严格限制以完成一项特定任务或领域。语言偏离这种自我强加的限制越远，它就越有可能成为一种负担而不是资产 [Brockington et al. 02]。通用语言需要付出非凡的努力才能发展到适合通用任务的程度；滚动自定义通用语言几乎自动意味着放弃现有的工具、程序员知识和经过实战测试的代码。因此，始终牢记 “领域特定” 部分是值得的。
简而言之，好的 DSL 的目标是允许实现者使用与他们用来思考想要发生的事情相同的词汇和思维模式来谈论（在代码中）它。DSL 本质上与它们的预期受众密切相关；一种用于帮助直升机飞行员自动导航的语言与用于帮助物理学家校准粒子加速器实验的语言看起来会非常不同。
在创建基于 DSL 的 AI 时的一个关键认识是，没有必要将 AI 的所有功能都归入一种语言。事实上，考虑到这种功能的积累必然会导致语言不再特定而开始变得更加通用，这样做几乎总是有害的。
另一个需要记住的重要事情是，DSL 通常对主要不是程序员的人最有用 [Poiker 02]。DSL 不需要充斥着弯曲的符号和神奇的词语；相反，一个好的 DSL 往往会类似于预期逻辑的设计图的术语和整体结构。如果预期受众倾向于使用某些符号或咒语来描述他们的目标，那么这些东西在 DSL 中应该被视为完全自然的。然而，一个好的语言设计将避免竭尽全力 “看起来” 或 “感觉” 像一种通用编程语言。
简单地说：一个好的 DSL 不应该看起来像 C++ 代码，也不需要一个复杂的解析器、编译器、解释器、虚拟机或任何其他典型通用语言的陷阱。事实上，一个简单的基于空格的标记器应该足以支持大多数 DSL。另一个常见的选择是使用现有的文件格式，如 XML 或 JSON 来编码逻辑，并在这些格式之上提供薄的用户界面，以便用该语言创建实际的程序。最终用户不需要手动编写 XML；他们可以使用舒适、直观的工具来构建他们的逻辑 [McNaughton et al. 06]。同时，没有必要仅仅为了加载生成的脚本而滚动另一个解析系统。好的 DSL 是关于以新的方式利用现有技术，而不是重新发明轮子。
对于大多数 DSL 实现，真正的工作在于指定一种紧凑但可用的语言；实际上解析和执行代码相对简单。简单的技术包括大的开关语句，或从简单的抽象基类或接口派生的 “可执行” 类的组，其中虚拟调度用于触发每个语言 “关键字” 或操作的相应代码。
当然，从理论上讲，存在为执行游戏逻辑而编写整个虚拟机架构的可能性；事实上，这已经在许多成功的游戏中进行了探索，包括前面描述的 X 系列。然而，当涉及到 DSL 时，滚动一个真正的、自定义的 VM 几乎总是一种严重的过度行为。
设计 DSL 的有效指南是创建一种语言，该语言表达在更简单的观察 / 反应架构中可能有用的那种事情。所有标准的考虑都适用：分类、属性检查、排序等等都是语言的基本控制流技术。
与通用语言形成鲜明对比的是，DSL 不需要担心在编写代理行为逻辑方面处理阳光下的每一种意外情况。相反，语言设计师用词汇和语法来构建 AI 实现者组装最终脚本的基础 —— 语言是砖块和灰浆，实际的构建取决于 AI 程序员或设计师来完成。
这些砖块的性质可能对最终构建的建筑物产生深远的影响。因此，就像触发线架构一样，DSL 需要大量特定于上下文的决策才能有效。例如，一种游戏类型的 DSL 不太可能轻易地在完全不同的模拟体验中重用。
值得再次提及的是，将游戏限制在单个 DSL 中通常是一个错误。即使在 AI 系统中，协同部署多个 DSL 也可能非常有效。包容架构与这种方法完美匹配，主脚本系统可能会从为精细控制机制的各个子集部署 DSL 中受益匪浅。
基本思想是将代理行为划分为离散的、定义明确的、紧凑的分组，并为每个分组编写一种语言。描述在世界中自由漫游的代理的行为可能需要与描述同一代理在激烈战斗中的瞬间反应完全不同的语言框架。此外，DSL 甚至可以嵌套 —— 一个 DSL 中的高级 “进入战斗” 命令可能会调用在不同的、更低级的语言中实现的更详细的脚本。
清单 16.1 说明了一个用于控制收集小部件的机器人的简单 DSL 片段。为了简洁起见，机器人不是非常智能，但它应该有足够的基本逻辑来完成其任务并获得许多小部件。不幸的是，它最终可能会尝试获取离家太远的小部件，并在返回充电之前耗尽电量；但扩展逻辑以安全地避免此类小部件应该很简单。
使用 DSL 实现此逻辑的关键优势在于，可以编写任意数量的机器人行为，而无需在更传统的编程语言中编写任何通用控制代码。如前所述，这使更广泛的受众能够为模拟项目创建 AI 脚本 —— 这是一个非常有效的力量倍增器。
请注意，DSL 片段可以使用简单的标记器进行解析；它看起来足够可读，但词汇是经过精心选择的，以便代码可以在运行时被解析并分解为程序内存中一系列简单的命令对象。例如，考虑行 set mywidget = get closest widget to robot。我们可以使用我们选择的实现语言的字符串解析功能将其拆分为一系列由空格分隔的标记。在大多数现代语言中，这只不过是一行代码或一个库函数调用。
接下来，我们从左到右遍历列表。意图总是很明确，无需提前查看流中的其他标记 —— 我们想要设置一个名为 widget 的变量。等号可以被视为装饰，有助于使程序更具可读性。它可以简单地被解析器丢弃。
一旦我们确定该语句是变量赋值，我们就继续 —— 再次从左到右。我们确定我们将执行某种查找（get）。此查找应具体找到模拟中两个实体中最近的一个。最后，我们意识到我们要查找的两个实体是小部件和机器人类型。短语的每个部分都可以直接转换为内存中的某种表示形式，以便稍后执行，而无需复杂的解析算法或对编译器架构课程的噩梦般的回忆。
执行 DSL 代码的典型方法是在加载时处理脚本一次，然后将它们存储在易于快速执行的内存格式中。如果加载时性能是一个问题，大多数 DSL 可以被简单地预处理为二进制格式，这些格式可以更快地转换为内存格式。
执行模型有许多微妙不同的方法，但在大多数情况下，它们归结为一个简单的决定：DSL 代码中的单个指令的执行应该通过虚拟函数调度还是通过开关语句来完成？当然，做出这个决定的具体细节在团队之间、经验水平、架构偏好和策略以及平台性能考虑方面往往会有很大差异。
在虚拟调度模型中，单个指令被实现为从公共接口或抽象基类派生的类。在加载时，来自原始源代码的指令被适当地转换为这些类的实例。在执行期间，脚本引擎只是存储这些对象的容器，并顺序调用诸如 Execute 之类的虚拟函数。
每个指令的参数可以以各种格式存储，但通常一个简单的无类型 DSL 只需要存储表示每个参数值的字符串（或内置字符串的枚举 “标记”）。这允许每个指令具有一个简单的接口，该接口接受一个通用的、无类型的参数容器，它根据指令本身的语义解释该容器。实现完整的类型系统当然是可能的，但重要的是要权衡构建类型系统的工作与这种类型的代码可能提供的（通常是边际的）收益。
基于开关的模型稍微复杂一些。指令是简单的常数值，通常存储在主机语言的枚举概念中。执行 DSL 代码流包括读取指令值，执行开关以调用正确的功能，然后解析指令的参数。
这种方法通常还需要显式执行堆栈以及其他形式的存储的概念。一个强大的模型是通过堆栈传递每个 DSL 指令的参数，并通过黑板机制访问其他状态。黑板可以在不同的 DSL 甚至引擎的核心语言之间共享，允许在各种 AI 层之间无缝传递知识。如果某些例程由于性能或存储原因需要直接在低级代码中实现，这可能特别有用。
在基于开关的实现中，流控制（条件、循环等）也可能更困难。在使用此模型时，拥有汇编语言经验通常是有利的，因为许多相同的概念都在起作用 —— 显式跳转到某些地址进行流控制、无类型存储、执行堆栈等。
相比之下，虚拟调度模型中的流控制很简单：只需创建一个指令类，如循环（例如），它存储自己的附加指令对象容器，并根据循环条件重复执行它们。
总的来说，基于虚拟调度的执行模型更容易实现和维护 —— 特别是扩展 —— 但显然需要虚拟函数操作的成本。然而，如果 DSL 专注于高级行为而不是每帧行为，那么这可能不是一个重大损失；如果代理平均每 3 秒只需要完成一个 “思维滴答”，那么虚拟调度和将代码作为对象存储在内存中的成本对于易用性的优势来说是值得的。
16.3.3 集成架构
无论如何，滚动 DSL 执行引擎是一项相当大的任务，应该仔细考虑与其他选项的对比。一个特别有效的替代方案是使用现有的脚本引擎 —— 甚至是低级实现语言本身 —— 与看起来和感觉像 DSL 但不需要实现投资的特殊定制代码结构协同工作。
这些 “集成架构” 是通过构建一个类或函数（或两者）库来构建的，这些类或函数代表了脚本系统应该可用的功能的总和。然后，“脚本” 只是程序中的模块，只访问该功能的有限子集，而不访问其他任何内容。
清单 16.2 说明了相同的机器人和小部件逻辑，完全用 C++ 实现。这只是高级别的 “脚本”—— 每个调用函数的实现留给想象。显然，像 Wait (); 函数这样的一些元素需要一些思考才能成功实现，但在大多数情况下，这只是良好的代码架构的实践。没有触及渲染器、物理模型，甚至世界状态本身的大部分。一切都是根据被认为适合 AI 使用的简单例程来实现的。
显然，这在很大程度上取决于程序员的纪律。几乎没有什么能阻止程序员直接访问渲染系统中的功能，甚至操作系统本身的功能。可以采取某些措施（限制在 C 和 C++ 中使用 #include，在 C# 中使用 using，在 Java 中使用 import 等），但最终团队的领导要确保所有代码都符合关于 “脚本” 模块应该使用哪些功能的限制。
乍一看，集成架构可能听起来根本不像一个脚本解决方案 —— 没有使用特殊语言，没有外部工具，只有最少的特殊定制逻辑来支持系统。然而，仔细观察，集成架构仍然符合前面描述的主和仆架构的范式，并且可以完成与单独的脚本语言完全相同的事情。
与单独的语言实现相比，使用集成架构有几个主要优点。首先，它允许程序员在不需要太多修改的情况下使用他们现有的语言知识和技能。其次，使用现有语言可以访问所有现有的在该语言中工作的工具 ——IDE、调试器、编译器、分析器等。第三，它消除了逻辑和底层平台之间的一层执行抽象，这在低端硬件上或团队缺乏经验丰富的优化工程师来处理脚本语言实现时，可以是一个实质性的性能胜利。
最后但同样重要的是，集成架构为编写几乎任何大规模代码提供了一种说明性方法。分层方法几十年来一直受到大力鼓励，著名的支持者包括 Fred Brooks 和麻省理工学院的 SICP 课程。学习以这种方式构建代码可以成为创建项目其他部分的干净、良好分离的模块的强大力量倍增器，甚至远远超出 AI 系统的范围。
虽然清单 16.2 中的示例使用 C++，但它不一定是构建集成架构的最有效语言。Lua 是一个非常流行的选项，并提供了一个强大和高性能的框架来构建脚本系统。嵌入式 Python 实现可以使用 yield 语句而不是 Wait () 函数来实现代理之间的协作多任务，工作量非常小。对于碰巧熟悉 JavaScript 的程序员来说，该语言的嵌入式实现可以轻松使用面向回调的事件模型来交错代理处理，如在著名的堆栈（如 Node.js）中使用的那样。
这里的关键权衡是放弃对现有调试和仪器工具支持的访问，以换取一些额外的安全性（可以轻松防止高级脚本语言访问无关功能，如渲染器）和潜在的巨大生产力提升。这是另一个必须根据每个团队甚至每个项目做出的判断，同时考虑团队的技能水平、经验水平、开发偏好等以及目标平台的要求和项目本身的范围。

16.4 编写实际脚本
考虑了主要的技术问题后，是时候继续使用选择的脚本技术构建一个完整且功能正常的 AI 了。尽管主或仆架构的选择以及脚本系统实现的细节可以在脚本化 AI 的结果中发挥重要作用，但真正的艺术性 —— 真正的黑魔法 —— 在于在技术基础之上构建有效的脚本。
通过脚本创建引人入胜的游戏体验存在许多挑战。首先也是最重要的是，重要的是要意识到脚本不能也不应该用于一切。无论在主人还是仆人角色中，脚本在与项目所需的其他技术协同使用时最为有效。
过度使用脚本的主要问题是组合爆炸。试图预测需要脚本化的每一种可能情况是一个失败的主张。不可避免地，玩家会遇到 AI 没有预先编程处理的情况，并且沉浸感将完全丧失，因为 AI 会做一些非常愚蠢的事情。更糟糕的是，AI 看起来越强大，当这些失败发生时，打击就越严重；完美是无法实现的，而且在大多数情况下，脚本系统越接近完美，其缺点就会显得越令人失望。
这可以通过依赖其他技术来缓解，在这些技术中，脚本可能会变得太难手动管理。这些补充技术的选择对每个独特项目的需求非常敏感，但要记住的主要准则是，一般情况需要通用解决方案。脚本在大多数情况下是一种高度特定和集中的创建代理行为的方法，特别是在仆人角色中。它通常不太有效地应对不可预测的各种情况。即使在主配置中，脚本也必须仔细规划，以预测要选择的行为类别，并且当界限变得模糊时，建议委托给其他系统。
16.4.1 迭代
在实现涉及大量使用脚本的 AI 时，快速迭代至关重要。随着脚本的形成，脚本准备处理的场景范围不可避免地会出现差距。此外，玩家期望代理理性或可信地做的事情与实际发生的事情之间也会存在差异。
因此，尽可能频繁和彻底地测试和改进脚本逻辑至关重要。为快速迭代设置工作环境的团队将受益匪浅，因为小问题可以得到解决并转化为连贯的结果。缓慢或不存在的迭代是灾难的秘诀。由于脚本固有的倾向是朝着硬编码和固定解决方案发展，忽视迭代几乎必然会导致脆弱和无聊的行为。
当然，另一方面是，一旦系统通过一定程度的灵活性和适应性，就会越来越难以进行详尽的测试。此时的重大变化会带来严重的风险，即引入的潜在副作用可能比能够可靠地检查和验证的更多。因此，虽然迭代仍然很重要，但限制每次通过所做更改的范围也很关键，以避免不断创造几乎不可能进行满意测试的截然不同的体验。
16.4.2 过渡
在模拟展开的过程中，可能会发生许多过渡：在使用主角色的脚本时行为控制系统之间的过渡，在仆人方法中脚本之间的过渡，在使用包容架构时细节级别之间的过渡，等等。
所有这些过渡都对创建无缝和可信的脚本化体验构成了重大挑战。任何时候代理的控制发生这样的变化，都有可能导致玩家对该代理的感知出现不连续性。
为了帮助缓解这一点，在 AI 本身的设计过程中提前知道会发生哪些过渡是很重要的。每个过渡都必须仔细考虑，以确保交接顺利和令人信服。有一些技巧可以帮助解决这个问题，例如共享知识系统。如果传出和传入的脚本都可以访问完全相同的信息集，那么确保它们的行为一致就会变得更简单。这种技术的另一个有用变体是在两个脚本之间进行显式通信，例如将内部状态数据从一个传递到另一个。
更进一步，可以为某些过渡注入特殊情况的逻辑。例如，在细节级别之间移动时，通过添加额外的过渡级别可以大大提高可信度。这些级别专门用于平滑从一种保真度到另一种保真度的跳跃；它们应该设计为快速出现和消失，并让位于更持久的级别。一般来说，两个系统生成的行为之间的潜在差异越大，使用中间逻辑就越合适。
16.4.3 多样性
对典型脚本化 AI 系统最严厉但最适用的批评之一是缺乏多样性。例如，过度简单地使用触发线系统很容易导致这种不受欢迎的结果：如果英雄每次在某些无形的线上来回走动时都被另一个角色用完全相同的对话欢呼，玩家将不可避免地失去对模拟的沉浸感，并对 AI 留下不太理想的印象。更大规模的例子往往对体验更具破坏性。
出于这个原因，值得在设计前期花一些时间来确保脚本化行为能够避免感觉陈旧或乏味。如前所述，触发线激活的去重是一种简单但有效的方法。一般来说，确保事件不重复（或不经常重复）是改善脚本化 AI 系统感觉的好政策。
当然，过了某个点，为游戏的内容添加更多多样性就会成为一个实际问题。内容的产生不是免费的，所需资产的增加可能是令人望而却步的。在这种情况下，对脚本事件重复频率的简单限制可以大有帮助。
另一个有用的技巧，特别是对于主样式控制系统，是在时间上错开脚本及其执行。换句话说，不是让所有代理在完全相同的时刻开始他们的脚本，而是在脚本的中途将它们放入行动的不同点。这避免了数十个环境 AI 代理以一种类似僵尸的同步方式执行完全相同的例程的怪异机器人外观。这种方法的一个很大的优势是它不需要额外的内容资产；只需为每个代理在不同的时间表上触发行为，随着时间的推移，他们的例程将倾向于分散并形成有趣的新兴交互。
主系统在创建多样性方面往往更容易使用。因为主脚本将代理委托给少数实际控制系统中的一个或多个，所以不同的代理在给定时间不执行相同的控制方案这一事实会自然产生变化。仆人式脚本可以同样多样化和有趣，但需要更多的特殊情况逻辑和设计工作作为代价。
无论如何，脚本通常应该被视为一种 “胶水”，将创建令人信服的代理行为的其他技术相互连接。一些游戏实现可能主要由脚本构建，但最终，对其他机制的依赖变得至关重要。即使只是委托给转向和导航系统，从纯粹的硬连线脚本将控制权交给另一个系统，对于创造良好的多样性并确保 AI 代理能够有效地处理不同情况大有帮助。
16.4.4 惊喜
除了多样性，惊喜是脚本化 AI 中最常缺乏的元素之一。不幸的是，它也是游戏创作中追求的最空灵和主观的品质之一。创建能够让玩家感到惊讶和娱乐的体验是一项艰巨的设计挑战，无论脚本在项目本身中的作用如何。
当然，与设计师和测试人员密切合作（进行迭代反馈）是实现这一目标的核心。然而，有一些技术决策会严重影响创建与游戏 AI 代理的令人惊讶和引人入胜的遭遇的实际可行性。例如，过于复杂的脚本系统（如整个成熟的编程语言）在实现努力方面的成本可能远远超过它们在最终游戏质量方面的交付。这不仅适用于核心技术的实现本身，也适用于使用该技术构建的脚本。
因此，建议倾向于简单的解决方案，这些解决方案需要一点创造力，而不是过于复杂和看似 “强大”的系统。精心设计的触发线系统、简约的 DSL 和精心制作的集成架构都可以以这样一种方式设置，为设计目的提供巨大的灵活性，而不会变得过于复杂。
这里的重要因素是赋予设计师和脚本实现者有效处理玩家可能发现自己的各种可能情况的能力。然而，同样重要的是抵制提前预测每一种可能情况的冲动。这具体取决于是采用主还是仆的方法。
对于主意识形态，对广泛的情况进行分类并通过授权做出适当的反应就足够了。仆人视角需要更多的关注。一般来说，目标是避免为所有可能的情况创建脚本，并允许通用行为控制方案在尽可能多的时间内占据主导地位。这使 AI 能够提供多样化和有趣的体验，同时保留通过脚本创建精心制作的遭遇的潜力。
16.4.5 叙事
也许脚本最有效的应用是创造丰富的叙事体验。当游戏玩法中特定的事件序列旨在以特定方式展开时，脚本是实现这种设计的逻辑选择。希望已经清楚的是，这不是脚本可以成为有效工具的唯一场所，但它肯定是最自然的场所之一。
创建引人入胜的交互式叙事体验绝非易事。就其本身而言，AI 必须被设计为有助于进一步体验，而不是与之对抗 [Barnes et al. 02]。每个人都有这样的故事：看着一个无助的角色在周围混乱和战斗肆虐时坚定地继续他们的空闲动画。稍微不那么常见但同样严重的是，AI 似乎积极拒绝做它应该做的事情的情况。
创建良好叙事 AI 的一个主要组成部分是可见性。开发人员必须始终能够理解 AI 为什么做了特定的事情。在使用脚本时，这通常归结为跟踪代理执行的步骤的日志，以及在适用的情况下，选择了哪些分支以及循环重复了多少次。能够选择一个代理并查看其完整脚本状态的调试列表也是一个非常宝贵的工具。
最终，当一切都协同工作以创造和谐的游戏体验时，交互式叙事最具吸引力。仔细的迭代、对过渡的关注、多样性的提供以及偶尔的惊喜都在实现这一目标中发挥着关键作用。

16.5 结论

脚本常常被视为创建游戏 AI 系统的一种脆弱、无聊和不受欢迎的方法。不幸的是，玩家在享受 AI 交互缺乏深度或多样性的游戏时的负面体验，在很大程度上证明了这种耻辱是合理的。好消息是，这不是一个不可避免的结果；通过适当的关注和投资，脚本可以成为一个非常强大的工具。
有效地使用这个工具需要项目的设计和技术问题之间的密切协调。了解设计计划和要求是成功的关键，提前思考如何实现这些计划也是如此。
此外，脚本必须被视为多样化工具箱中的一种工具。过度依赖脚本必然会产生我们试图避免的那种脆弱、无聊的结果。脚本应该被视为将各种决策、规划和知识表示系统连接成一个连贯而强大的整体的胶水。
同样重要的是，要抵制试图预测脚本可能需要处理的一切的冲动。委托给其他技术和技术对于维护最终游戏体验的质量至关重要。无论这是通过 “主人” 还是 “仆人” 的方法完成，应用的一致性也至关重要。坚持早期选择的设计理念将有助于指导所有脚本逻辑和基础技术的创建。
就像在软件工程中经常出现的情况一样，对于脚本系统来说，简单更好。设计师有一种持久的诀窍，可以创造性地使用（有些人可能会说滥用）他们面前的任何工具集；这可以被利用来产生巨大的效果。与其创建过于复杂和复杂的系统，不如专注于创建简单的系统，这些系统具有灵活性，可以以创造性和有趣的方式使用。
最后但并非最不重要的是，永远不要盲目发布。游戏测试和迭代对于提炼和挖掘游戏的乐趣至关重要，这同样适用于脚本化 AI 和其他任何事情。始终准备根据玩家反馈或设计决策快速调整交互，并保持敏捷。
脚本是一把锋利的刀刃。它们可以实现惊人的壮举，但一个错误的举动可能是危险的。然而，没有必要害怕；通过适当的照顾和控制，脚本仍然是 AI 创作者可用的最强大的技术之一。无论是简单的循环行为还是复杂的、绽放的错综复杂的叙事可能性之树，脚本无处不在。
只需要一些想象力和一些纪律来释放它。