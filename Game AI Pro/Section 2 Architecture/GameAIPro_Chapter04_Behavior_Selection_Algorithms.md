二杠一、行为选择算法概述
  迈克尔・达维、史蒂夫・加戈林斯基、卢克・迪肯、特洛伊・汉弗莱斯和戴夫・马克
  4.1 引言
  随着主机游戏玩家对游戏的要求越来越高，为游戏编写人工智能系统变得越来越复杂。同时，移动平台上的小型游戏也涌现出来，这使得人工智能程序员了解如何在短帧时间内获得最佳行为变得非常重要。
  即使在强大机器上运行的复杂游戏中，非玩家角色（NPC）的范围也可以从玩家可能路过或猎杀的简单动物到需要经受数小时玩家交互的成熟同伴角色。虽然这些示例 AI 中的每一个都可能遵循感知 - 思考 - 行动循环，但该循环中的 “思考” 部分定义不明确。有多种算法可供选择，每种算法都适用于不同的用途。对于在最新主机上实现人类角色来说可能是最佳选择的算法，可能并不适合为基于网络的棋盘游戏创建对抗性玩家。
  本文将介绍业内一些最流行和经过验证的决策算法，概述这些选择，并展示每种算法何时可能是最佳选择。虽然它不是一个全面的资源，但希望它能为人工智能程序员提供对各种算法选择的良好介绍。
  4.2 有限状态机
  有限状态机（FSM）是当今游戏人工智能编程中最常用的行为建模算法。FSM 在概念上简单，编码快速，导致具有低开销的强大而灵活的 AI 结构。它们直观且易于可视化，这有助于与技术水平较低的团队成员进行沟通。每个游戏 AI 程序员都应该熟悉使用 FSM，并了解它们的优点和缺点。
  FSM 将 NPC 的整体 AI 分解为更小的、离散的部分，称为状态。每个状态代表一种特定的行为或内部配置，并且一次只考虑一个状态为 “活动”。状态通过转换连接，转换是指在满足某些条件时负责切换到新的活动状态的有向链接。
  FSM 的一个引人注目的特征是它们易于勾画和可视化。每个状态用一个圆角框表示，连接两个框的箭头表示状态之间的转换。转换箭头上的标签是触发该转换所需的条件。实心圆表示初始状态，即 FSM 首次运行时进入的状态。例如，假设我们正在为一个守卫城堡的 NPC 设计一个 FSM，如图 4.1 所示。
  我们的守卫 NPC 从巡逻状态开始，沿着他的路线行进并留意他所在的城堡部分。如果他听到噪音，他会离开巡逻状态并进入调查噪音状态一段时间，然后返回巡逻。如果他在任何时候看到敌人，他将进入攻击状态以应对威胁。在攻击时，如果他的健康值降得太低，他会逃跑以希望能活下来。如果他击败了敌人，他会返回巡逻。
  虽然有许多可能的 FSM 实现，但查看算法的示例实现会很有帮助。首先是 FSMState 类，我们的每个具体状态（攻击、巡逻等）都将扩展这个类：

  每个 FSMState 有机会在三个不同的时间执行逻辑：进入状态时、退出状态时以及状态处于活动状态且没有转换触发的每个滴答时。每个状态还负责存储一个 FSMTransition 对象的列表，这些对象代表从该状态出发的所有潜在转换。

  我们图中的每个转换都从 FSMTransition 扩展。当此转换的条件满足时，isValid () 函数返回 true，并且 getNextState () 在有效时返回要转换到的状态。onTransition () 函数是在转换触发时执行任何必要行为逻辑的机会，类似于 FSMState 中的 onEnter ()。
  最后，FiniteStateMachine 类：

  FiniteStateMachine 类包含我们 FSM 中所有状态的列表，以及初始状态和当前活动状态。它还包含中央 update () 函数，该函数在每个滴答时被调用，并负责按如下方式运行我们的行为算法：
  ・对 activeState.transtitions 中的每个转换调用 isValid ()，直到 isValid () 返回 true 或没有更多转换。
  ・如果找到有效的转换，则：
  ・调用 activeState.onExit ()
  ・将 activeState 设置为 validTransition.getNextState ()
  ・调用 activeState.onEnter ()
  ・如果未找到有效的转换，则调用 activeState.onUpdate ()
  有了这个结构，剩下的就是设置转换并填写 onEnter ()、onUpdate ()、onExit () 和 onTransition () 函数来产生所需的 AI 行为。这些具体的实现完全取决于设计。例如，假设我们的攻击状态触发一些对话，在 onEnter () 中说 “他在那里，抓住他！”，并在 onUpdate () 中定期选择战术位置、移动到掩护处、向敌人开火等。攻击和巡逻之间的转换可以触发一些额外的对话：在 onTransition () 中说 “威胁消除！”。
  在开始编写 FSM 代码之前，绘制一些像图 4.1 这样的图表来帮助定义行为的逻辑以及它们如何相互连接会很有帮助。一旦理解了不同的状态和转换，就可以开始编写代码。FSM 是灵活和强大的，但它们的效果取决于开发底层逻辑的思考程度。
  4.3 分层有限状态机
  FSM 是一个有用的工具，但它们确实有弱点。向 NPC 的 FSM 添加第二个、第三个或第四个状态通常在结构上是微不足道的，因为所需要的只是将转换连接到少数现有的所需状态。然而，如果您在开发接近尾声时，并且您的 FSM 已经很复杂，有 10、20 或 30 个现有状态，那么将新状态融入现有结构可能会非常困难且容易出错。
  还有一些常见模式是 FSM 不太能够处理的，例如情境行为重用。为了展示一个例子，图 4.2 显示了一个负责守卫建筑物中保险箱的夜班守卫 NPC。
  这个 NPC 将永远在前门和保险箱之间巡逻。假设要添加一个名为对话的新状态，允许我们的夜班守卫响应手机呼叫，暂停进行简短对话，然后返回巡逻。如果守卫在电话打来时处于巡逻到门的状态，那么我们希望他在对话结束后恢复巡逻到门的状态。同样，如果他在电话响起时处于巡逻到保险箱的状态，他应该在转换出对话状态时返回巡逻到保险箱的状态。
  由于我们需要知道通话后应转换回哪个状态，因此每次我们想要重用该行为时，我们都被迫创建一个新的对话状态，如图 4.3 所示。
  在这个简单的例子中，我们需要两个对话行为来实现期望的结果，而在更复杂的 FSM 中，我们可能需要更多。每次我们想要重用一个行为时以这种方式添加额外的状态并不理想或优雅。它会导致状态和图的复杂性爆炸式增长，使得现有的 FSM 更难理解，并且新状态的添加更加困难且容易出错。
  幸运的是，有一种技术可以缓解这些结构问题：分层有限状态机（HFSM）。在 HFSM 中，每个单独的状态本身都可以是一个完整的状态机。这种技术有效地将一个状态机分离成多个按层次排列的状态机。
  回到夜班守卫的例子，如果我们将我们的两个巡逻状态嵌套到一个名为看守建筑物的状态机中，那么我们只需要一个对话状态就可以了，如图 4.4 所示。
  这之所以有效，是因为 HFSM 结构添加了 FSM 中不存在的额外滞后。对于标准的 FSM，我们总是可以假设状态机从其初始状态开始，但对于 HFSM 中的嵌套状态机来说并非如此。请注意图 4.4 中圈出的 “H”，它指向 “历史状态”。我们第一次进入嵌套的看守建筑物状态机时，历史状态指示初始状态，但从那时起，它指示该状态机的最近活动状态。
  我们的示例 HFSM 从看守建筑物开始（如前所示，由实心圆和箭头指示），该状态选择巡逻到保险箱作为初始状态。如果我们的 NPC 到达保险箱并转换到巡逻到门，那么历史状态切换到巡逻到门。如果 NPC 的电话在此时响起，那么我们的 HFSM 退出巡逻到门和看守建筑物，转换到对话状态。对话结束后，HFSM 将转换回看守建筑物，该状态机在巡逻到门（历史状态）中恢复，而不是巡逻到保险箱（初始状态）。
  如您所见，这种设置无需重复任何状态即可实现我们的设计目标。一般来说，HFSM 对状态布局提供了更多的结构控制，允许将更大、更复杂的行为分解为更小、更简单的部分。
  更新 HFSM 的算法与更新 FSM 类似，但由于嵌套的状态机，增加了递归的复杂性。伪代码实现相当复杂，超出了本文的概述范围。对于一个可靠的详细实现，请查看 Ian Millington 和 John Funge 所著的《游戏人工智能》一书中的第 5.3.9 节。
  FSM 和 HFSM 是解决游戏 AI 程序员通常面临的各种问题的非常有用的算法。如前所述，使用 FSM 有许多优点，但也有一些缺点。FSM 的一个主要潜在缺点是您期望的行为可能无法优雅地适应其结构。HFSM 在某些情况下可以帮助缓解这种压力，但并非在所有情况下都可以。例如，如果 FSM 遭受 “转换过载”，并且将每个状态连接到其他每个状态，并且如果 HFSM 没有帮助，其他算法可能是更好的选择。回顾本文中的技术，思考您的问题，并为工作选择最佳工具。
  4.4 行为树
  行为树描述了一种从某个根节点开始的数据结构，由行为组成，这些行为是 NPC 可以执行的单个动作。每个行为又可以有子行为，这赋予了算法树状的性质。
  每个行为都定义了一个前置条件，它指定了智能体执行此行为的条件，以及一个动作，指定了智能体在执行行为时实际应该做的事情。算法从树的根开始，检查行为的前置条件，依次决定每个行为。在树的每一层，只能选择一个行为，因此如果一个行为执行，它的任何兄弟行为都不会被检查，但其子行为仍将被检查。相反，如果一个行为的前置条件不返回 true，算法将跳过检查该行为的任何子行为，而是移动到下一个兄弟行为。一旦到达树的末尾，算法就决定了要运行的最高优先级行为，并依次执行每个行为的动作。
  执行行为树的算法如下：
  ・将根节点设置为当前节点
  ・当当前节点存在时，
  ・运行当前节点的前置条件
  ・如果前置条件返回 true，
  − 将节点添加到执行列表中
  − 将节点的子节点设置为当前节点
  ・否则，
  − 将节点的兄弟节点设置为当前节点
  ・运行执行列表上的所有行为
  行为树的真正优势来自于它的简单性。由于其本质上的直接性，基本算法可以快速实现。由于树是无状态的，算法不需要记住之前运行的行为来确定在给定帧上应该执行哪些行为。此外，行为可以（并且应该）被编写为完全相互不知情，因此从角色的行为树中添加或删除行为不会影响树的其余部分的运行。这缓解了 FSM 常见的问题，在 FSM 中，每个状态都必须知道其他每个状态的转换标准。
  可扩展性也是行为树的一个优势。从如上所述的基本算法开始并添加额外功能很容易。常见的添加是行为的 on_start/on_finish 函数，它们在行为第一次开始和完成时运行。也可以实现不同的行为选择器。例如，父行为可以指定不是选择其一个子行为来运行，而是依次运行其每个子行为一次，或者随机选择其一个子行为来运行。实际上，如果需要，子行为可以基于效用系统类型的选择器（见下文）来运行。前置条件也可以被编写为响应事件而触发，使树能够灵活地响应智能体的刺激。另一个流行的扩展是将单个行为指定为非排他性的，这意味着如果它们的前置条件运行，行为树应该继续检查该级别上的兄弟行为。
  行为树虽然简单而强大，但并不总是选择算法的最佳选择。由于每次选择行为时树都必须从根开始运行，因此运行时间通常比有限状态机要长。此外，朴素的实现可能会有大量的条件语句，这可能会非常慢，具体取决于您的目标平台。另一方面，在处理能力是限制因素的其他平台上，评估树中每个可能的行为可能会很慢。任何一种方法都可以是算法的有效实现；因此程序员必须决定什么是最好的。
  由于行为本身是无状态的，因此在创建看似应用记忆的行为时必须小心。例如，想象一个市民从战斗中逃跑。一旦远离该地区，“逃跑” 行为可能会停止执行，而接管的最高优先级行为可能会将市民带回战斗区域，使市民在两个行为之间不断循环。虽然可以采取措施来防止这种问题，但传统的规划器往往可以更轻松地处理这种情况。
  4.5 效用系统
  许多 AI 逻辑 - 就此而言，计算机逻辑 - 基于简单的布尔问题。例如，一个智能体可能会问 “我能看到敌人吗？” 或 “我没有弹药了吗？” 这些都是纯粹的 “是或否” 问题。从布尔问题中得出的决策通常也同样两极分化。正如我们在前面的架构中看到的，这些问题的结果通常直接映射到单个动作。例如，

  即使结合了多个标准，布尔方程也往往会导致非常离散的结果集。

  然而，许多决策方面并不那么整洁。有许多问题，“是或否” 的答案并不合适。例如，我们可能想要考虑敌人有多远，我还剩下多少子弹，我有多饿，我有多受伤，或者任何数量的连续值。相应地，这些连续值可以映射到我想要采取行动的程度，而不仅仅是是否采取行动。基于效用的系统测量、权衡、组合、评级、排序和整理许多考虑因素，以决定潜在行动的优先性。以上面的例子为指导，我们可以评估我们想要（或需要！）攻击、重新装填、隐藏等的强烈程度。
  虽然效用技术可以用于补充其他架构的转换逻辑，但完全有可能基于效用构建整个决策引擎。事实上，有时候构建基于效用的 AI 比其他方法更可取。这些可能包括有许多可能行动的游戏，并且要么没有一个 “正确” 的答案，要么选择一个更可取的行动可能基于大量竞争输入。在这些情况下，我们不仅仅是使用效用来测量或评级某事物。相反，我们使用它来驱动实际的决策机制。另一种说法是，基于效用的系统不是说 “这是你将执行的一个行动”，而是建议 “这里有一些你可能想要做的可能选项”。
  一个有详细记录的例子是效用在《模拟人生》中的使用。在这些游戏中，智能体（即实际的 “模拟市民”）从他们的环境中获取信息，并将其与自己的内部状态结合起来，为每个潜在行动得出一个优先得分。例如，“我非常饿” 的事实与 “劣质食物” 的可用性相结合肯定比我只是 “有点饿” 更有吸引力。此外，“极好的” 食物的接近性可能仍然会使优先级很高，即使我只是 “有点饿”。请注意，描述符 “极好的”、“相当”、“劣质的” 和 “有点” 实际上是在某个设定的最小值和最大值之间的数字。（一种常用的方法是使用 0 到 1 之间的浮点数。）
  当选择新行动的时候（要么是因为当前行动完成，要么是通过某种中断系统），会使用某种方法从候选行动中进行选择。例如，可以对潜在行动的分数进行排序，以便我们可以简单地选择 “最合适的” 行动 - 即得分最高的行动。另一种方法是使用分数来种子加权随机选择。通过根据这些加权概率投掷随机数，最可取的行动有更高的被选中的机会。随着行动的适用性增加，它的分数增加，被选中的机会也增加。
  基于效用的架构可能更适合其他架构的另一个例子是角色扮演游戏（RPG）。在这些游戏中，智能体的选项通常是多种多样的，并且根据情况，可能只是微妙地更好或更差。例如，考虑选择哪种武器、法术、物品或行动，根据敌人的类型、智能体的状态、玩家的状态等，可能是一个复杂的平衡行为。
  效用架构的另一个适用领域是任何具有经济决策层的游戏系统。例如，在实时战略游戏中构建哪些单位或建筑物的问题，是成本、时间和通常许多优先级轴（例如，“进攻” 或 “防御”）的杂耍行为。基于效用的架构通常可以更好地适应不断变化的游戏情况。因此，与更脚本化的模型相比，它可以更好地从被打乱中恢复，因为脚本化模型可能会要么陷入绝望的困惑，要么只是像什么都没发生一样继续前进。
  这种适应性的主要原因是优先得分是高度动态的。随着游戏情况的变化 - 无论是通过环境的变化还是智能体状态的变化 - 大多数（如果不是全部）行动的分数都会改变。随着行动分数的变化，它们被选为 “合理” 行动的可能性也会改变。行动分数的这种起伏 - 特别是与加权随机选择结合时 - 往往会导致非常动态的涌现行为。
  另一方面，与使用布尔转换决策逻辑的架构不同，效用系统往往有些不可预测。然而，由于选择是基于行动在给定情况和背景下 “有多大意义”，因此行动应该看起来合理。这种不可预测性有好处也有坏处。它可以提高可信度，因为在给定情况下可能发生的各种行动可以使智能体看起来更自然，而不是基于可预测的机器人的 if/then 模型。虽然在许多情况下这是可取的，但如果您的设计要求在非常特定的时刻出现特定行为，则必须特别注意用更脚本化的行动覆盖效用计算。
  使用基于效用的架构的另一个警告是，您获得的所有微妙性和响应性通常都有代价。虽然核心架构通常相对容易设置，并且可以简单地添加新行为，但它们的调整可能会有些挑战。在基于效用的系统中，很少有行为是孤立存在的。相反，它被添加到所有其他潜在行为的堆中，想法是相关的数学模型将鼓励适当的行为 “浮出水面”。诀窍是调整所有模型，以鼓励在最合适的时候最合理的行为闪耀。这通常更多的是艺术而不是科学。然而，与艺术一样，产生的结果往往比仅使用简单科学生成的结果更吸引人。有关基于效用的系统的更多信息，请参阅本书中的文章《效用理论简介》和《游戏 AI 的行为数学》。
  4.6 面向目标的行动规划器
  面向目标的行动规划（GOAP）是由 Monolith 的 Jeff Orkin 在 2005 年为游戏《F.E.A.R.》开创的一种技术，此后已被用于许多游戏中，最近用于《正当防卫 2》和《杀出重围：人类革命》等游戏。GOAP 源自斯坦福研究所问题解决者（STRIPS）的人工智能方法，该方法于 20 世纪 70 年代初首次开发。一般来说，STRIPS（和 GOAP）允许人工智能系统通过提供游戏世界如何运作的描述来创建自己解决问题的方法 - 即可能的行动列表、每个行动使用前的要求（称为 “前置条件”）以及行动的效果。然后，系统获取世界初始状态的符号表示和一些需要实现的目标事实集。在 GOAP 中，这些目标通常从 NPC 可能想要实现的预定目标集中选择，通过某种方法如优先级或状态转换来选择。规划系统然后可以确定一系列行动，允许它控制的智能体将世界从原始状态改变为包含需要为真以满足其当前目标的事实的状态。在经典规划中，理想情况下这将是到目标状态的关键路径，并且该目标将是包含所有目标事实的最容易达到的状态。
  GOAP 通过 “反向链式搜索” 工作，这是一个花哨的短语，意思是从你想要实现的目标开始，找出实现这些目标所需的行动，然后找出为了实现你刚刚确定的行动的前置条件需要发生的事情，依此类推。你继续以这种方式向后工作，直到你到达你开始的状态。这是一种相当传统的方法，在科学界已经失宠，被依赖启发式搜索、修剪和其他技巧的 “正向链式搜索” 所取代。然而，反向搜索是一个可靠的主力，尽管它不太优雅，但它比更现代的技术更容易理解和实现。
  反向链式搜索的工作方式如下：
  ・将目标添加到未完成事实列表中
  ・对于每个未完成事实
  ・移除这个未完成事实
  ・找到将该事实作为效果的行动
  ・如果行动的前置条件满足，
  − 将行动添加到计划中
  − 向后工作以将现在支持的行动链添加到计划中
  ・否则，
  − 将行动的前置条件添加为未完成事实
  GOAP 的一个最后有趣的方面是，它允许 “上下文前置条件”，这些条件被规划系统忽略，但必须在运行时满足，以便执行行动。这允许推理绕过世界的某些方面，这些方面不能轻易地用符号表示 - 例如在开始射击之前确保对目标的视线 - 同时确保通过访问规划期间未提供的信息（以确保搜索仍然可行），这些约束可以得到满足。这使得 GOAP 生成的计划具有一定的灵活性，并且它调用的行动更多地应用于战术级别而不是最基本的执行级别。也就是说，计划告诉你要做什么，但不一定告诉你如何去做。例如，诸如如何建立视线以开始射击的详细说明被省略，可以更具反应性地处理。
  假设我们有一个典型的 NPC 士兵角色，他的目标是杀死另一个角色。我们可以将这个目标表示为 Target.Dead。为了让目标死亡，角色需要射击他（在基本系统中）。射击的前置条件是装备武器。假设我们的角色没有武器，我们现在需要一个行动，也许是从枪套中拔出一把武器来给角色一把武器。当然，这有它自己的前置条件 - 角色的库存中有可用的武器。如果是这种情况，我们刚刚创建了一个简单的拔出武器然后射击的计划。如果角色没有武器怎么办？那么我们的搜索将不得不找到一种获取武器的方法。如果这不可能，搜索可以回溯并寻找射击行动的替代方案。也许附近有一个安装的武器可以用来提供 Target.Dead 效果，甚至有一辆车辆我们可以用来碾压目标。在任何一种情况下，很明显，通过提供世界中可以做的事情的全面行动选择集，我们可以让角色决定应该做什么，让动态和有趣的行为自然涌现，而不是在开发期间设想和创建它们。
  最后，考虑一个游戏，其中武器有最大射程。作为上下文前置条件，我们可以说目标必须在该范围内。规划器不会在其搜索中花费时间试图使其成为真 - 它不能，因为这将涉及推理目标可能如何移动等等 - 但它要么在条件为真之前不会发射武器，要么它将使用替代策略，例如使用具有更长射程的不同武器。
  基于自动规划的 NPC 控制方法有很多值得喜欢的地方。它通过允许设计人员专注于创建将自组装成行为的简单组件来简化开发过程，并且它还允许 “新颖” 的解决方案，这些解决方案可能从未被团队预期到，通常会成为玩家会重新讲述的精彩轶事。GOAP 本身仍然是自动规划所能提供的最容易实现的成果，并且从纯粹的科学角度来看，自它开发以来，该技术的最新进展已经有了显著的进步。话虽如此，如果使用正确，它仍然可以是一种非常强大的技术，并为特定的定制提供一个良好的、适应性强的起点。
  值得注意的是，这些采用以角色为中心的智能观点的方法从开发团队中移除了很多作者和导演的控制。能够 “为自己思考” 的角色可能会在游戏世界中成为不稳定因素，创建的计划虽然对于实现角色的目标是有效的，但并不能实现创造沉浸式和引人入胜的体验的更广泛目标，并且如果例如士兵的计划没有让他经过方便放置的大红桶，这可能会潜在地破坏电影般的场景。
  虽然通过使用知识工程技术和表示技巧来避免这些问题是可能的，但它不像行为树等架构那样直接，行为树将允许所需的行为直接注入到角色的决策逻辑中。同时，GOAP 方法比基于分层任务网络的方法更容易设计，因为在 GOAP 中，您只需要描述世界中对象的机制。
  GOAP 和类似的技术不是万能的解决方案，但在正确的情况下，它们可以证明在创建现实行为和让玩家完全参与的沉浸式感觉角色方面非常强大。
  4.7 分层任务网络
  虽然 GOAP 可能是最著名的游戏规划器，但其他类型的规划器也越来越受欢迎。一种这样的系统，分层任务网络（HTN），已被用于《游击队游戏》的《杀戮地带 2》和《High Moon Studios》的《变形金刚：赛博坦的陨落》等游戏中。与其他规划器一样，HTN 旨在为 NPC 找到要执行的计划。它的不同之处在于它如何找到该计划。
  HTN 通过从初始世界状态和代表我们正在寻找解决的问题的根任务开始工作。然后，这个高级任务被分解为越来越小的任务，直到我们最终得到一个我们可以执行以解决我们问题的任务计划。每个高级任务可以有多种完成方式，因此当前世界状态将用于决定高级任务应该分解为哪组较小的任务。这允许在多个抽象级别进行决策。
  与像 GOAP 这样的反向规划器不同，反向规划器从期望的世界状态开始并向后移动，直到达到当前状态，HTN 是一个正向规划器，这意味着它将从当前世界状态开始并朝着期望的解决方案工作。规划器使用几种类型的原语，从世界状态开始。世界状态代表问题空间的状态。在游戏方面的一个例子可能是 NPC 对世界的看法以及他在其中的位置。这个世界状态被分解为多个属性，如他的健康、他的耐力、敌人的健康、敌人的范围等。这种知识表示将允许规划器推理该做什么。
  接下来，我们有两种不同类型的任务：原始任务和复合任务。原始任务是可以为解决问题而执行的可操作的事情。在游戏方面，这可以是 FireWeapon、Reload 和 MoveToCover。这些任务能够影响世界状态，例如 FireWeapon 任务如何使用弹药，Reload 任务如何重新装填武器。复合任务是可以以不同方式完成的更高级任务，描述为方法。方法是一组可以完成复合任务的任务，以及确定何时可以使用该方法的前置条件。复合任务允许 HTN 推理世界并决定采取哪种行动方案。
  使用复合任务，我们现在可以构建一个 HTN 域。该域是一个代表解决我们问题的所有方式的大型任务层次结构，例如如何作为某种类型的 NPC 行为。以下伪代码显示了如何构建计划。
  ・将根复合任务添加到我们的分解列表中
  ・对于我们分解列表中的每个任务
  ・移除任务
  ・如果任务是复合的
  − 找到复合任务中满足当前世界状态的方法
  − 如果找到方法，将方法的任务添加到分解列表中
  − 如果没有，将规划器恢复到上一个分解任务之前的状态
  ・如果任务是原始的
  − 将任务的效果应用于当前世界状态
  − 将任务添加到最终计划列表中
  如前所述，HTN 规划器从一个非常高级的根任务开始，并不断将其分解为越来越小的任务。通过将每个复合任务的方法的条件与当前世界状态进行比较，来引导这种分解。当我们最终遇到一个原始任务时，我们将它添加到我们的最终计划中。由于每个原始任务都是一个可操作的步骤，我们可以将其效果应用于世界状态，本质上是向前推进时间。一旦分解列表为空，我们将要么有一个有效的计划，要么完全退出，导致我们没有计划。
  为了演示 HTN 的工作原理，假设一个游戏有一个需要编写 AI 的士兵 NPC。根复合任务可能名为 BeSoldierTask。接下来，如果士兵有敌人要攻击或没有敌人，他应该表现不同。因此，需要两种方法来描述在这些情况下该做什么。在有敌人的情况下，BeSoldierTask 将使用需要该条件的方法进行分解。在这种情况下，该方法的任务将是 AttackEnemyTask。这个任务的方法定义了士兵可以攻击的不同方式。例如，如果士兵的步枪有弹药，他可以从掩护位置射击。如果他的枪支没有弹药，他可以冲向敌人并用战斗刀攻击他。编写这些给 AttackEnemyTask 两种方法来完成任务。
  我们对士兵行为的深入研究越多，层次结构就越形成和完善。域的结构自然地适合于人们如何向另一个人描述行为。
  由于 HTN 使用分层结构描述行为，以自然的方式构建和推理角色，允许设计人员更容易地通读 HTN 域，协助编程和设计之间的协作。与其他规划器一样，AI 实际完成的工作保存在良好的模块化原始任务中，允许在不同的 AI 角色中大量重用。
  由于 HTN 是在图中进行搜索，图的大小会影响搜索时间，但有两种方法可以控制搜索大小。首先，方法的条件可用于剔除层次结构的整个分支。这在构建行为时自然发生。其次，拥有部分计划可以将复杂的计算推迟到计划执行。例如，考虑复合任务 AttackEnemy。一种方法可能有子任务 NavigateToEnemy，然后是 MeleeEnemy。NavigateToEnemy 需要路径计算，这不仅可能成本高昂，而且可能受到世界状态的影响，世界状态可能在规划和执行之间发生变化。为了利用部分计划，将这两个任务拆分为两个方法，而不是一个带有子任务的方法：如果敌人超出范围，则为 NavigateToEnemy，如果在范围内，则为 MeleeEnemy。这允许我们在敌人超出范围时仅形成 NavigateToEnemy 的部分计划，缩短我们的搜索时间。
  另一个注意事项是，用户需要构建网络才能使 HTN 工作。与 GOAP 风格的规划器相比，这是一把双刃剑。虽然这允许设计人员在他们试图实现的行为中非常有表现力，但它消除了 NPC 构建设计人员可能没有想到的计划的能力。根据您正在构建的游戏，这可以被视为优势或劣势。
  4.8 结论
  有如此多种行为选择算法可供选择，人工智能程序员必须了解工具箱中的每个工具，以便最好地将每个工具应用于给定情况。哪种算法最适合给定的 NPC 可能取决于游戏、NPC 的知识状态、目标平台或更多。虽然这不是对每个可用选项的全面处理，但了解一些从哪里开始选择选项可能是无价的。通过花时间仔细考虑游戏的需求，可以精心制作一个 AI 系统，在保持开发时间和创建容易性之间的平衡的同时，提供最佳的玩家体验。