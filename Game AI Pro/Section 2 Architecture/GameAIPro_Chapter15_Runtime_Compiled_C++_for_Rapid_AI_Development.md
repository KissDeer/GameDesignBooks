二杠十二、用于快速 AI 开发的运行时编译 C++
道格・宾克斯、马修・杰克和威尔・威尔逊
15.1 引言
脚本语言一直是快速 AI 开发的基础，但随着对 AI 需求的增加，它们的性能缺陷变得越来越成问题。另一方面，传统的 C++ 开发方法通常导致冗长的编译和链接时间，这限制了程序员可以进行的迭代和测试的数量。尽管开发工具在这方面不断进步，但开发人员仍然需要运行构建并加载内容才能看到最终结果，而编辑并继续的方法并不适用于所有代码库或更改。
在本文中，我们展示了如何通过一种新颖的方法，即我们称为运行时编译 C++（RCC++），使用纯 C++ 实现相同的快速迭代时间和错误处理。RCC++ 允许开发人员在游戏运行时更改代码，并快速将代码编译并链接到游戏中，同时保留状态。因此，程序员可以在几秒钟内获得对其更改的反馈，而不是几分钟或更长时间。该技术已在 Crytek 的 AAA 游戏开发中使用，并提供了与 Epic 的虚幻引擎 4 中的热重载类似的结果。RCC++ 代码可在 GitHub 和随附的磁盘上作为许可开源项目获得 [Jack, Binks, Rutkowski 11]。
15.2 替代方法
有多种替代方法可用于在游戏中实现快速迭代时间，每种方法都有其优缺点。总的来说，我们认为没有一种方法提供运行时编译 C++ 的主要优势，并且许多技术可以通过与 RCC++ 一起使用来增强。
15.2.1 脚本语言
脚本语言可能是实现快速迭代的最常见解决方案。最近的一项游戏引擎调查显示，Lua 是游戏开发中最重要的脚本语言 [DeLoura 09]，尽管考虑到虚幻引擎社区的规模，虚幻脚本 [Epic 12a] 可能占据了相当大的市场份额。尽管脚本语言很受欢迎，但我们认为它们在用于核心功能时存在一些问题，即集成开销、性能、工具和调试以及低级支持，如向量操作和多线程。事实上，我们遇到的许多游戏引擎实现都不允许在运行时编辑游戏脚本，这大大降低了使用它们的好处。
用 C++ 编写的游戏需要一个与脚本语言的接口，以便实现功能。有多种技术和方法可以使这相对简单，但当需要更改接口时，将强制进行重新编译和游戏重新加载。
虽然脚本性能正在提高，但仍远低于 C++ 等编译代码的性能 [Fulgham 12]。事实上，Facebook 将其 PHP 脚本代码转移到使用开源交叉编译器 HipHop 预编译的 C++ 中，他们开发 HipHop 是为了解决性能问题。他们发现，在降低 CPU 开销以及系统支出和维护方面有显著好处 [Zao 10]。垃圾回收也可能是一个问题，优化后的系统甚至每帧花费几毫秒 [Shaw 10]。在控制台上，数据执行保护（DEP）阻止虚拟机进行即时（JIT）编译，限制了在 PC 上运行的尖端虚拟机提供的性能优化机会。
调试进入脚本虚拟机的 C++ 应用程序可能非常困难，甚至不可能，并且开发人员日常使用的许多工具，如性能和内存分析器，也可能无法以可追溯到原始源代码的方式查看虚拟机的内部。
C++ 通过汇编语言与本机指令集轻松集成，并直接访问内存。这种低级支持允许开发人员针对增强但常见的功能集，如 SIMD 向量单元、多线程和协处理器单元，如索尼 PS3 的 SPU。
Havok 脚本（最初是 Kore 脚本）是出于解决这些问题的动机而开发的 [Havok 12]，提供了优化的虚拟机以及性能改进、调试器支持和分析工具。
15.2.2 Visual Studio 编辑并继续
编辑并继续是 Visual Studio 中 C++ 的标准功能，在 Visual C++ 6.0 中引入，允许在调试时通过称为 “代码修补” 的技术对代码进行小的更改 [Staheli 98]。然而，有一些主要的限制，最关键的是您不能对影响对象布局的数据类型进行更改（例如类的数据成员），并且您不能对优化的代码进行更改 [Microsoft 10]。
15.2.3 多进程
多进程可用于分离代码和状态，以加快编译和加载时间，可以使用共享内存、管道或更常见的 TCP/IP 在它们之间进行通信。这是许多控制台开发人员使用的基本方法，游戏在控制台上运行，编辑器在 PC 上运行，客户端 / 服务器风格的多人游戏也使用这种方法。如果大部分状态位于另一个进程中，则可以合理简单地实现对其中一个进程的重新编译和重新加载的支持，并且由于进程之间有清晰的分离，这可能是一种方便的方法。然而，通信开销通常将其限制在某些应用程序中，例如能够修改编辑器，而在编辑器进程重新编译和重新加载时，游戏及其游戏状态仍在运行。由于可执行文件需要编译、链接和运行，周转时间仍然相对较长。
15.2.4 数据驱动方法
许多游戏引擎提供数据驱动系统来增强其引擎的灵活性，例如 CryENGINE 3 使用 XML 文件来指定 AI 行为选择树 [Crytek 2012]。由于底层功能可以用 C++ 编写，这种方法可以克服脚本语言的许多问题，同时为不熟悉编程语言的设计师提供一个安全且相对易于使用的环境来开发游戏玩法。虽然像数据驱动的行为树这样的框架可以实现良好的平衡，但这种方法可能会陷入在 XML 中实现脚本语言的境地，伴随着所有相关的问题。
15.2.5 可视化脚本
Epic Games 的虚幻 Kismet 和 Crytek 的 CryENGINE Flow-Graph 等可视化脚本系统为游戏逻辑提供了图形用户界面 [Epic 12b, Crytek 12]。功能块通常用 C++ 编写，具有输入、输出和数据成员，可以进行图形编辑并链接到其他功能块，从而提供创建复杂系统的潜力。这基本上是一个具有增强用户界面的数据驱动系统。
15.2.6 库重新加载
动态链接库（DLL，在 Unix 变体上称为 “共享对象”）可以在运行时加载，提供了一种明显的方法，通过重新编译和重新加载 DLL 来允许快速迭代。对于游戏开发人员来说，一个关键功能是 Xbox 360 和 PS3 控制台都支持动态加载库，iOS（仅用于开发目的，而不是在发布的代码中）和 Android 也是如此。函数和对象指针需要进行修补，并且 DLL 的接口不能更改。如果 DLL 项目的代码很大，编译时间可能会很长，限制了迭代周转。尽管这种方法很有吸引力，但在实践中，将游戏拆分为许多小尺寸的 DLL 并进行维护，以及延迟加载链接和状态保存所需的基础设施，意味着这种方法很少被使用。
15.3 运行时编译 C++
运行时编译 C++ 允许在游戏运行时更改编译后的 C++ 代码。RCC++ 使用 DLL，但不是构建整个项目，运行时编译器只重建和链接所需的最小源文件。通过使用松散耦合技术，依赖关系保持在最低限度。加载生成的动态库，并保存游戏状态，然后使用新代码恢复状态。因此，在游戏玩法或编辑器会话期间，可以在几秒钟内对 C++ 代码进行更改。开发人员不需要管理多个项目配置，因为 DLL 会根据需要自动即时构建。实际上，代码库可以构建为单个可执行文件。图 15.1 展示了 RCC++ 的实际应用。
与编辑并继续不同，RCC++ 允许更改对象布局，包括添加全新的类，并且它适用于优化代码和调试。由于我们处理的是编译后的 C++，我们享受它提供的完整功能集，以及使用访问指令集功能（如 SIMD 和原子操作）的内在函数的能力，以及多线程等操作系统级功能。通过使用一种语言进行开发，我们可以使用我们拥有的所有工具，从无缝调试到性能分析器。有趣的是，现在可以即时修复错误和优化代码。
我们认为这种方法非常适合取代程序员用于快速迭代的脚本，并且通过使用 RCC++，数据驱动系统和可视化脚本语言等设计工具可以很容易地得到增强。其他开发人员似乎也同意这一点；例如，Epic 在虚幻引擎 4 中完全放弃了虚幻脚本，转而采用了一种与 RCC++ 结果相似的方法，称为热重载。通过对 Kismet 可视化脚本系统的改进，保留了设计师的灵活性 [EPIC 12c]。
15.4 运行时编译 C++ 的实现
运行时编译 C++ 的实现包括两个主要组件：运行时编译器和运行时对象系统。运行时编译器处理文件更改通知和编译。运行时对象系统处理源文件及其依赖项的跟踪。它还提供 IObject 基类接口和 IObjectFactorySystem，用于创建对象并在加载新代码时交换它们。这种分离旨在允许开发人员创建自己的动态重新加载代码，同时保留编译器功能。此外，对于控制台和移动游戏，运行时编译器可以更容易地移动到在主机系统上运行的单独进程中。
15.4.1 运行时编译器
运行时编译器为编译器提供了一个简单的 C++ 接口。目前支持 Visual Studio 8.0、9.0 和 10.0 编译器（Visual Studio 2005、2008 和 2010），包括免费的 Express 版本和完整版本，并且可以构建 x86 和 x64 目标。
编译器的主要目标之一是提供快速周转。编译从命令行进程运行，该进程在编译器初始化时实例化，并在编译之间保留。我们发现设置编译的环境变量需要花费大量时间，因此通过仅设置一次并保持进程活动，我们大大减少了小编译的时间。提供了一个简单的编译器日志记录接口，可以实现并传递给编译器以获取编译输出。在 Windows 上的一个方便技巧是除了任何其他日志记录之外，还使用 OutputDebugString () 函数输出此信息；在 Visual Studio 中，然后可以双击任何错误或警告以导航到有问题的源代码。
运行时编译器监视运行时对象系统已在系统中注册的文件，当检测到更改时，它将这些文件及其任何依赖项编译到 DLL 模块中，然后由运行时对象系统加载。
15.4.2 运行时对象系统
运行时对象系统提供了检测代码更改、使用正确的依赖项进行编译以及加载结果模块并切换对象以使用新代码所需的功能。为了使编译尽可能快，编译的依赖项数量最少。
运行时对象系统依赖于 C++ 的虚函数功能，通过简单地交换从旧对象到新对象的指针来交换对象。如果函数是非虚函数，则函数指针将嵌入到调用该函数的任何代码中，因此将始终运行旧代码。一个简单的运行时可修改类可以由一个头文件声明，如下所示：
清单 15.1. 一个示例运行时对象，派生自 IObject。

为了能够在运行时进行更改，我们需要通过工厂风格的构造函数公开这个类。这是通过在.cpp 文件中应用宏 REGISTERCLASS (MyRuntimeModifiableObject) 来完成的，该宏将源文件的路径添加到运行时编译器监视的列表中。当此源文件更改时，我们将源文件与公共运行时对象系统接口代码一起编译到 DLL 中，然后加载生成的模块。即使项目包含许多源文件，在最小情况下也只需要编译和链接两个到模块中。在模块加载后，我们现在有两个或更多名为 MyRuntimeModifiableObject 的类以及它们各自的构造函数，这是可能的，因为每个类都在不同的模块中（例如，一个在可执行文件中，另一个在 DLL 中）。运行时对象系统可用于创建一组新的对象来替换旧对象，使用新的构造函数，并交换它们的指针，以便代码现在引用新类。
我们考虑了几种实现运行时指针交换的技术。两个主要候选者是智能指针，它通过指针表添加了一个额外的间接级别，允许以极低的成本进行对象指针交换，以及使用对象 ID 进行指针替换的所有对象的序列化，这提供了较低的运行时开销，但指针交换的成本较高。为了在更改代码时保存对象状态，我们无论如何都需要进行序列化，并且减少的运行时开销似乎对序列化有利。由于状态只需要从内存中写入和读取，因此这种序列化可以非常快。对于非运行时可修改代码，事件系统允许开发人员在加载新代码时使用对象 ID 来交换对象指针。
使用虚函数引入了一个间接级别，因此性能关键代码区域的开发人员应该查看关于代码优化的第 15.8 节以获取建议。请注意，使用虚函数并不意味着开发人员需要实现具有深度继承树的复杂多态类系统。
为了使运行时代码能够访问非运行时可修改代码的功能，我们提供了一种机制，用于将系统表对象指针传递给运行时代码。然后，这个系统表可用于存储游戏引擎子系统（如渲染、音频、物理等）接口的指针。在清单 15.2 中，我们使运行时对象系统子系统本身可访问，以允许用户强制进行完全重新编译。这个例子取自本书附带的代码示例中的 Pulse 演示（在代码库中称为 SimpleTest）。
运行时对象系统的总体架构最好通过查看其应用的完整示例来阐明，我们将在下一节中进行介绍。
15.5 实践中的运行时编译 —— 逐步示例
在这个例子中，我们将查看实现一个简单的 Win32 控制台应用程序，该应用程序每秒运行一个主循环，调用运行时对象上的更新函数。在下面的列表中，我们删除了一些实现，以便专注于主要元素。再次查看包含的源代码以获取完整详细信息，在 ConsoleExample 项目中。
项目的主要入口点只是构造一个 ConsoleGame 对象，调用其 Init () 函数，然后在循环中调用 MainLoop () 函数，直到该函数返回 false。ConsoleGame 类，它派生自 IObjectFactoryListener，在代码更改后添加新构造函数时接收事件调用，允许我们使用 ID 查找来交换运行时对象指针。数据成员 m_pUpdateable 是我们存储本机指针的地方，而 m_ObjectId 存储运行时对象的 id。
ConsoleGame.cpp 包含 RCC++ 实现所需的基本方面。初始化需要创建一个日志系统（它只是将日志输出写入 stdout）和运行时对象系统，然后将 ConsoleGame 添加为事件的侦听器，然后创建我们的运行时对象 —— 在这种情况下，一个简单地称为 RuntimeObject01 的类。
当加载新代码时，调用 IObjectFactoryListener::OnConstructorsAdded () 方法，我们使用它来将我们的对象指针交换为新代码，如下面的清单所示。
清单 15.5. 在加载新代码后交换运行时对象指针。

主循环首先检查编译是否完成，如果刚刚完成编译，则加载一个新模块。然后，我们更新文件更改通知系统和我们的运行时对象通过 IUpdateable 接口。
如果我们想在运行时更改类声明，则需要一个单独的虚拟接口用于非运行时可修改代码。此接口不应在运行时修改，但头文件跟踪允许更改不同运行时源文件之间的接口。实际上，移动到运行时编译的代码越多，这就越不受限制。我们的控制台示例有一个简单的接口，如清单 15.6 所示；这定义了 Update () 函数，并且也派生自 IObject。
清单 15.6. 更新函数被声明为抽象接口。

清单 15.7. 运行时对象。在控制台示例运行时，可以修改此代码，保存文件会导致编译和重新加载代码。

运行时对象代码相应地简单。在清单 15.7 中定义的类，派生自一个模板，该模板实现了 GetInterface () 成员函数，在这种情况下，它允许我们使用接口 ID（IID_IUPDATEABLE）获取指向 IUpdateable * 的指针。
将这些放在一起，并运行示例，我们能够更改 Update () 函数并保存，在控制台中看到我们的更改生效。清单 15.8 显示了我们在输出中添加 “NEW！” 的会话的示例输出。
15.6 运行时错误恢复
我们认为，为了使 RCC++ 真正实用，它必须具有某种形式的崩溃保护。毕竟，如果您只能避免退出、重新编译、重新加载，直到您的第一个简单错误（空指针迫使您关闭所有并重新开始），那将是一种令人沮丧的体验。我们考虑了两种主要方法来实现这一点：使用单独的进程和结构化异常处理。
Google Chrome 为其每个标签使用进程方法，允许一个标签崩溃而不影响其他标签。这是一种非常强大的方法，但除非您的引擎架构考虑到这一点，否则可能会导致大量的进程间函数调用，这将对性能产生严重影响。我们想要一种易于融入现有项目的方法。
结构化异常处理（SEH）是 Win32 API 的一项功能，允许处理运行时错误，如访问冲突。它的行为非常类似于标准异常，但实际上是完全分开的；游戏控制台上不使用标准异常有各种原因，但这些原因不影响 SEH。当发生运行时错误（如空指针解引用）时，操作系统会检查应用程序注册的可能处理程序的堆栈，以确定如何继续。您在 Windows 中看到的崩溃对话框实际上是默认处理程序；当 Visual Studio 的调试器附加时，会添加另一个处理程序。
使用 SEH 很容易捕获错误并直接继续。在我们的情况下，关键是在对游戏对象的更新调用周围。当更新失败时，我们会禁用它，直到代码在运行时重新编译，然后我们再试一次。在此过程中，应用程序的其余部分 —— 渲染、GUI、日志记录 —— 都将继续运行。
但实际上，您不想默默地处理崩溃 —— 您真的想首先找出导致崩溃的原因！您可以添加代码来生成堆栈跟踪。然而，像 Visual Studio 中的调试器这样的工具在崩溃发生时已经提供了一个非常理想的界面，允许您轻松检查状态。所以实际上，我们希望崩溃，但然后继续。
事实上，这正是我们所做的；我们首先允许崩溃正常进行，以便我们可以使用 Visual Studio 进行调试，然后用户可以在 IDE 中点击 “继续” 按钮。通常，“继续” 选项是非常无用的，但在我们的情况下，我们会在第二次尝试时捕获崩溃并继续执行。我们两全其美。
为了提高生产力，我们包括了一个运行时断言宏，它与运行时异常处理过程兼容。
15.6.1 处理加载新代码时的错误
当加载新代码时（见原型中的 ObjectFactorySystem::AddConstructors 函数），我们需要构造新对象，将状态序列化为它们，并初始化它们（如果需要）。由于该过程依赖于正常的序列化，我们还测试从新构造的对象中序列化出来。在此过程中可能会发生结构化异常（崩溃），因此我们使用运行时异常过滤器来处理它们，并恢复为运行旧代码和状态。这为开发人员提供了一个机会来修复问题并重新加载新代码，而无需重新启动应用程序。
如果捕获到错误，则会删除新构造的对象。这会在析构函数中引入一个新的失败路径，因此它也使用运行时异常处理，并且在发生错误时简单地泄漏对象。
另一个常见的问题是，新代码在这个过程中污染数据，不会导致崩溃，但会使应用程序实例无法使用。一个简单的解决方案（尚未在我们的代码库中实现）是维护一个代码和数据的撤销列表，允许开发人员恢复到以前的工作状态并从那里进行进一步的更改。
通过在加载之前对新代码进行单元测试和 / 或在磁盘上创建保存点，可以增加进一步的稳定性。如果开发人员打算在编辑工具中使用运行时编译 C++ 方法，我们建议添加这些功能，但对于编程生产力工具，我们认为这些步骤会适得其反，因为会增加额外的周转延迟。
15.7 更复杂的代码 —— 状态保存和头文件处理
当用新代码替换旧代码时，希望确保旧对象的状态传播到新对象。运行时对象系统包括一个简单的序列化系统，专为运行时修改代码的需求而设计。
SERIALIZE 宏可用于任何实现了 operator = 方法的类型，这也允许将类型更改为兼容类型，如 float 到 double 或 int 等。非运行时指针可以通过其值进行序列化，因为地址不会改变，但运行时指针通过其 ObjectId 进行序列化。
清单 15.9. 一个示例序列化函数。

为了节省开发人员的时间，在加载和保存状态时都会调用相同的序列化函数。对于需要不同行为的情况，可以使用 IsLoading () 函数。
值是按名称进行序列化的，因此如果对象的名称发生更改，开发人员应该直接使用 Serialize 函数而不是宏，并在加载后用宏替换。
已经实现了一个简单的头文件依赖项跟踪方法。要使用此方法，请将 RUNTIME_MODIFIABLE_INCLUDE 添加到头文件中（在 RuntimeInclude.h 中定义），当此文件更改时，任何包含它且具有运行时可修改类的代码都将被重新编译。这个宏扩展为一个递归模板特化，当从.cpp 文件包含这些头文件时，使用_COUNTER_宏为每个文件名分配连续的数字。这使系统能够遍历给定类的所有包含文件。
15.8 性能关键代码的代码优化
我们使用虚函数在加载新代码时为函数调用提供运行时重定向。这会给函数调用带来一点性能损失。对于许多 AI 和脚本样式的用例，这仍然与运行脚本虚拟机或使用数据驱动方法的性能相当或更好。然而，一些简单的方法可以减少或消除这种损失。
对于仅使用虚函数进行代码运行时编译的开发人员，可以为最终发布版本编写一个宏，将适当的函数声明为非虚函数，只要不需要多态行为。这会在构建之间引入潜在的巨大差异，因此需要强大的测试制度。
清单 15.10. 通过在最终发布版本中从性能关键函数中删除 virtual 来进行优化。请注意，我们没有声明抽象接口，因此开发人员必须注意确保他们在非运行时代码中仅使用 virtual 或 RUNTIME_VIRTUAL 函数。

一个更简单的替代方法是围绕聚合调用构建代码的高性能区域，类似于数据导向编程中采用的方法。例如，如果我们考虑以下对游戏对象执行操作的函数：
清单 15.11. 简单虚函数示例的声明和定义。

如果我们在游戏中有许多 Execute 调用，虚函数调用开销可能会变得很大。因此，我们可以通过聚合所有调用来替换它，如下所示：
清单 15.12. 重新设计的函数，通过每次调用处理多个对象来减少虚函数调用开销并提高缓存一致性。

在这里，我们基于一个新的接口定义了这个函数，该接口要求开发人员传入一个游戏对象数组进行处理，因此将虚函数调用的成本降低到原始成本的 1/numObjects。此外，缓存一致性可能会带来潜在的好处，这可能会进一步提高性能。
15.9 用例：行为树和黑板架构
在运行时自由更改代码的能力不仅可以加速现有工作流程的迭代。它还可以让我们以完全不同的方式解决问题。我们以这种方式重新评估的一些首批技术是行为树和黑板。
作为现代游戏 AI 的堡垒，行为树提供了一个框架，用于将复杂的 AI 分解为具有结构化反应决策的模块化部分，并且已经被广泛描述，包括在本书中。黑板是一种在 AI 的各个方面共享数据的简单方法，同时保持松散耦合。通常，两者一起使用，行为树中的条件主要从黑板读取，而该数据定期从感官系统更新，并由行为本身的操作写入。
15.9.1 “软编码” 行为树
在这里，我们以 “第一代” 行为树为例 —— 本质上是一个以行为状态为叶子的决策树，这是现代游戏中非常常见的设计，包括《孤岛危机 2》。
实现包括使用 Lua 的代码片段在每个节点形成灵活的条件，或者在《孤岛危机 2》中使用一个简单的虚拟机来执行由 XML 指定的树 [Martins 11]。然而，本质上，结构是一个简单的 if-else 语句树 —— 行为树架构的其余部分源于对快速迭代的需求，因为一组硬编码的 C++ if-else 子句将使 AI 开发几乎停滞。
我们现在可以重新评估这个假设。在 RCC++ 下，这样的决策代码可以被认为是 “软” 编码的 —— 我们可以在游戏运行时随意更改它。因此，假设一些格式良好的代码，让我们考虑它的属性：作为原始 C++，它显然非常快，它将处理错误而不会崩溃，它可以轻松访问我们 AI 系统中的所有状态，它可以共享子树作为函数调用，它可以使用我们所有的 C++ 数学和 C++ 数学和实用程序例程，我们可以使用我们现有的调试器，如果需要，我们可以应用我们现有的分析器，您可以从源代码控制中看到有用的差异…… 列表还在继续。在几行代码中，您已经实现了一个行为树 —— 实际上，是一个异常快速和强大的行为树。
主要的改进方面是为设计师提供的接口。当然，简单的参数可以通过 XML 或 GUI 公开。根据作者的经验，更多的结构更改最好由 AI 程序员负责，他们通常发现简单的文本规范比图形规范更易于使用。然而，如果需要图形表示，这样的 if-else 代码可以很容易地从图形表示生成，只需替换源文件即可触发运行时编译。
15.9.2 黑板
在 Lua 或 Python 等语言中，黑板可以自然地表示为键值对的表，包括字符串和动态类型的值。虽然在 C++ 中可以进行类似的构造，但它们可能代表性能瓶颈。在类似于我们的行为树的方法中，我们可以将黑板在 RCC++ 下表示为简单的结构体 —— 每个键值对成为适当类型的命名成员变量。
从黑板读取和写入变得像将其指针传递给我们的感官系统和我们的 RCC++ 行为树一样简单。我们必须解决的主要困难是依赖关系，因为使用它的所有代码都必须包含结构体定义作为头文件，并且如果它发生更改，则必须重新编译。
RCC++ 的头文件跟踪功能使这变得简单，对包含文件的更改会触发所有依赖代码的重新编译。我们建议使用分层形式的黑板，例如，特定代理的完整黑板从所有代理共享的一个黑板继承，以及从其物种共享的一个黑板继承，并且对仅由当前行为使用的任何黑板进行单独访问。这种方法有助于确保当黑板定义更改时，只有相关的 AI 代码需要重新编译，从而使重新编译尽可能高效。
15.10 Crytek 案例研究
在 2011 年巴黎游戏 / AI 会议上的演讲之后，Crytek 在内部实现了一个类似的系统，他们称之为 SoftCode。该系统已用于 Crytek 目前活跃的几个游戏项目中，并用于渲染效果、UI 和动画等多种系统。目前，它在《崛起》中用于创作行为和管理行为选择的 AI 系统中使用最为频繁。
SoftCode 在 RCC++ 的方法基础上朝着几个有趣的方向发展。首先，它提供了运行时编译器的编译和更改跟踪功能作为 Visual Studio 2010 插件，适用于 32 位和 64 位 Windows 构建以及 Xbox 360。此外，它概括了运行时对象系统的概念，允许开发人员通过类型库公开自己的系统。因此，每个 SoftCoded 类型可以从自己的基接口派生，而不必从单个 IObject 基类派生。与 RCC++ 一样，SoftCoding 具有使用结构化异常的错误处理机制，但其 lambda 函数允许捕获调用状态，以便在失败后可以重试各个方法。为了简化开发，SoftCode 类型使用 SOFT () 宏来公开类成员变量，而不是通过显式的 Serialize 函数，并且全局变量可以通过 SC_API 宏公开。
15.11 未来工作
随着 Mac 甚至 Linux 成为游戏更受欢迎的目标，我们认为支持这些平台是该项目的自然下一步。除此之外，将运行时对象系统和运行时编译器转移到客户端 / 服务器模型将允许针对控制台和移动设备等更多目标。
一个有趣的进一步步骤是支持比 C++ 更简单的编程接口，使用中间编译器生成 C++ 代码，并使用 RCC++ 允许运行时使用。一个基本的图形界面来构建对象数据成员和函数声明，函数体可在 C++ 的变体中编辑，限制运算符算术和可以调用的函数，可能足以满足许多技术导向的设计师。或者，像虚幻的 Kismet 或 Crytek 的 Flow-Graph 这样的完整图形脚本方法可以输出 C++ 而不是数据，允许编译器在可能的情况下进行优化。一种允许现有构建块连接在一起，并在代码中即时构建新构建块的混合方法，似乎是在安全和高效的环境中允许设计师自由表达的良好解决方案。
同时，我们将继续发展当前的代码库，以寻求更快的迭代时间、更轻松的开发和最大性能的潜力。请查看作者的博客[RuntimeCompiledCPlusPlus.blogspot.com](https://runtimecompiledcplusplus.blogspot.com/)以获取更新。
15.12 结论
我们使用运行时编译 C++ 的最初目标是证明编译代码可以取代脚本，用于游戏逻辑和行为的迭代和交互式开发，特别是在 AI 等性能关键的代码区域。我们相信我们不仅成功实现了这一目标，而且还开发了一种技术（以及许可开源代码库），允许开发人员更进一步，以这种方式开发他们游戏代码的大部分。
现在，无需重新启动进程，就可以更改行为、修复错误、添加新功能，甚至进行优化，周转时间约为几秒钟。
特别感谢亚当・鲁特科夫斯基