# 三杠五、使用转向圆进行编队移动的技术
**斯蒂芬·比约尔**

## 21.1 引言
在开阔地形上移动编队相对容易。然而，考虑到编队只能以一定的速度转弯的限制，要生成一条路径，使编队在特定的方向上以特定的点结束变得更加困难。本章介绍了这个问题的解决方案，它是克里斯·朱尼（Chris Jurney）在GDC演讲中使用转向圆的想法的扩展[Jurney et al. 07]。该解决方案可以分为两部分：
1. 生成要遵循的路径。
2. 沿着路径导航编队。

值得注意的是，生成路径的第一部分不仅限于编队。它可以用于单个角色、车辆或任何其他可以定义转向圆的移动对象。第二部分特定于编队，并描述了沿着路径移动编队的两种不同技术。

## 21.2 生成路径
使用两个转向圆，一个基于编队的当前位置，一个基于目标位置，我们可以计算出编队需要采取的路径。

图21.1展示了最重要的信息，以及我们最终路径的示例。

当我们开始生成路径时，我们从五个信息开始：编队的当前位置（formation.pos）、当前方向（formation.dir）、目标位置（target.pos）、目标方向（target.dir）和转向圆的半径（或编队的转弯半径，r）。基于此数据，我们需要计算四个额外的值：
- c1，起始转向圆的中心点。
- c1_exit，编队将离开起始圆的点。
- c2，结束转向圆的中心点。
- c2_enter，编队将加入结束圆的点。

### 21.2.1 计算c1和c2
计算路径的第一步是生成将在起始和结束点使用的转向圆。为此，我们需要计算向量target.pos - formation.pos，我们将其称为dirVec。

接下来，我们将计算起始圆的中心点c1。为此，我们需要formation.dir在dirVec方向上的垂直向量。我们可以通过计算formation.dir的两个垂直向量与dirVec的点积来计算。我们将使用具有正结果的垂直向量，将其标记为formation.perp。将formation.perp缩放为长度等于r，然后将其添加到formation.pos以获得c1。结束圆的中心点c2的计算方式相同，使用 - dirVec（而不是dirVec）和target.dir的垂直向量。具有正点积的向量将被称为target.perp。

唯一的例外是当c1和c2之间的距离小于2r（即转向圆重叠）时。在这种情况下，解决方案是反转formation.perp和target.perp。这将导致编队转向相反的方向，从而为其提供足够的空间来转弯。例如，如果我们最初使用formation.dir的右手垂直向量，我们将使用左手垂直向量代替，实质上是将转向圆翻转到formation.dir的另一侧。

### 21.2.2 计算c1_exit和c2_enter
本节的目标是找到c1_exit和c2_enter，有两种不同的情况需要我们考虑。为了确定我们拥有哪种情况，我们首先需要查看formation.perp和target.perp是position.dir和target.dir的左手垂直向量还是右手垂直向量。为了简洁起见，如果formation.perp是formation.dir的左手垂直向量，我们将说formation.perp等于“Left”；否则它是“Right”。同样，如果target.perp是target.dir的左手垂直向量，我们将说target.perp等于“Left”；否则它是“Right”。

第一种情况是formation.perp和target.perp落在相反的两侧（例如，formation.perp等于Right且target.perp等于Left）。在这种情况下，我们的目标是计算c1_exit和c2_enter在两个圆的圆周上相对于x轴的角度（这些角度在图21.2中是a3和b3）。一旦我们有了这些角度，我们就可以计算这两个点。

第二种情况是formation.perp和target.perp在同一侧。这种情况不需要我们计算任何角度，而是依赖于观察到涉及的重要角度都是90度。

#### 21.2.2.1 如果Formation.Perp和Target.Perp在相反两侧的计算
在formation.perp与target.perp不在同一侧的情况下，我们的目标是计算角度a3和b3。我们将立即深入细节，但应该注意的是，a3和b3的计算将根据formation.perp和target.perp所在的侧面略有变化，这就是为什么图21.2中有两个图的原因。

在我们开始计算之前，我们将进行一些观察。首先，从c1到c1_exit的线和从c2到c2_enter的线都垂直于c1_exit和c2_enter之间的线。其次，线c1到c2和c1_exit到c2_enter在两条线的中点相交。第三，我们知道转向圆的半径r。第四，我们能够计算c1和c2之间的距离，标记为d。看图21.2，我们可以看到我们现在有两个直角三角形，并且我们知道三角形的两条边（一条边是r，另一条是1/2d）。这意味着我们可以计算角度a1：a1 = acos(r / (1 / 2 * d))。我们还可以通过找到向量c2 - c1相对于x轴的角度来计算a2。

对于a3，如果formation.perp是Right，那么我们可以参考图A，a3是通过将a1加到a2来计算的。否则，如果formation.perp是Left，我们参考图B，a3可以通过从a2中减去a1来计算。

c2_enter的计算与c1_exit的计算非常相似。角度b1使用与我们用于找到a1的完全相同的方程和值来计算。角度b2是向量c1 - c2相对于x轴的角度（与a2不同，a2是c2 - c1相对于x轴的角度）。b3的计算也与我们用于a3的计算相同，并且简单地是b2 - b1或b2 + b1，具体取决于formation.perp和target.perp的值。最后，现在我们已经计算了a3和b3，我们可以生成圆上的点c1_exit和c2_enter：
- c1_exit(x, y) = (c1.x + r * cos(a3), c1.y + r * sin(a3))
- c2_enter(x, y) = (c2.x + r * sin(b3), c2.y + r * sin(b3))

#### 21.2.2.2 如果Formation.Perp和Target.Perp在同一侧的计算
在formation.perp和target.perp都落在同一侧的情况下（意味着它们都是Right或Left），计算稍微简单一些。这里，我们首先计算向量c2 - c1，我们称之为d。如图21.3所示，如果formation.perp等于Right，那么我们将使用d的左手垂直向量，标记为d.perp。同样，如果formation.perp等于Left，那么d.perp将是d的右手垂直向量。在任何一种情况下，一旦我们有了d.perp，将其添加到c1和c2以获得c1_exit和c2_enter。

### 21.2.3 生成沿路径的点
最后，我们可以生成编队要导航的路径上的点。点将从formation.pos开始，围绕圆c1移动到c1_exit，继续移动到c2_enter，最后围绕圆c2直到我们到达target.pos。

围绕圆的行进方向由formation.perp和target.perp确定。当它们等于“Right”时，我们将在相应的圆上生成点，沿顺时针方向移动，当它们是“Left”时，我们将生成点沿逆时针方向移动。

## 21.3 导航编队
以合理的方式移动编队需要编队内的位置是流畅的。以下示例将保持编队的第一行静态，后面的行将以几种不同的方式跟随。这里，我们将查看两种样式：第一种样式涉及将编队内的每个单元朝着它前面的单元移动，第二种样式要求每个单元通过保持在其左右单元旁边来保留其行。

请注意，这里描述的编队内的点旨在成为寻路目标，不一定是编队内单元的实际位置。这种灵活性可以允许单元离开并做其他事情，例如处理攻击敌人、收集附近的资源或绕过较小的障碍物。一旦单元完成了它所拥有的任何子任务，它就可以恢复寻路到编队内的目标位置。

### 21.3.1 “列”编队
这种技术涉及将编队内的每个单元朝着它前面的单元移动，同时保持设定的距离。虽然这将导致相当流畅的外观，并保持列中每个单元之间的连接，但它不保留行。

第一步是根据编队的速度和路径中的下一个点更新编队的位置和方向。为了使第一行的单元保持在一条直线上，它们的位置被计算为使得它们形成的线垂直于编队的更新方向，并以编队的位置为中心。从第二行开始，计算每个目标与同一列中前面目标之间的方向。然后，我们将目标沿该方向移动，直到它接触到前面的单元，对编队中所有剩余行的单元重复此过程。

### 21.3.2 “带”编队
对于这种移动样式，编队在转弯时保留行。第一行的计算方式与“列”编队样式相同。

接下来，我们需要根据第一行移动的方向确定第二行是向左还是向右转弯。为此，首先计算第二行中的任何单元到第一行中同一列的单元的方向，然后取右手垂直向量，我们将其称为rPerpendicular。接下来，计算第一行移动的方向与rPerpendicular的点积。如果结果为正，则第二行将向右转弯，否则将向左转弯。

目前，假设第二行向左转弯。下一步将是将第二行中最左边的单元朝着同一列中前面的单元移动，直到它们接触。接下来，从行中的第二个单元开始，将每个单元的位置设置为接触其左侧的单元，沿rPerpendicular的方向移动。

如果行向右转弯，只有两个小的区别。主要的区别是我们将首先计算最右边单元的位置，将其朝着前面的单元移动，直到它们接触。另一个区别是您将从右边的第二个单元开始，并将每个单元的位置设置为接触其右侧的单元，沿 - 1 * rPerpendicular的方向移动。

在任何一种情况下，一旦我们有了第二行中所有单元的位置，我们就可以对编队中剩余的行重复此过程。

## 21.4 演示
本书网站（http://www.gameaipro.com）上提供的演示是为了作为本文中提出的想法的概念验证而创建的。它是用HTML5和Javascript编写的，旨在尽可能便携。生成路径的几乎所有逻辑都可以在“main.js”中找到，而绘制、更新和移动编队以及编队内单元的逻辑可以在“formation.js”中找到。

## 21.5 结论
本文表明，使用一些简单的线性代数将编队转向特定的位置和方向并不困难。通过根据编队的当前位置和目标位置计算两个转向圆，可以生成编队遵循的路径，确保编队永远不需要进行比其能力更尖锐的转弯。

对这个概念的进一步发展可以包括编队考虑障碍物的能力，无论是大规模还是小规模。对于较小的障碍物，意图是编队可以在很大程度上忽略它们。这是因为预计编队内的寻路目标将处理寻找绕过任何小物体的方法。大规模障碍物需要单独处理，但可能通过考虑整个编队的大小，然后为整个编队进行寻路来潜在地处理。
