# 三杠九、具有移动规划的动画驱动移动
**雅罗斯瓦夫·齐普宁斯基**

## 25.1 引言
在提高电子游戏沉浸感的竞赛中，游戏的各个方面都必须得到改进。动画驱动移动是增加角色移动真实感的一种方式。这不仅仅意味着拥有大量的动画，因为随机播放它们看起来会不真实。这个问题的解决方案是规划动作，以便每个动画都与未来的移动完美协调。简而言之：在动画驱动移动中，角色的移动直接来自动画。

然而，由于游戏的动态性质，仅仅播放动画是不够的。需要进行一些调整，以使角色朝着期望的方向移动到期望的位置。因此，计划的执行对于使动画驱动移动工作并使用它来满足其美学要求非常重要。

本文如下处理此任务：使用高级路径来指导动画驱动路径的增量生成。动画驱动路径由动作组成，动作分为三类。转移动作用于大致沿直线覆盖较长距离。预转移和后转移动作可选地用于进入和退出转移动作。这里描述的整个系统是在游戏《子弹风暴》中发布的系统的修订版本。

## 25.2 动画和移动架构
在许多情况下，移动不作为单独的子系统存在。角色移动的责任通常在AI、游戏玩法、物理和动画系统之间分配。为了更好地控制“正在发生什么以及为什么”在移动中，最好将与移动相关的尽可能多的责任（创建导航路径、处理实际移动、排队、检查目标是否达到等）移动到一起，提供一个干净且易于使用的接口。如果不将移动代码放在AI /游戏玩法/脚本和动画之间的单独层中，最好的地方是在动画子系统本身中。

动画驱动移动使用来自动画的数据来移动角色。这意味着移动符合动画数据和动画中包含的速度数据。移动子系统可以进行进一步的更改来调整速度以满足移动请求。为了使动画更易于使用，它们应该遵循一些基本规则。例如，根骨骼（如果动画代码中的根运动直接转换为角色的速度）应该尽可能接近直线或曲线移动。

虽然这不是硬性要求，在某些情况下甚至可能不希望这样（例如，对于醉酒的角色），但它将使移动规划更可预测（角色将不太可能离开规划的路径），并且移动执行将更容易。

如果只使用简单的循环动画，那么就不需要任何规划，并且移动可以完全是反应性的。这意味着播放的动画被选择来匹配已经规划的移动。然后，角色的AI选择自己的速度和动画，试图使一切看起来合适。这种方法易于实现，但在许多情况下看起来不自然，特别是在移动开始或停止时。

为了使移动看起来更自然，使用过渡动画。这些是用于开始、停止、改变方向和其他非循环动作的动画。请注意，这些动画需要时间并且需要空间来正确播放。因此，一个仅响应当前请求的系统将起作用，但仅在一些简单和直接的情况下。例如，这样的系统在角色向前跑10米并在目的地点前2米开始停止的情况下没有问题。但是，如果路径更复杂，角色可能很容易错过被要求停止的点。通常有几种停止动画的变体，但每帧检查所有可能性太昂贵。由于AI知道采取什么路径到达最终目的地，预先规划动画是自然的解决方案。

## 25.3 准备
在开始进行动画驱动移动的工作时，强烈建议您尽可能多地与动画师和AI程序员交谈，以决定您想要实现的目标。例如，动画师可能希望有非常长、美观的动画来覆盖各种情况，以实现良好的美学效果。然而，这些可能难以处理，因为长动画将导致系统响应性降低，并且需要更多的物理空间来执行。这可能意味着系统需要提前规划不仅仅是几步。

您还应该决定您想要拥有的移动类型。例如，跑步和步行可能只在前进方向上进行，而其他方向将通过短步或顺序（转弯和前进）来覆盖。此外，在开始制作动画和规划系统之前，决定是否可以穿越障碍物以及如何穿越是很重要的。如果可以，考虑会有什么样的障碍物，角色应该如何接近它们，它们应该如何存储在导航网格中，以及如何处理它们。动画师、AI程序员和/或设计师可能希望有其他功能和规则存在。一个例子可能是制定规则，在向任何方向迈步时进行射击有特定的动画，而不是允许射击覆盖在步行或跑步动画上。

## 25.4 移动规划
最好将移动规划分为单独的模块，每个模块都有明确的目的：
1. 导航路径处理器
2. 创建动作堆栈的规划器
3. 执行动作堆栈的动画系统

强烈建议添加一个额外的模块，作为与其他游戏子系统的接口。这个模块将接受新的请求，为动画模块准备命令（它们现在应该做什么），并作为交换数据的中心枢纽。这样的模块确实有助于发现移动中的问题；它更容易发现无效请求，并确定是动画/移动子系统问题还是其他模块失败。

### 25.4.1 导航路径处理器
移动请求的处理始于创建导航路径。将导航路径存储为多边形和点是值得的。由于移动过程中可能发生的意外事件（例如，其他物体挡住了道路），导航路径可能需要调整或完全重新创建整个路径。存储多边形数据将减少访问导航网格的需求。当调整基于点的路径时，它也提供了更多的自由，基于点的路径是规划器的基本表示（图25.1）。

基于点的路径的创建应该从简单的方法开始，例如弦拉或漏斗算法，这将给出连接起点和终点的最短路径。有关寻路、弦拉和漏斗算法的更多信息，请参考以下资源[Demyen et al. 06, Cui et al. 11]。

路径处理器的第一项工作是处理彼此靠近的点，因为它们不提供任何额外信息，并且可能只会使移动规划中的后续步骤复杂化。更容易假设路径的每个段都是最小长度，任意选择，或基于最短的停止动画。这意味着三个后续段（从角色的当前位置开始）将覆盖，例如，至少2或3米。

在某些情况下，当处理较长的移动动画（需要更多空间）时，最好对点的位置进行进一步调整。例如，在弦拉路径后，可能有两个后续点在相反方向上将移动方向改变90°并且非常靠近。如果它们太近，将无法连续播放两个“跑步时急转弯动画”并（大致）保持在路径上。如果这些点周围有足够的空间，它们可能会被移得更远，以提供足够的空间来播放两个动画。如果不可能将点移得更远，仍然应该提供故障安全解决方案：在第一个转弯点停止，朝下一步，然后从那里开始跑步。为了避免影响移动的流畅性，应很少使用此类故障安全解决方案。

在某些情况下，沿着路径添加额外的点可能会有用，这将使接近某些位置更容易。例如，而不是跑到应该跳过的障碍物旁边，然后跳起来，可以使用一个额外的点从更好的角度冲向障碍物。由于内存限制，可能只有两个动画用于“站立跳跃”和“跑步时直跳”，并且当从宽角度冲向障碍物时，两者看起来都很糟糕；因此，从更好的角度接近对于使其看起来良好至关重要。

### 25.4.2 动作堆栈
动作堆栈是遵循当前路径段所需的动作列表。从末端开始选择动作（从期望的目标状态开始）更可行。这意味着首先选择的动作是最后执行的（图25.2）。

当路径被处理后，它应该以点的形式出现，并带有一些额外的数据，描述在每个给定时间的行为（蹲下、不跑步、跳过）。只有两三个路径段应该被考虑用于创建动作堆栈，原因如下：
1. 动作堆栈的创建计算量很大，如果为整个路径完成，将导致显著的性能峰值。
2. 我们不知道未来会发生什么，所以真的没有必要提前计划一切。角色可能会遇到另一个角色，或者可能被命令做其他事情。

理想情况下，动作堆栈只需要覆盖路径的一个段。当堆栈中的所有动作都执行完毕时，角色应该处于继续下一段的最佳点，此时可以创建一个新的动作堆栈。然而，在创建第一个动作堆栈时，仍然应该考虑两个或三个后续段，以便最好地进入后续段。考虑后续段还有另一个原因：在某些情况下，可能可以使用一个动画来覆盖多个段。一个例子可能是进入拐角后面的掩护。

即使规划动作仅针对一个段执行，了解角色之后会做什么也是有价值的。角色会跑步还是滑行？它需要在那里停止还是应该全速前进？这告诉它角色在当前段结束时应该处于什么状态（位置、方向、步态或姿势）。当然，还有角色的当前状态。其他信息可能描述当前段，例如距离，以及允许或禁止哪些动画（例如，角色不能在这里跑步）。给定这些数据，我们有两个选项来覆盖该段：
1. 执行一个动作，将角色直接从当前状态转换到期望状态。
2. 执行几个动作：
    - 预转移动作，将角色准备好进行转移动作（例如，开始向特定方向跑步）。
    - 转移动作，将角色移动更长的距离（例如，步行、跑步）。
    - 后转移动作，将角色带入期望状态（例如，在一个点停止，在跑步时进行急转弯）。

### 25.4.2.1 直接过渡
直接过渡给出了最好看的结果，但需要大量的动画来覆盖许多可能性。在实际游戏中，这些应该只用于覆盖特殊情况。例如，步行极短的距离可以通过一个动画来完成，该动画迈出一步或两步。对于这样的短距离，没有必要，并且开始跑步然后立即停止可能看起来很奇怪。

### 25.4.2.2 转移动作
对于更长的距离，使用转移动作更可行。它要求动画分为三个基本组（如前所述：预转移、转移和后转移），这些可以在不同的组合中大量重用，从而导致角色动画流畅。

每个动作（预转移、转移和后转移）都是可选的。由于角色可能已经处于“转移”状态，因此在段结束时可能不需要做任何事情。此外，转移本身可能会被省略，因为在某些情况下，实际播放预转移和后转移动画可能是可行的。

在游戏中，不可能为所有可能的情况都有预转移或后转移动画。这可能是由于内存限制、预算限制或开发时间限制。因此，我们可能会删除或不创建罕见情况的动画。当处理没有适当动画的情况时，规划器将不得不以不同的方式解决问题。

这样的一个例子是当角色蹲下时开始跑步。假设没有这种情况的动画，让我们看看规划器会怎么做。规划器首先尝试找到一个动画，将角色从蹲伏姿势（当前状态）带到跑步20米远的地方（期望状态）。当然，没有这样的动画。然后规划器尝试找到后转移、转移和预转移动作，但它找不到将角色从蹲伏状态带到跑步状态的动作。假设只有“角色从站立开始跑步”的动画在八个方向上，并且有动画将角色从蹲伏状态带到站立状态。然后规划器应该尝试使用蹲伏到站立的动画，执行一个动作堆栈，并再次尝试解决问题。在播放角色蹲伏到站立的动画后，可以使用八个“站立到跑步”动画中的一个。

在某些情况下，可能可以使用动作或动画将角色从当前状态带到期望状态，但只需要一个额外的动作。例如，可能有一个动画是在向右走的同时射击，但在开始时角色背对着目标，因此在播放行走射击动画之前，角色应该转向敌人。

当转移动作将角色带到期望位置，但尚未处于期望状态（例如，角色没有转向正确的方向或不在期望的姿势）时，可能需要类似的额外动作。

### 25.4.2.3 实现建议
对于实现，我们强烈建议将数据分为三组：
1. 转移信息（步行、跑步、蹲着步行、跳过、滑过），包括：
    - 转移动画列表。
    - 后转移动画列表，带有关于最终角色状态的信息（例如，旋转、姿势、它占用多少空间或任何其他所需的信息）。请注意，一些后转移动画条目可能会存储这不是达到期望状态的最终动画，规划器需要做更多的事情。
2. 姿势信息（站立、蹲伏、隐身），包括：
    - 姿势空闲动画列表。
    - 预转移动画列表，带有关于它们将角色带入的状态的信息（转移状态、角色将移动的方向、需要多少空间等）。
    - 直接从一种姿势转换到另一种姿势的动画列表。
3. 直接过渡：将角色从任何状态带到任何其他状态的动画列表，尽管在大多数情况下，只为姿势拥有这样的列表就足够了。

预转移、后转移和直接过渡动画也可以在单独的地方描述，其中包含与规划器所做决策无关的细节，但具有在执行期间对转移有用的一般信息。

其中一些信息可以通过算法收集。例如，每个动画如何连接到转移动画（启动转移动画、匹配姿势或调整运动，以便后转移动画在正确的时刻触发）。

其他信息（主要是规划器所需的信息）可以自动收集，尽管输入数据或至少手动调整它通常很有用。一个例子是动画所需的空间。一些“开始跑步”动画可能需要2米的空间。一些将角色从一个点带到另一个点的动画可能只覆盖1到3米。虽然这可以自动计算，但手动输入数据可以使每个系统在给定情况下的行为更加连贯和可控。

请注意，拥有故障安全解决方案非常重要，即使这意味着转向最终目的地并逐步走到那里，也可以防止角色陷入一种姿势。

### 25.4.3 执行动作
在规划期间，动作分为几种不同类型，包括预转移、转移、后转移、整段动画和额外动作。相反，动作的执行可以分为仅两组：转移和非转移动作。以下部分描述每个组的执行。

### 25.4.3.1 非转移动作
非转移动作只是播放分配的动画，如果需要，对速度和旋转进行小的调整。

当改变姿势（站立或蹲伏）时，只需播放动画而无需任何调整。对于预转移动作，需要进行方向调整，以便在预转移动画结束时角色朝着正确的方向移动。大多数后转移动作要求角色在精确的位置面向正确的方向，因此也需要进行调整。对于将角色从一个地方带到另一个地方的动作，需要对位置和方向进行调整。

参数调整应由规划器确定，这意味着所有此类动作的执行没有差异。

### 25.4.3.2 转移动作
转移动作是将角色从空间中的一个点带到另一个点的循环动画（尽管可以有随机或按顺序的动画相继播放）。除了匹配正确的方向并在所需位置结束外，角色可能需要以特定的姿势结束，以便与后转移动作无缝融合。例如，一个从右脚开始的停止动画要求角色在停止动画开始时处于同一只脚上。

这可能需要改变角色的速度，例如稍微加速或减速。这对于较长的距离效果很好，但在短距离上调整姿势可能会导致速度调整过大或导致角色在离目标位置太远的地方切换到后转移动画。在这种情况下，要么必须忽略姿势，要么应该有在后姿势上不同的后转移动画（左脚或右脚）。尽管变体可以在规划期间决定，但也可以在执行期间拾取。如果角色由于其他原因不得不稍微调整其路径，这可能会很方便。

加速或减速角色速度的替代方法是修改动画的播放速率。重要的是要记住在切换动画时保持播放速率，并逐渐调整播放速率。如果不保持播放速率，动画可能会看起来立即加速和减速，导致角色行为看起来很奇怪。

处理转移动作的代码应该尝试处理任何障碍物，保持角色的队形，或执行任何所需的路径调整。有了导航走廊和转移动作终点的信息，就有可能对角色的移动进行一些调整，并且仍然在后续动作要求的点结束。例如，如果一个角色在跑步时注意到前面有一个新的障碍物，它可能会足够早地改变移动方向以避免撞到障碍物，而不会冒着角色无法在下一步应该开始的点结束的风险。

也有一些情况，角色最终会离开已知的导航走廊，或者在某些执行点，很明显它会错过下一个动作的起点或根本无法到达那里。在这种情况下，要么应该重建动作堆栈，要么应该重新考虑整个导航路径。

撞到障碍物应该以类似的方式处理。可能无法避免撞到障碍物，或者可能决定角色甚至不尝试避免撞到一个。后一种解决方案在实践中效果足够好。当角色撞到障碍物时，它可以播放一个回避动画，完成后，请求一个新的导航路径（尽管在某些情况下重建动作堆栈可能就足够了）。

### 25.4.4 逆运动学（IK）控制器
由于系统对移动进行了大量调整，应该使用脚部的IK控制器来覆盖校正，通过移除、隐藏或至少减少脚滑效果。对于人类肢体，一个简单的两骨IK求解器就足够了[Juckett 08]。一个合适的动画将没有脚滑，这意味着当脚放在地上时，直到它被抬起才会移动。

在执行动作堆栈时，移动动画的速度会增加或减少，而不会加速或减慢动画的播放速率（因为加速或减速的原因是在给定点匹配姿势），这不幸地导致脚滑。例如，如果速度增加，脚将向前滑动；如果有其他旋转或其他调整，脚也可能向侧面滑动。在这些情况下，IK控制器试图将脚保持在原来放置的位置。

其他IK控制器可用于根据脚调整躯干位置，以帮助处理脚保持在角色后面或前面的情况。如果角色停止并且防滑控制器将脚保持在与最初预期不同的位置，可能会发生这种情况。

## 25.5 关于移动规划的其他信息
以下是关于移动规划的其他信息。

### 25.5.1 性能
在执行阶段，移动不需要大量的CPU资源。一切都已经规划好了，只是要保持角色的移动忠实于计划。相比之下，反应式移动需要在每一帧检查并可能更新所有可能的动作然而，需要注意的是，移动规划可能会导致显著的 CPU 峰值。如果有需要，大多数峰值可以通过延迟以下任何过程来消除，尝试首先延迟优先级最低的动作：
最低优先级：处理新的导航路径
中优先级：为站立角色创建动作堆栈
最高优先级：为移动角色创建动作堆栈
在最坏的情况下，一些角色可能会停止。请记住，当一个角色停止（播放停止动画）时，CPU 情况可能会好得多。在游戏中，由此产生的行为可能看起来像一个错误，因为角色已经停止并再次开始运行，但请记住，总是有可能播放一个新的动画。特别是，一个环顾四周、挠头或绊倒的动画都将抵消用户对不良 AI 行为的感知。
25.5.2 AI 的移动请求
依赖于动画驱动移动的 AI 应该有耐心；也就是说，它不应该在太短的时间内发送太多请求。如果 AI 经常改变主意，角色可能会陷入反复播放 “开始” 和 “停止” 动画的困境。这可以通过提供广泛反馈的移动系统来部分防止，因此 AI 不必 “担心” 角色尚未移动或正在做其他事情。并非每个 AI 请求都可以立即处理，因为预转移和后转移动作通常是不可中断的，应该等到它们完成。
移动系统应该小心，不要将每个 AI 请求视为完全新的和无关的，因为这会导致创建全新的路径。新路径通常意味着角色将停止并再次开始向同一方向移动。在许多情况下，AI 只需要更改请求路径的末端，因此当前执行的动作堆栈（以及部分导航路径已经处理）仍然足以满足本地移动。
25.6 商业实现
本文中描述的规划是为《子弹风暴》（由 People Can Fly 开发，Epic 的一部分，由 Electronic Arts 于 2011 年发布）实现的规划的修订版本。实际实现依赖于有限状态机 - 前面部分中提到的转移和姿势描述的广义版本。这意味着整个系统是数据驱动的，尽管一些情况需要单独的方法，这由特殊代码处理。例如，在物体上攀爬和下滑是在生产后期添加的。
此实现的代码是动画树的一部分（分布在几个动画节点上），使用单独的结构（称为 AnimationProxy）与其他游戏系统进行通信。源代码可供 UE3 许可证持有者使用。
25.7 结论
具有规划的动画驱动移动为游戏带来了可信的外观和感觉。角色以更自然和流畅的方式移动。规划的基本实现非常简单，并且由于它是数据驱动的，添加更多动画很简单。相同的代码可用于具有不同行为的角色，尽管系统的微调可能需要经验和时间。