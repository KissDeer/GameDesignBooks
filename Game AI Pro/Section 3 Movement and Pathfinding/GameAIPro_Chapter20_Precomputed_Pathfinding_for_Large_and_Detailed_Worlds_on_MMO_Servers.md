# 三杠四、面向大型和精细MMO服务器世界的预计算寻路
**法比安·格拉沃**、**横山孝则**和**三宅洋一郎**

## 20.1 引言
在旧一代主机上，预计算的寻路解决方案很常见，但在当前硬件上却很少使用。这些解决方案在计算成本方面能取得最佳效果，因为所有路径请求结果都在查找表中预先计算。然而，它们有两个缺点：内存成本和灵活性损失。目前，大多数游戏使用A*等动态算法进行导航。
然而，在MMO游戏的背景下，预计算解决方案仍然被使用。虽然相应的服务器通常配备充足的内存，但每个请求可用的CPU周期非常少。本文将展示如何为《最终幻想XIV：重生之境》实现预计算寻路。
这款游戏拥有非常大且精细的地图（每个约4平方千米），有悬崖，智能体可以从那里掉落（单向路径）。我们将展示一个具有导航网格自动生成和基于组件的分层查找表的精确导航系统。我们将组件定义为一组相连的多边形（在最低层）或相连的子层组件（在其他层）。我们将首先概述整个导航系统，然后简要解释导航网格的自动生成，最后重点介绍预计算数据的生成。

## 20.2 系统概述
本文介绍的导航系统是为《最终幻想XIV：重生之境》开发的，这是一款由SQUARE ENIX开发的“大型多人在线游戏”。该系统的选择主要由游戏的需求驱动，但这里介绍的技术也可以在其他环境中使用。
游戏在服务器上执行所有的导航路径计算。一个服务器可以模拟多个地图。一个地图可以大到4平方千米，有数千个NPC和玩家。图20.1展示了游戏中要探索的世界的一部分截图。由于寻路系统必须非常快，意味着A*不是一个选项，因此选择了预计算的路径查找表。
另一个重要要求是使寻路系统尽可能自动化。它必须能够为数百张地图生成准确的导航，无需专家或手动输入，但如果必要，必须能够直接编辑数据。作为游戏规则，任何NPC都可以去玩家可以去的地方（除非由关卡设计师指定）。导航系统必须尽可能接近玩家使用的碰撞系统。由于玩家可以跳跃或掉落（几乎可以从任何地方），导航系统必须支持这些功能。这也意味着，如果玩家可以使用狭窄通道，大型NPC也可以通过。NPC的大小不用于寻找路径，但仍用于在运行时平滑路径。为了满足世界导航表示的角色，选择了导航网格。
预计算的导航数据是从导航网格生成的，这种生成是本文的核心概念。预计算的数据存储在分层查找表中。选择这种方法是为了减少内存占用，同时保持非常快的计算时间。这些表在服务器上用于执行所有导航系统任务。
图20.2展示了从碰撞数据到服务器导航系统使用的表数据的工具流程图。
## 20.3 工具链
生成导航表数据的主要工具是关卡编辑器和表构建器（图20.2）。关卡编辑器收集所有碰撞数据以生成导航网格。导航网格的自动生成是由Mikko Mononen开发的开源软件库Recast完成的[Mononen 12]，在MIT许可证下发布。在体素化阶段后生成网格，以识别可行走区域[Miles 06, Axelrod 08]。对Recast的主要修改是在生成过程中添加了游戏特定的“掉落网格”。
关卡编辑器还允许通过各种工具编辑导航网格。例如，可以删除盒子内的网格生成或标记一个区域仅玩家可访问。门也可以分割并标记下面的网格，从而在关闭时禁止移动。最重要的功能是导航网格种子点。它允许设计师删除与该点不相连的所有多边形。只有当掉落多边形允许两个有效可行走多边形之间的连接时，才会保留它们。
导航网格本身只是一个可以由其他适当工具编辑或操作的3D多边形网格模型。例如，它可以被2D地图自动生成工具使用（第20.9.4节）。
图20.3展示了在Maya中查看的此系统生成的导航网格的截图。可以手动编辑它，但这样做会使进一步的自动生成无效。如果使用此选项，则必须在项目的最后阶段完成。
导航网格的主要目的是通过表构建器用于计算表数据。这些数据用于服务器导航系统，由QA和其他自动测试进行检查（图20.2）。也可以使用表检查器工具直接分析表数据。所有这些质量检查都暴露了输入数据（碰撞数据）或算法中的问题。质量检查是我们创建尽可能强大的系统以自动生成导航数据的主要关注点之一。
## 20.4 网格生成
在项目早期，为导航系统选择了导航网格。它们描述了一个可用于转向的自由移动空间。
由于世界非常大，导航网格的生成将其分割为规则网格。每个瓦片独立生成导航网格。我们选择在预计算数据中保留此网格信息，使用32x32米的小瓦片。
图20.4展示了导航网格的更详细视图。在其边界处，网格被玩家半径缩小，以便NPC，或更确切地说它们的中心，可以在整个网格表面上自由移动。生成过程必须尽量减少多边形的数量，并尽可能匹配碰撞数据。
如前所述，我们在网格生成算法中添加了掉落网格。这些的生成超出了本文的范围，但一些细节很有用，因为它强烈影响了表构建器算法。玩家可以从任何地方从任何高度掉落而不受伤害。NPC必须能够跟随玩家并避免长时间的绕行。设计师可以添加一个隐形墙来防止玩家掉落。
此外，我们添加了对NPC击退的支持，使玩家能够将NPC击下悬崖。图20.5a，b展示了掉落网格如何用于支持击退功能，覆盖所有可能的掉落方向。图20.6展示了从游戏地图生成的掉落网格。
可以使用网格连接性来确定击退长度（图20.5b中的虚线）。如果击退路径在掉落网格中间停止，则会附加一个掉落动作。
使用掉落网格代替碰撞检查来实现击退的优点是计算速度快，并且保证NPC最终始终处于导航网格上的有效寻路位置。主要缺点是自动生成过程的复杂性。
## 20.5 表生成概述
预计算的导航数据是从导航网格生成的。为此，构建查找表。图20.7a展示了这样的查找表。例如，它表明从C到E的遍历意味着使用C多边形的Edge 1。查找表给出了从一个多边形移动到另一个多边形时使用的正确输出边缘。然而，随着生成的多边形数量（N），表大小将很快变得令人望而却步（N×N）。为了避免内存爆炸，使用了分层方法[Dickheiser 03, Sterren 03]。通过分层方法，我们可以将N个多边形分成K组，并拥有K个大小为（N/K）×（N/K）的表和一个大小为P×P的门户表，其中P是连接多边形组的门户数量。
代替使用门户来划分区域，使用了连接组件方法。这种方法源自于《龙腾世纪：起源》（Bioware，2009）的工作[Sturtevant et al. 10]。组件被定义为一组完全连接的多边形。这个组件将是上层分层级别表的节点。由于我们使用分层方法，当描述可以推广到上层分层时，我们将使用“节点”一词代替多边形。
### 20.5.1 组件方法
图20.7b展示了如何在一个瓦片中将5个节点聚集到两个组件中。由于节点C、D和E之间存在连接性，可以将它们聚集为一个组件。星星表示用作组件中心的节点。组件中心代表上层节点。在我们的实现中，它们在描述组件连接性时取代了门户。一般来说，组件中心是到该组件内其他节点距离最小的节点。
由于世界的大小，导航网格的自动生成将其分割为规则网格，并为每个瓦片生成网格。查找表的最低层基于这些瓦片（图20.7c）。我们定义以下元素：
- **节点**：一个多边形或一个子层组件。
- **组件**：一组连接的节点。组件中的任何两个节点之间始终存在路径。
- **瓦片**：网格分区层中的一个单元格。它可以有任意数量的组件或节点。
### 20.5.2 表连接性
每个瓦片都有一个查找表，描述其所有节点之间的连接性。为了避免在其边界处出现不连续性，每个瓦片还有一个查找表，描述其节点与所有相邻瓦片节点之间的连接性（图20.8b，左表）。这确保了在从一个瓦片移动到另一个瓦片时，始终有一个详细的表显示选择哪个边缘。
每个瓦片还有一个查找表，描述其每个节点与两个瓦片外的组件中心之间的连接性（图20.8b，右表）。正如我们将在下一小节中看到的，拥有这个最后一个表可以提高上层给出的寻路启发式的质量。图20.8a展示了25个瓦片与导航网格。中心瓦片（垂直线图案）有一个查找表，描述其两个节点与彼此、与其八个相邻瓦片的所有15个节点（水平线图案）以及与其12个相邻瓦片的组件中心（14个带灰色星星的节点）的连接性。总之，中心瓦片有一个从其两个节点到31个（2 + 15 + 14）节点的查找表。
### 20.5.3 掉落网格在表外
当掉落时，玩家失去控制。同样，通过掉落网格移动会改变NPC的运动。我们决定，为了模拟智能体掉落，掉落网格的多边形每个只有一个输出边缘。表构建器使用此属性来优化查找表大小。它首先重新排序掉落多边形边缘，以便输出边缘是第一个。因此，对于查找表中的任何目标，任何掉落多边形的输出边缘将是Edge 0（即，掉落多边形的查找表列是一个空列）。此外，我们决定，掉落网格上的任何目标都将更改为其最终掉落点。这允许预测运动并消除在查找表中将掉落多边形作为目标的需要（即，查找表行）。这意味着掉落网格不需要存储在查找表中。这种方法将查找表的大小减少了高达20％。
### 20.5.4 寻路请求
图20.9展示了使用预计算数据的寻路过程的示例。路径子目标实际上是组件中心。选择使用哪个组件中心由上层决定。在这个简单的例子中，只有一个上层，有一个查找表用于查找要使用的下一个节点链接。如果在最低级别找不到解决方案，则在上级级别中搜索（b）。图20.9c，d展示了如何选择子目标。它是上层路径上仍在本地查找表（带图案的瓦片）内的最远组件中心。当前瓦片的查找表包含要使用的下一个边缘。图20.9e，f展示了一旦目标在相邻瓦片内，就使用直接的节点 - 节点表。这个例子展示了完整的寻路过程，但如果目标足够远，则不需要为每个分层级别计算完整的路径。这允许非常快速的路径计算。
### 20.5.5 层次结构
为了进一步减少内存使用，我们在最大的地图上不仅使用两个，而且使用三个层次结构。例如，对于我们测试的一张地图，表大小为16.5兆字节（2层），8.8兆字节（3层），8.7兆字节（4层），如果没有任何层次结构，则超过400兆字节。
我们使用与前面描述的相同的过程来创建上层。图20.10展示了添加到图20.8示例的第二层。在图20.10中，第二层的瓦片大小为2×2子层瓦片。对于上层瓦片，节点（图20.10a中的点或星星）是下层的组件中心（图20.8a中的星星）。对于每个瓦片，可以计算其组件中心（图20.10a中的星星），它们成为最高层图的节点（图20.10c）。
在我们的测试中，最低层（网格）的组件的平均和最大数量分别为1.5和15，中间层分别为3.2和19。这种方法提供了良好的压缩，最小化了表的大小。
## 20.6 表生成算法
上一节解释了用于导航的分层表数据背后的主要思想。在本节中，我们将更详细地解释计算此数据的算法，并讨论为获得可靠数据需要避免的一些陷阱。
清单20.1展示了表构建器算法的伪代码。它迭代层次结构的级别，并对最低级别（网格数据）应用特定功能。为了避免生成的表中出现一些不一致性，采取了一些额外的措施。我们将在本节和以下部分详细介绍所有这些步骤。
### 20.6.1 计算连接性
ComputeConnectivity()函数可能是最简单的一个。由于导航网格生成算法生成一个3D网格文件，因此有必要计算其多边形之间的连接性。我们的代码基于“为任意网格构建边列表”算法[Lengyel 05]。唯一的修改是添加了对掉落多边形的支持。由于这些多边形可能重叠，根据掉落多边形的材料（即，掉落输出、瓦片之间的掉落门户、边缘的掉落路径等）添加了额外的规则。
### 20.6.2 掉落网格设置
为了简化掉落网格的手动编辑，对它们施加的唯一要求是在掉落的末端放置一个特殊的输出标记（一个表示输出边缘的特殊三角形）。由于一个输出边缘可能连接到几个可行走多边形，表必须分割掉落边缘以匹配底层多边形边界。FallingMeshSetup()还负责计算掉落路径并设置掉落输出边缘。
### 20.6.3 多边形之间的距离
为了构建查找表，我们尝试最小化多边形中心之间的距离。我们尝试了两种计算此距离的方法：附加距离和平滑距离。
附加距离是中间距离的总和。从多边形A通过多边形D到多边形E，我们有距离AE等于距离AD和DE的总和（图20.11c）。
平滑距离使用中心之间的平滑路径作为距离。在这种情况下，从多边形A通过多边形C到多边形E的距离小于或等于距离AC和CE的总和（图20.11d）。请注意，我们将在第20.9节中讨论这两种距离的优缺点。
### 20.6.4 表构建器
为了减少计算时间和内存使用，我们决定仅为最高层（只有一个瓦片）构建完整的地图查找表数据。对于较低层，查找表仅考虑21个相邻瓦片。在图20.8a中，这些相邻瓦片用线或网格图案显示。由于我们尚未确定组件中心，因此计算节点 - 节点表而不是节点 - 组件表。
算法独立地为每个瓦片构建查找表（实际上，这个过程是多线程的）。请注意，最短路径结果可能会随着邻域而改变；不可能在瓦片之间重用它。例如，在图20.8a中，从π到θ的路径在中心单元格邻域内绕了很长的路。在右下角瓦片邻域中，从π到θ的路径是最短的。
为了避免到一个固定目标的冲突路径，我们计算从一个目标到所有其他节点的表数据（反向搜索）。当当前瓦片中的所有节点都更新时，搜索停止（图20.11e）。
图20.11展示了在网格级别（函数BuildMeshTable()）的Dijkstra算法的表构建过程。如图20.11c，d所示，平滑路径距离可以比附加距离给出更好的结果。然而，这种方法不一定产生最短路径（例如在图20.11h中）。由于已经决定从B到E通过D进行（图20.11g），从A到E的路径必须通过D。请注意，使用平滑距离时，路径不是对称的（图20.11d，h）。
### 20.6.5 分层表构建器
函数BuildHierarchicalTable()负责上层层次结构。它与前面解释的函数BuildMeshTable()类似。对于此算法，我们也尝试了平滑距离和附加距离。平滑距离使用在下层计算的非相邻节点之间的距离（图20.12a）。这仅在下层不使用附加距离时才有效。平滑距离显着提高了长路径的质量。
请注意，使用平滑距离时，路径不需要通过组件中心，如图20.12a所示。从B到J的最短路径是B，A，F，G，I，J。最短的上层路径，α，γ，δ，穿过组件γ：{F，G，H，I}，但不通过其中心，节点H。
函数BuildHierarchicalTable()包括一个我们称为“子节点路径”约束的附加约束。其目的是确保解决第20.7.2节中介绍的表不一致性的算法的有效性。
当子节点中心和另一个子节点对于相同目标具有不同的下一个组件时，应用此约束。图20.12b展示了这样的情况。想象起点是B，下一个子目标是H。对于上层节点，有一个直接链接β - φ，即子节点路径从D到H只有一个组件变化。然而，对于B，到H的最短子节点路径是B，A，F，G，H，它通过α（A）。由于路径β，φ可以意味着通过α，上层路径α，β，φ可能导致表不一致α，β，α（即，子节点路径A，B，A）。
算法检测到所有组件子节点具有不直接通向相邻组件的路径的情况。这些导致禁止的3节点路径（例如，α，β，φ）被添加为基于规则的约束。例如，如果β的下一个节点是φ，则β不能有a作为前一个节点。在从目标到起点的 Dijkstra 搜索过程中，如果这些规则中的任何一个适用，则前一个可能的节点将被拒绝。图 20.12c 展示了从目标 y 开始的表构建过程。来自 β（β，φ，γ），δ（δ，φ，γ）和 φ（φ，γ）的路径已经确定；a 不能被选为 β 的前一个节点，即使它是最短距离。相反，α 的输出必须是 δ（图 20.12d）。请注意，然而，在这个例子中，网格表之间没有不一致性。从 A 到 J 的路径将使用网格表，导致最短路径 A，B，C，D，E，I，J。
20.6.6 添加层次结构
AddHierarchy () 函数负责从下层组件中心构建更高的层次结构。如第 20.5.5 节所述，上层节点之间的链接被定义为其子节点中心之间的路径。
20.6.7 组件计算
组件计算分两个阶段进行。第一阶段由函数 ComputeComponent () 执行，使用节点连接性信息计算组件（见第 20.5.1 节）。对于第一阶段，需要记住的唯一事情是使用单向连接。例如，对于 3 个节点 N1，N2，N3，具有单向连接 N1 到 N2，N2 到 N3，N3 到 N1，我们在同一个组件中有 N1，N2，N3。
第二阶段分割这些组件，将在接下来的部分解释。
20.7 表不一致性
如果如前所述使用，表生成将产生不一致性。这些被定义为节点路径内的无限循环，最终阻止达到目标。没有单向链接，不一致性总是发生在两个边界节点之间（即，不同瓦片中的链接节点）。有单向链接时，循环可以包括不确定数量的节点，但至少有两个边界节点。这些不一致性是由于查找表生成的局部性质和分层方法引起的，并在表构建过程中解决。
20.7.1 分割有问题的组件和计算组件中心
SplitProblematicComponents () 负责解决表中两种可能的不一致情况：相反路径不一致性和我们称为凸性问题的另一种情况。解决每种情况的方法类似。对于组件中的每个节点，确定它是否与其他组件节点兼容。这意味着计算瓦片邻域内的路径。这些路径基于第 20.6 节中计算的查找表中的 21 个相邻瓦片。
20.7.1.1 相反路径不一致性
图 20.13a，b 展示了相反路径不一致性。从 D 到 K 使用节点 - 节点表的最短路径是 D，A，B，C，F，G，K。然而，从 A 到 K 是通过节点 - 组件中心表进行的。如果包括 K 的组件的中心是 H，I 或 J，最短路径是 A，D，E，H，I，J。这造成了不一致。同样，K，L，J 不能是包括 H 或 I 的组件的中心。这表明 H，I 和 K，L 对不能在同一个组件中，因此我们必须分割它们。这个问题只发生在相邻瓦片的边缘边界上（节点 D 和 F）。
20.7.1.2 凸性问题
组件内的所有路径都应该留在组件内。上层节点不应该通过另一个节点链接到自身。图 20.13c，d 展示了这样的情况，从 C 到 D 的最短路径是 C，F，G，H，E，D，并且超出了组件。这意味着 C 和 D 不能在同一个组件中，应该被分割。
20.7.1.3 组件中心
一旦找到分割约束，就再次计算组件。这次有几个可能的组件选择。例如，在图 20.13b 中，我们可以有组件 {H，I，J} 和 {K，L} 或组件 {H，I} 和 {J，K，L}。算法首先选择表面积最小的组件。
之后，可以计算组件中心。然而，由于相反路径不一致性等问题，一些组件中心可能是非法的。例如，在图 20.13b 中，“J” 不能是组件中心。
目前，组件中心是从允许的中心集合中选择的组件的重心。例如，可以通过减少链接中心之间的距离来优化中心选择。
20.7.2 移除无效子链接
RemoveInvalidSubLink () 函数负责移除由于表构建过程的局部性质和路径启发式（选择最远的组件中心作为子目标）导致的表不一致性。根据瓦片邻域，子目标选择可能会产生回溯的路径。通过在查找表中删除最远子目标的链接来解决此问题。图 20.14e，h 展示了如何通过删除 B 到 N 的路径的查找表中的输出边缘来更改子目标。
由于分层构建过程确保上层表对于相邻节点是一致的（第 20.6.5 节中的约束），删除最远的子目标仍然会导致有效的路径。
这种类型的不一致性只能在子目标更改时发生在瓦片边界上，并且主要是长路径的问题。在这些情况下，上层数据比下层数据更准确，因此，算法从上到下验证层。
图 20.14 展示了子目标选择的动态性质引起的问题。在某些情况下，选择最远的可能子目标可能导致回溯。在图 20.14d 所示的示例中，删除了从 B 到 N 的节点 - 组件表访问。前往 P 的最后一个有效子目标将是 H，消除了图 20.14f 中的不一致性。
20.8 表在服务器上的使用
在第 20.5.4 节中，我们看到了如何处理路径请求。如前所述，直到目标都不需要计算多边形或上层节点的路径。由于不需要搜索，请求非常快。
然而，这只产生了多边形序列，而不是实际要遵循的路径。使用优化的漏斗算法 [Douglas 06] 来计算平滑路径。即使在找到网格路径时不考虑 NPC 半径，漏斗算法也会使用它将路径推离边界多边形。
使用智能体半径进行路径平滑会导致路径看起来更好，但不能防止大型 NPC 与碰撞边界相交。可以创建一个新表（不一定是新网格）来避免狭窄通道，但这可能会导致长时间的绕行。
为了进一步提高短距离的路径质量，对目标进行直线路径搜索。如果发现障碍物，则使用路径查找算法。
20.9 结果
所提出的导航系统以灵活性损失为代价提供了非常快的查询速度。一个查询大约需要 4 微秒。预计算数据的主要问题是任何动态更改都需要一个新表；因此，这种方法最适合静态世界。然而，一些动态变化，如开门 / 关门，通过允许 / 禁止穿过门多边形来支持。此检查在运行时完成。
这种缺点被导航系统在运行时所需的处理能力的大幅降低所抵消。最昂贵的任务是相对简单的最近多边形查询，这也通过规则网格分区得到了促进。即使是平滑路径计算也更便宜。
20.9.1 平滑距离
使用平滑距离而不是附加距离来计算查找表（第 20.6.3 节）提高了路径质量。
使用随机轨迹的基准测试表明，超过 70％的路径的长度保持不变。对于其余的路径，长度既有增加也有减少。然而，减少超过 5％的轨迹数量是增加相同比例的轨迹数量的 10 倍。
平滑距离技术带来了成本：不对称路径、算法复杂性增加以及表计算时间增加一倍。然而，计算时间仍然在可接受的范围内，对于测试的最大地图，计算时间不到 80 秒。
20.9.2 表构建器算法
我们尝试了三种算法来计算查找表：Floyd - Warshall，Dijkstra 和 A*。在路径质量方面，Dijkstra 使用平滑距离给出了最佳结果。最快的算法是 A结合附加距离给出的。A使用的启发式是到正在处理的瓦片的距离。
Floyd - Warshall 算法较慢，并且难以添加新约束或使用平滑距离。它计算所有 21 个相邻瓦片的所有节点之间的所有最短路径。在图 20.8a 的示例中，这意味着需要 42×42 条路径，而不是 2×42 条（图 20.8b）。
A * 使用平滑距离的启发式是到当前处理瓦片最近边界的欧几里得距离。即使该算法为处理瓦片中的所有多边形返回最短可能路径，其全局结果也会比 Dijkstra 版本差。瓦片表的不一致性增加，为了解决这些问题，使用了更长的路径。
值得注意的是，当与附加距离度量结合使用时，所有三种算法都产生了相似的结果。
20.9.3 表大小
最大的表大小约为 4 兆字节（Mo），用于 1.5 平方千米的森林。地牢和城镇的大小在 500 千字节以下。请注意，此数据不是基于最终地图，并且在地图设计过程中，表大小有时会达到 10 Mo。
20.9.4 替代用途
除了导航之外，网格还用于检查碰撞数据，但它最有趣的次要应用是游戏内 2D 地图的自动生成。玩家可以访问世界的 2D 地图，该地图必须代表玩家可以访问的区域。此地图基本上是导航网格的投影。不幸的是，其生成过程的细节超出了本文的范围。然而，值得在图 20.15 中展示此酷炫功能使我们能够生成的其中一张地图。
20.10 结论
本文描述了自动生成预计算导航系统所采取的步骤。我们强调了处理单向路径的方法，并评估了执行距离测量的不同方法。最终的系统允许在大型和精细的世界中进行非常快速的导航请求。对于安全或客户端硬件限制有严格要求的所有基于服务器的应用程序，这是一个很好的解决方案。
整个生成系统是完全自动的，使团队的其他成员能够专注于更具创造性的工作。我们希望本文对其他创建预计算导航系统的人有用，并帮助他们避免潜在的陷阱。
致谢
我们要感谢所有 FFXIV 团队，特别是参与 2D 地图自动生成的坂田信平，使我们能够分享导航网格的这个意外用途。
