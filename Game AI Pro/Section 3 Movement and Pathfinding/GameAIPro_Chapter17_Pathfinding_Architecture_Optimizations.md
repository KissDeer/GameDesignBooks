# 三杠一、寻路架构优化
**史蒂夫·拉宾**和**内森·R·斯特尔特万特**

## 17.1 引言
在许多类型的游戏中，智能体的路径请求会消耗大量的AI CPU周期，这是众所周知的，例如实时战略游戏和第一人称射击游戏。因此，AI程序员在优化寻路架构方面需要达成共识，这是非常必要的。本章将按照优先级顺序介绍您可以采取的最重要步骤，以获得最快的寻路引擎。

所有游戏开发者都知道A*是寻路搜索算法的首选，但令人惊讶的是，或者说并不那么令人惊讶的是，它并不是万能的。有一个庞大的知识领域对于构建最快的引擎至关重要。事实上，即使已经做出了大量的寻路设计选择，您仍然可以做很多事情。

## 17.2 性能差异的数量级
最快和最慢的A*实现之间的区别是什么？

在迪吉彭理工学院的视频游戏大学，入门AI课程要求学生在固定的规则网格上编程实现一个简单的A*作为第一批作业之一。作为作业的额外奖励，会举行一场比赛，看谁能写出最快的A*实现。所以，如果您猜测最快和最慢的解决方案之间的差异，您会猜测什么？您会猜测最好的解决方案比最慢的快几倍吗？

真正的答案非常令人惊讶。多年来，数百名学生参加了该课程，最快的实现比最慢的实现快2个数量级（100倍的差异）。最快的实现也比平均实现快1个数量级（10倍的差异）。为了具体说明这个例子，在给定的地图上，最快的实现找到路径需要约200微秒，平均需要2500微秒，而最慢的实现需要超过20000微秒。考虑到这些是大三、大四和硕士学生，您认为如果给您同样的任务，您会排名如何？这是一个奇怪的问题，因为作为一名专业的游戏程序员，您永远不会处于这样的位置。无论您可能排名如何，想到您可能比最佳解决方案慢1到2个数量级，这是一个可怕的想法。

虽然学生较少，但第二作者在常规作业和比赛中与他的学生也有类似的经历。两位作者的见解在这里得到了提炼。因此，您可能想要在本章中寻找智慧的精华，以使您的实现与最佳实现保持在相近的水平。

## 17.3 优化 #1：构建高质量的启发式算法
这第一个优化是经典的内存与速度权衡编程的缩影。有许多构建启发式算法的方法；我们将在这里介绍几种有用的方法。

### 17.3.1 预先计算每一条路径（Roy - Floyd - Warshall）
乍一看这似乎很荒谬，但可以预先计算搜索空间中的每一条路径并将其存储在查找表中。内存影响是严重的，但有一些方法可以缓和内存要求并使其适用于游戏。

该算法在英语圈中被称为Floyd - Warshall算法，而在欧洲它更被称为Roy - Floyd算法。由于该算法是由三位不同的数学家独立发现的，我们将给予每个人荣誉，并将其称为Roy - Floyd - Warshall算法[Millington 09]。

虽然我们不会详细解释该算法以实现它，但您应该了解其基本优势和属性，以便您可以做出明智的选择，是否为您的游戏实现它。以下是事实：
- Roy - Floyd - Warshall是在运行时生成路径的绝对最快方式。它通常应该比最佳A*实现快一个数量级。
- 查找表在游戏发布前离线计算。
- 查找表需要$O(n^2)$个条目，其中n是节点的数量。例如，对于一个100乘100的网格搜索空间，有10000个节点。因此，查找表所需的内存将是100000000个条目（每个条目2字节，这将是约200MB）。
- 路径生成就像查找答案一样简单。时间复杂度是$O(p)$，其中P是最终路径中的节点数量。

图17.1显示了一个搜索空间以及由Roy - Floyd - Warshall算法生成的相应表格。通过连续查找路径中的下一步（图17.1中的左表）来找到完整的路径。例如，如果您想找到从B到A的最终路径，您首先查找（B，A）的条目，这是节点D。您将前往节点D，然后查找路径的下一步（D，A），这将是节点E。通过一直重复到节点A，您将以绝对最小的CPU工作量行驶最佳路径。如果地图中存在必须避免的动态障碍物，只要在查找表中存储距离而不是要行驶的下一个节点，这种方法就可以用作非常准确的启发式估计（图17.1中的右表）。

如前所述，在游戏中，您可以通过创建相互连接的最小节点网络来使内存要求更合理[Waveren 01，van der Sterren 04]。例如，如果您的关卡中有1000个总节点，这通常需要在表中存储$1000^2 = 1000000$个条目。但是，如果您可以创建50个每个包含20个节点的节点区域，那么所需的总条目数将是$50×20^2 = 20000$（这是少50倍的条目）。

### 17.3.2 Roy - Floyd - Warshall的无损压缩
减少内存要求的另一种方法是压缩Roy - Floyd - Warshall数据。已发表的工作[Botea 11]表明了压缩数据的有效性，并且在2012年基于网格的路径规划竞赛中，当有足够的内存时，这种方法表现得非常好。

压缩Roy - Floyd - Warshall数据的另一种方法是利用环境的结构。在许多地图中，但不是所有地图，通过状态空间的相对较少的最优路径具有显著长度，并且这些路径中的大多数重叠。因此，可以找到一些稀疏的“中转节点”，最优路径通过这些节点[Bast et al. 07]。如果对于状态空间中的每个状态，我们存储该状态到所有中转节点的路径，以及所有中转节点之间的最优路径，我们可以使用比存储所有状态对之间的最短路径更少的空间轻松重建任何两个状态之间的最短路径信息。这是在高速公路地图上已被证明非常有效的几种方法之一[Abraham et al. 10]。

### 17.3.3 Roy - Floyd - Warshall的有损压缩
完整的Roy - Floyd - Warshall数据导致非常快速的寻路查询，但代价是内存开销。在许多情况下，您可能希望使用更少的内存和更多的CPU，这意味着构建强大但不完美的启发式算法。

想象一下，如果我们只存储Roy - Floyd - Warshall数据的几行/列。这对应于保留从几个选定节点的最短路径。幸运的是，可以从这些数据中推断出所有节点之间改进的距离估计。如果$d(x, y)$是节点x和y之间的距离，并且我们知道$d(p, z)$对于所有z，那么x和y之间的估计距离是$h(x, y) = |d(p, x) - d(p, y)|$，其中P是一个枢轴节点，对应于Roy - Floyd - Warshall数据中的单行/列。对于多个枢轴节点，我们可以执行多个启发式查找并取最大值。改进的估计将减少A*搜索的成本。

这种方法在许多上下文中得到了发展，并被赋予了许多不同的名称[Ng and Zhang 01，Goldberg and Harrelson 05，Goldenberg et al. 11，Rayner et al. 11]。我们更喜欢欧几里得嵌入这个名称，我们将很快说明原因。首先，我们总结这种方法的事实：
- 欧几里得嵌入可以比地图的默认启发式算法准确得多，在某些地图中几乎与Roy - Floyd - Warshall一样快。
- 查找表可以在游戏发布前或运行时计算，具体取决于地图的大小和动态性质。
- 启发式需要$O(kn)$个条目，其中n是节点的数量，k是枢轴的数量。
- 欧几里得嵌入为引导A*搜索提供了一种启发式。给定多个启发式算法，A*通常应该取所有可用启发式算法的最大值。

为什么我们称这为欧几里得嵌入？考虑一个缠绕成螺旋形的地图，如图17.2所示。点A和B在地图的坐标中非常接近，但在考虑A和B之间的最小旅行距离时却非常远。如果我们能够将地图展开成一条直线，距离估计将更加准确。因此，核心问题是用于美学和游戏玩法目的的坐标对于A*搜索目的不是最佳的。也就是说，它们不能提供准确的启发式估计。如果我们能够提供一组针对A*搜索优化的不同坐标，我们可以使用这些坐标来估计节点之间的距离并拥有更高质量的启发式算法。将地图转换为新的状态空间的过程，其中距离估计（希望）更准确，称为嵌入。从枢轴节点进行的单源最短路径搜索等同于执行一维嵌入，因为每个节点都获得一个坐标，并且此嵌入中的启发式算法是嵌入点之间的距离。其他类型的嵌入是可能的，只是尚未得到很好的理解。

这种方法的关键问题是如何选择枢轴。一般来说，枢轴不应位于地图的中心，而应靠近边缘。当从枢轴p到x的最优路径通过y时，枢轴p在节点x和y之间的启发式算法将最为准确。在许多游戏中，有角色通常会旅行的位置，这表明枢轴的良好位置。例如，在RPG中，区域的入口和出口点是良好的位置。在RTS中，玩家基地将是最有用的。在夺旗FPS中，旗帜的位置可能效果很好。

## 17.4 优化 #2：使用最佳搜索空间表示
如果您必须在运行时搜索路径，那么您可以进行的首要优化是使用有效的搜索空间表示。原因是寻找路径所花费的时间与必须考虑的节点数量成正比。更少的节点等同于更少的搜索时间。关于选择搜索空间表示的更深入讨论可以在本书中找到[Sturtevant 13]。

图17.3显示了三种主要的搜索空间表示。正如您可以清楚地看到，网格搜索空间使用的节点最多，航路点图和导航网格（navmesh）的节点数量少一个数量级。

如果您有一个大世界，这三种搜索空间表示都不足以将CPU负载保持在最低限度。相反，您需要诉诸于使用分层表示来细分搜索空间。分层寻路是指搜索空间可以细分为至少两个级别：高级别的区域到区域表示和低级别的逐步表示[Rabin 00]。在这种方案中，首先在高级别表示中找到从起始区域到目标区域的路径（想象城堡中的房间，从门厅开始，找到从一个房间到阳台的房间到房间的路径）。然后，为了开始移动，在起始区域内找到从起始区域到路径上的下一个区域的低级路径（例如，从门厅的站立位置到路径上的下一个房间）。一旦进入第二个区域，然后从第二个区域到第三个区域找到逐步路径，依此类推。

在已发布的游戏中，分层寻路的两个具体例子包括《龙腾世纪：起源》[Sturtevant 08]和《英雄连》[Jurney et al. 07]。《龙腾世纪：起源》的最终架构在低级网格之上使用了两级基于网格的抽象。在《英雄连》中，高级搜索空间表示是六边形网格，低级表示是常规正方形网格。如果没有足够的内存来存储低级状态空间的Roy - Floyd - Warshall解决方案，通常有足够的内存来将此信息存储在抽象状态空间中。

## 17.5 优化 #3：预分配所有必要的内存
一旦您优化了搜索空间，下一步是确保在搜索期间绝对不分配内存。尽管所有游戏程序员都应该根深蒂固地知道这一点，但怎么强调都不为过。搜索期间的内存分配可能会使搜索时间增加至少一个数量级。

您如何避免内存分配？只需在启动时预分配一个内存池并重用它。由于节点的内存大小相同，它们可以很容易地从预分配的缓冲区中取出，而不会有任何碎片问题。

A*所需的内存也可以是地图表示的一部分。这避免了明确存储单独的闭列表的需要，因为地图中的每个节点都可以有一个标志，指示它是否在闭列表中。如果使用id而不是布尔标志，搜索可以避免在大多数搜索之间重置闭列表中的节点。

## 17.6 优化 #4：高估启发式算法
为了保证A*找到最优路径，启发式算法必须是可接受的，这意味着从当前节点到目标节点的启发式成本猜测绝不能高估真实成本。然而，通过使用高估的启发式算法，您可以在可能牺牲略微非最优路径的情况下获得巨大的加速。虽然这听起来最初像是一个可怕的权衡，但事实证明，少量的高估具有很大的好处，而几乎没有明显的非最优性。在搜索算法的世界中，这曾经可能被视为异端邪说，但在视频游戏行业中，这是一个精明而值得的优化。

为了理解如何高估启发式算法，让我们首先看一下等式17.1，这是经典的A*成本公式。如您所见，最终成本$f(x)$是给定成本$g(x)$和启发式成本$h(x)$的总和。添加到开放列表中的每个节点都会被分配这个最终成本，这就是开放列表的排序方式。

$f(x) = g(x) + h(x)$（17.1）

等式17.2显示了在公式的启发式部分添加权重。

$f(x) = g(x) + (h(x)×weight)$（17.2）

通过改变权重，我们可以调整A*的行为。如果权重为零，则公式简化为仅$g(x)$，这与Dijkstra搜索算法相同。这种方法保证找到最优路径，但不是一种“智能”搜索，因为它在所有方向上均匀地向外探索。如果权重为1.0，则等式是经典的A*公式，保证在给定当前启发式估计的情况下扩展找到最优路径所需的最小节点数，模除平局打破。如果权重大于1.0，则我们将算法倾向于贪婪最佳优先搜索的行为，这不是最优的，但专注于尽快找到目标。

因此，我们可以通过权重调整A*，使其倾向于Dijkstra或贪婪最佳优先。通过使用1.1到1.5或更高的权重，我们可以逐步迫使搜索更积极地推向目标节点，同时以可能的次优路径为代价。当地形充满类似于柱子或树木的随机障碍物时，更大的权重很有意义，并且路径不会明显次优。然而，如果最终路径需要远离目标的大量回溯，则建议使用较低的权重。

您的游戏或游戏部分的正确权重必须通过实验发现。也有可能根据路径允许的次优程度的特定误差容限自适应地发现区域的理想权重。有关此类算法，请参阅[Thayer and Ruml 08]。无论如何，高估启发式算法是一种经过试验和验证的游戏优化，您将希望探索。

## 17.7 优化 #5：更好的启发式算法
有两种使用更好的启发式算法的方法。首先，某些启发式算法更适合解决某些问题，因此选择正确的启发式算法可以显着减少解决问题所需的工作量。第二种方法是构建和存储改进的启发式算法，Roy - Floyd - Warshall算法只是其中一个例子。当地图拓扑相对静态时，构建新的启发式算法最有用，因为改变世界可能会使启发式算法无效。

至于启发式算法的选择，考虑在网格上进行寻路，具有8向移动。三个可能的启发式算法是直线（欧几里得）距离、八叉树距离（假设只允许$45^{\circ}$和$90^{\circ}$角）和曼哈顿（城市街区）距离。曼哈顿距离是一种较差的启发式算法，因为它会高估距离，没有考虑对角线移动。直线启发式算法也很差，因为它会低估距离，假设路径可以采取任何角度。八叉树启发式算法，与世界中的移动完全对应，是在网格上使用的最准确和最佳的启发式算法。两点之间的八叉树启发式算法可以计算为$max(\Delta x, \Delta y) + 0.41·min(\Delta x, \Delta y)$，假设对角线移动的成本为1.41。

## 17.8 优化 #6：开放列表排序
A*的教科书描述指出，每一步应该扩展具有最低f成本的节点。更有效的实现将打破具有相同f成本的节点之间的平局，朝着具有更大g成本的节点倾斜，因为这些节点预计更接近目标。这导致更好的平局打破，这在一些地图中可能非常重要。开放列表的排序可以在优先级队列结构（如堆）中完成，尽管研究人员花费了大量精力改进这些数据结构，因此如果需要完全排序，弱堆[Edelkamp et al.，12]只是加速A*的一种选择。通常情况下，插入优先级队列中的最后一个节点会立即被删除，以进行下一次扩展。在将插入的节点插入开放列表之前缓存它可以减少这种开销。

一种更有效的方法是避免显式排序状态。在状态空间中，唯一f成本的数量将很小，可以为每个唯一的f成本维护一个列表；在开放列表上找到最佳节点就像从具有最小f成本的列表中取出第一个节点一样简单。这似乎排除了通过更高g成本打破平局的可能性，但将每个f成本列表视为后进先出（LIFO）堆栈将产生类似的平局打破效果。

找到最便宜的节点只是遍历短列表的问题。由于甚至没有琐碎方案的开销，无序开放列表可以非常快，因为它根本不会执行那么多指令。为了提供更多细节，无序开放列表作为数组保存，插入的节点放在数组的末尾。当必须删除一个节点时，它将被数组末尾的节点替换，以保持紧凑。使用此数据结构，维护数据结构的开销几乎不存在，并且其极简主义的大小（每个节点一个指针）意味着它非常缓存友好，从而导致更快的速度。

## 17.9 优化 #7：搜索期间不回溯

这可能看起来很明显，但没有路径会沿着它已经访问过的相同节点回溯，因此类似地，A * 搜索也不应该考虑回溯的节点。在实践中，这就像如果相邻节点与父节点相同，则不考虑该相邻节点一样简单。这个简单的优化将使搜索速度加快大约一个分支因子。对于网格搜索空间，这是 1/8，但对于导航网格搜索空间，这大约是 1/3。

在网格中，有许多短周期，这意味着从许多不同的邻居冗余地查找给定状态会有开销。通过对状态空间进行廉价的扫描，可以使搜索跳过许多中间节点，以避免这些冗余查找。此方法的完整细节是 Jump-Point Search 算法的一部分 [Harabor and Grastien 11]。

## 17.10 优化 #8：缓存后继节点

在 A * 搜索中，最常见的操作之一是查找节点的邻居。因此，该操作应该尽可能便宜。明确存储每个节点的邻居，而不是遍历更昂贵的数据结构，可以显着提高速度，但会增加额外的内存成本。

## 17.11 寻路的坏主意

以下是一些通常会导致寻路搜索变慢的坏主意列表。

### 17.11.1 坏主意 #1：同时搜索

当同时需要许多寻路搜索请求时，必须做出架构决策，即同时应该处理多少个同时搜索请求。例如，如果需要 10 个请求，很容易想到在所有请求之间进行时间切片，以便一个非常缓慢的搜索不会阻碍其他请求。

不幸的是，同时支持许多同时搜索充满了灾难。主要问题是您需要为每个请求支持单独的开放列表。这对所需内存量的影响是严重的，随后在缓存中的颠簸可能是毁灭性的。

但是对于一个搜索阻碍所有其他搜索的情况该怎么办呢？一方面，这可能是一个虚假的担忧，因为您的寻路引擎对于所有搜索都应该是极快的。如果不是，那么这表明您选择了错误的搜索空间表示或应该使用分层寻路。

然而，如果我们承认单个搜索可能需要很长时间来计算，那么一种解决方案是向超市学习。超市处理此问题的方式是创建两种类型的结账通道。一种是为物品很少的顾客（10 件或更少），另一种是为购物车装满杂货的顾客。我们可以通过允许同时进行最多两个搜索来对寻路做类似的事情。

一个队列用于被认为相对较快的请求（基于起始点和目标点之间的距离），另一个队列用于被认为需要较长时间的请求（再次基于起始点和目标点之间的距离）。

### 17.11.2 坏主意 #2：双向寻路

一种创新的搜索算法方法是从两个方向搜索路径，并在搜索相遇时完成路径。这种双向寻路减少了广度优先和深度优先搜索访问的节点数量 [Pohl 71]，但 A * 呢？

考虑这种方法的一个绝妙理由是大陆和岛屿问题。考虑一个从大陆开始的搜索，目标在一个岛屿上，但我们无法穿越水域。对于从大陆开始的传统 A * 搜索，必须探索整个大陆，然后搜索才能得出不存在路径的结论，这非常非常耗时。对于双向寻路，搜索从两端开始，岛屿一侧很快耗尽节点，搜索得出不存在路径的结论（工作量最小）。

然而，即使不考虑大陆 - 岛屿问题，事实是双向寻路对于 A*通常需要两倍的工作量。当两个搜索被一个障碍物隔开，并且两个搜索都在障碍物后面备份，直到一个溢出并连接时，可以看到这一点。由于我们更关心最坏情况而不是最佳情况，因此这是一个需要避免的重要情况。出于这些原因，双向寻路对于 A*通常是一个糟糕的选择。

### 17.11.3 坏主意 #3：缓存成功或失败的路径

虽然缓存昂贵操作的结果通常是一个好的优化建议，但对于路径来说不是一个好主意。原因是独特的路径太多了。内存要求会非常大（类似于 Roy - Floyd - Warshall），并且您再次请求完全相同路径的机会非常小。

## 17.12 结论

本文介绍了提高 A * 实现速度的技术。使用这些想法可以确保您的代码与最佳实现相当，并且比更天真的实现快几个数量级。
