三杠三、通过迭代波前边缘扩展创建高阶导航网格
D. 亨特・黑尔和 G. 迈克尔・扬布拉德
19.1 引言
当将 AI 驱动的角色放入您的沉浸式游戏世界中时，需要解决一个大问题，那就是环境的有意义表示问题。这些角色可获得的关于环境布局的唯一信息来源是游戏设计师提供给他们的信息，通常是以几何模型的形式，这些模型在空间中组装以创建世界。但在除最简单的游戏之外的所有游戏中，这些模型文件中的细节级别通常过于复杂、过于详细，并且更多地是为了显示而不是空间推理而组织的。相反，需要某种形式的空间抽象来将相似的区域分组到单个空间区域中，以供角色考虑。
从历史上看，这种表示通常以航路点图的形式呈现（即空间中已知开放点的有效点，以及它们之间的一系列已知良好路线）。搜索这样的结构允许 AI 角色在可穿越空间中生成看似合理的路径 [Tozour 04]。随着导航网格空间表示的使用增加，航路点图的使用一直在下降 [McAnils 08]。导航网格（通常称为 navmesh）由区域列表组成，这些区域是可穿越空间的明确定义的凸分组（通常由多边形或多面体定义），以及描述连接性的附加列表（作为拓扑图）。这个组织为图的区域集合可以快速搜索以生成路径，并且角色可以从一个区域走到另一个区域，知道他们将留在可穿越区域。
传统上，导航网格要么是手动创建的，要么是使用某种形式的自动空间分解算法创建的，该算法检查环境中存在的障碍物，然后将它们之间的区域分解为尽可能少的区域。减少世界中存在的区域数量会产生更小的搜索空间，并且通常被认为对空间分解非常重要。不幸的是，为游戏环境创建具有最佳（绝对最小）区域数量的分解是 NP 难的 [Lingas 82]。这意味着没有最好的技术。相反，有许多技术试图接近最佳技术。这些方法通常从环境的某种三角剖分开始 [Delaunay 34]，然后通过组合这些三角形来尝试最小化环境中存在的区域数量 [Hertel 83]。
这种方法的问题是，留在导航网格中的三角形会给角色在许多三角形在单个点汇聚的区域中的导航带来问题。角色几乎不可能说出他们在汇合点所在的区域。不幸的是，这些汇合点在复杂环境中经常出现。这会导致本地化和路径查找问题（即，如果角色不知道它在哪里，那么它如何找到到达目的地的路径）[Hale 11]。
三角形分解方法的替代方案，也是有助于最小化角色本地化问题的一种方法，是基于增长的方法。在我们之前的工作中，我们提出了 2D（PASFV）和 3D（VASFV）基于增长的空间分解算法 [Hale 08, Hale 09]，这些算法受到空间填充体积算法的启发 [Tozour 04]。虽然这些方法确实生成了高质量的导航网格，但在大型环境中执行时可能会很慢（算法的运行时间根据要分解的区域增加）。这是因为这些算法执行了许多不必要的碰撞测试，因为它们必须验证每个增长区域在每个增长步骤中是否没有侵入另一个区域或障碍物。绝大多数情况下，情况并非如此，并且该测试将返回否定结果。这种不必要的测试是传统基于增长的算法中顺序迭代扩展的结果。
我们开发了迭代波前边缘扩展单元分解（简称为波前）算法，通过减少碰撞测试和迭代增长来解决以前技术的问题。该算法通过扫描我们在世界中放置的每个区域可见的世界几何形状来工作，并确定可能发生碰撞的位置（即，有趣的扩展方向）。通过迫使我们的区域直接扩展到这些位置，我们消除了除少数碰撞测试之外的所有测试。这改变了基于增长的算法的运行时，使其随着世界的复杂性（障碍物的数量）而增加，而不是世界的面积。这种技术不仅比现有的基于增长的技术更快，而且使用波前算法生成的导航网格通过提供更高阶的多边形 / 多面体几何形状区域，保留了 PASFV 和 VASFV 算法所展示的高网格质量 [Hale 11]。
19.2 波前空间分解
波前边缘扩展单元分解（波前）算法源自 PASFV 和 VASFV 算法 [Hale 08, Hale 09]，并与它们共享几个实现步骤。该算法通过四步过程生成分解。首先，将单位大小的潜在区域（种子）放入世界中。接下来，随机选择其中一个区域，并从该区域的角度分析世界中存在的障碍物。在算法的第三步，所选区域进入加速扩展阶段。这种扩展是朝着算法第二步分析中发现的障碍物进行的。算法的第二步和第三步对每个区域重复；这将每个区域扩展到其最大可能大小。最后，在算法的第四步，将新的种子放入与刚刚创建的区域相邻的任何可穿越空间（又名，空空间、未配置空间、负空间）中，算法返回第二步，允许这些新区域扩展。如果没有放置新种子，算法终止。
19.2.1 初始播种
传统上，基于增长的算法开始使用基于网格的模式将初始单位大小的区域放入世界中。然后，这些方法迭代地给每个区域机会，使其沿着该区域的每个边缘（或 3D 中的面 —— 为了简单起见，我们将使用边缘，因为它们实际上都是占用空间的边界）的法线方向向外生长和扩展。
当在初始播种阶段使用波前算法时，我们使用一种播种算法生成潜在种子点的列表，该算法在每个暴露的障碍物边缘旁边放置一个潜在种子。这导致使用比简单网格播种更少的单位大小的四边形（或 3D 中的立方体）区域更好地覆盖环境 [Hale 11]。然后随机选择其中一个种子点作为我们的初始区域。其他潜在种子点将保留用于以后的播种过程，但只有当它们仍然在可穿越空间的区域中，并且尚未被任何区域声称时才会使用。如果在以后的播种阶段此列表为空，我们将尝试通过查找与我们放置的区域相邻的未声明可穿越空间的区域来重新填充它。如果此后该列表仍然为空，则波前算法将终止。
19.2.2 边缘分类
在生成种子区域后，我们进入波前算法的边缘分类步骤。接下来的这两个步骤是该算法计算量最大的步骤，我们只希望在我们知道将扩展的有效区域上执行它们。因此，我们一次只扩展一个区域，并丢弃被早期扩展覆盖的区域种子。在这一步中，我们迭代世界中存在的障碍物的每个边缘以及我们已经放入环境中的区域中存在的任何边缘。然后，我们丢弃任何法线背离区域目标种子点的边缘，因为这些边缘是背面，它们不能与区域相互作用。然后，我们根据这些边缘与目标种子位置的相对空间位置将这些边缘分类为类别（+x，-x，+y，-y，+z，-z）。请注意，此技术在分解区域之间创建轴对齐边缘（显然不能保证在区域与障碍物之间），这使得 AI 角色更容易推理和穿越区域。跨越多个类别的边缘将根据算法实现中使用的评估顺序放置在第一个适用的类别中。我们的参考实现使用以下顺序 + y，-y，+x，-x，+z 和 - z。任何顺序都可以，只要始终遵循。
一旦边缘被分类，我们找到所有潜在的事件点。我们的区域将有一个边缘，该边缘与每个分类类别垂直，并且其法线与分类类别匹配（我们将其称为分类边缘）。通过将我们分类的每个障碍物边缘的斜率与适当的分类边缘进行比较，我们可以提前确定扩展区域将如何与障碍物相互作用。这可以通过想象从初始种子点绘制的径向半平面扫描，然后沿着每个边缘以 90 度弧旋转来可视化，如图 19.1 和 19.2 所示。此扫描线将报告它找到的边缘的方向以及边缘上离初始种子点最近的点。这些占用空间的边缘与我们刚刚放置的区域的边缘之间的相互作用可以简化为一系列情况。
基于事件的空间分解的两个简单情况：左侧的情况显示向平行元素的扩展，右侧的情况显示发现侵入顶点。
波前分解的两个复杂情况涉及分裂事件。

这些情况中的第一种发生在测试边缘被发现与分类边缘平行时，如图 19.1 的左侧所示。在这种情况下，我们希望移动分类边缘，使其与目标边缘相邻且共面。我们通过计算边缘上离我们正在评估的区域的初始种子点最近的点来实现这一点。然后，我们将此点以及从该点到区域初始种子点的距离记录为事件。顺便说一句，由于我们放置的所有区域只暴露轴对齐边缘，并且我们扩展的区域也只暴露轴对齐边缘，任何涉及其他可穿越空间区域的事件都将属于此类别。
当检查边缘并发现其向内倾斜朝向分类边缘（即，正在评估的区域边缘）时，会发生稍微复杂的情况，如图 19.1 的右侧所示。在这种情况下，我们只能扩展到该边缘的最近顶点位于分类边缘上，而不改变分类边缘的斜率。我们不能改变这个斜率，因为这将导致先前声明的可穿越空间区域被放弃，这将违反我们的一个不变量（声明的区域空间必须始终由该区域声明）。这种情况也通过存储正在评估的边缘上最近顶点的位置以及该顶点到区域初始种子点的距离来解决。
最后，我们来到最复杂的情况，这可能导致向扩展区域添加新边缘。在这种情况下，如图 19.2 的左侧所示，最近的障碍物边缘远离分类边缘的中点倾斜，并且可以移动分类边缘，使得其一个顶点可以与正在考虑的边缘相交。这是一个边缘分裂情况，为了计算此分裂应发生的位置，找到正在评估的边缘上离区域初始种子点最近的点。然后，将此点与该点与区域初始种子点之间的距离一起存储为事件点。此外，我们希望存储正在考虑的边缘的两个端点（假设最近点不是端点），以便我们能够增加该区域的阶数（阶数表示多边形 / 多面体的相对边数，因此三角形的阶数为三，八边形的阶数为八，依此类推），使其添加一个与正在考虑的边缘的整个长度相邻的新边缘。然而，我们不会计算这些端点与初始种子点之间的距离，而是将它们视为特殊情况，就好像它们离初始点的距离比我们用于分裂的点略远一样。这将防止这些点干扰过程中的其他计算。
图 19.2 的右侧可以看到一个更复杂的情况，其中有多个分裂事件。事件应根据与扩展区域的初始种子点的距离顺序进行处理，通过改变这两个端点的距离，我们将确保该区域在处理该点时尝试完全包含与它分裂的边缘相邻的所有空间。
此时，我们有了一组新区域可以扩展的潜在事件；然而，在我们开始扩展之前，我们需要做两件事。首先，如果世界的边缘被定义为一些边界条件而不是不可穿越的空间，则需要插入事件以允许每个区域向外扩展到世界的边缘。然后，需要根据每个事件与区域初始种子点之间的距离对该列表进行排序。这导致首先处理更近的事件，因为我们更有可能到达它们，因为由于更直接的障碍物的存在，更远的事件通常是无法到达的。
19.2.3 边缘扩展
有了这个区域的完整事件列表，我们能够进入波前算法的扩展阶段。首先，区域所有边缘的扩展速率都重置为零。然后，选择并从潜在事件列表中删除第一个（最近的）未处理的扩展事件。然后计算区域的边缘必须移动的距离，以便它们到达此扩展事件。这是通过计算两个（3D 中为三个）最近边缘的当前位置与目标扩展位置之间的距离来完成的。然后将此结果分解为其主要成分（x，y，z），如果这些值为正，则将它们设置为具有指向目标事件的法线的边缘的扩展速率。使用速率是逐步增长的遗留问题，但这里的速率表示直接跳转到事件点。然后，每个边缘应迭代地向外移动进行扩展。一旦所有边缘都移动了，就可以执行对任何碰撞或无效扩展条件的检查。这是因为存在分裂事件，如果仅执行事件的一半（即，只允许一个而不是两个边缘扩展），可能会导致无效配置。
一旦区域完成扩展，必须解决与其他区域或障碍物的任何碰撞。与障碍物碰撞的扩展区域的任何顶点必须被分割，并且必须通过插入新边缘将该区域转换为更高阶的多边形 / 多面体。要构建此新边缘，请获取障碍物边缘的相反法线，并将此新边缘约束到障碍物边缘的范围内。由于扩展事件是在不考虑其他区域或潜在障碍物的情况下单独计算的，因此可能会发生碰撞，并且该区域可能不得不从潜在的扩展事件中收缩。如果发生这种情况，则参与碰撞的边缘应停止进一步扩展的尝试。然后，算法将选择另一个扩展事件，重复此过程，直到没有更多事件或其所有边缘由于碰撞而停止扩展尝试。
19.2.4 重新播种
所有区域完成扩展后，将按照前面的播种过程讨论放置其他区域。如果算法进入播种阶段，并且无法放置任何新区域，则终止。这导致一组准备用作导航网格的区域。此外，如果需要，可以通过组合相邻区域来清理此区域集合，使得结果仍然是凸的。
19.3 后分解
现有的基于增长的空间分解算法（例如，PASFV、VASFV 和 SFV）利用后处理步骤来提高生成的导航网格的质量。偶尔，两个或多个区域种子将生长到环境的一个区域中，该区域可以由一个凸区域填充。这是同时放置和生长多个种子的自然结果，通常通过组合区域来纠正。然而，这种组合需要时间和精力，如果不需要这样做会很好。波前算法的一个优势是，由于它一次只生长一个区域，因此避免了大部分这种形式的清理。由于两个区域不会同时生长，它们不会都试图细分可穿越空间的同一个凸区域，从而产生更干净的分解。
19.4 波前运行时
波前算法的最坏情况运行时受其执行环境的复杂性限制，为 O（n * m）。在这种情况下，n 是世界中存在的障碍物的数量，每个障碍物都将由算法播种的 m 个区域进行评估。这个运行时似乎比现有的基于增长的空间分解算法更差（它们通常以分数形式增加，O（n^（1 /x）），其中 n 是世界中平方单位的数量，x 是区域的数量），但请记住，这些算法的运行时根据世界的大小增加（由于必须执行额外的增长步骤来填充世界）。
波前算法的运行时仅随着环境的实际复杂性增加，而不是由于引入额外的未占用空间。一般来说，在各种不同大小和复杂性的游戏环境中，我们对这两种算法的参考实现的平均运行时，波前算法在毫秒到秒的范围内，而我们基于增长的实现则在秒到分钟的范围内。波前算法的内存占用随着每个新生成的区域只需要在任何给定时间点与现有区域和障碍物进行交互和了解而线性增长。
19.5 与现有技术的比较
波前算法已与生成空间分解的现有方法进行了比较，特别关注当前在行业中使用的方法，即 Delaunay 三角剖分、Hertel - Melhlorn 分解和梯形细胞分解。我们只针对也生成全覆盖分解的算法进行比较，以确保比较有效。对 25 个程序生成的世界进行了评估，这些世界由随机生成和放置的障碍物组成，没有轴对齐限制，并且有一组基本规则，生成的测试世界的几何形状与许多游戏中发现的相似（生成规则受到公共 Quake 3 关卡的影响，这些关卡用于初始测试）。
我们使用考虑中的每个算法为世界生成分解（其中一个级别和它的波前分解如图 19.3 所示）。然后，我们根据存在的区域数量和分解的质量（使用导航网格评估指标 [Hale 11] 确定任何退化或低质量区域的数量和形状）对分解进行评估。我们发现，与梯形分解或 Delaunay 三角剖分分解相比，使用波前算法生成的分解包含的总区域更少，近退化区域也更少。我们将近退化区域定义为 AI 角色难以进入或离开的区域。这些区域的特征是形状奇怪或奇异的区域（例如，所有三角形的扇区在单个点汇聚，基于四边形的区域的细长条跨越环境，与其他区域相邻非常狭窄的区域，或不相交 / 连接不良的区域），我们能够测试和检测到这些区域。
波前算法和 Hertel - Melhlorn 分解之间的区域数量一致；然而，波前分解的近退化区域比 Hertel - Melhlorn 分解少 [Hale 11]。波前算法的这些近退化区域较少并不奇怪，因为它具有我们测试的其他分解技术所不具备的独特属性。即，在可穿越空间的单个点上汇聚的区域数量有一个上限为五（3D 中为 10）；[Hale 11] 中的数学证明。其他常用技术对可穿越空间的单个点上可以汇聚的区域数量没有上限。许多区域汇聚到单个点上通常会导致近退化区域的创建，如果可能的话应该避免。
值得注意的是，波前算法生成的分解似乎与梯形细胞分解算法生成的分解相似。然而，它们是不同的分解，因为波前算法将始终生成区域更少的分解。这是由于梯形分解仅限于在单个方向（垂直或水平）分解世界，而波前算法实际上是多方向分解（垂直和水平波前都源自初始区域种子）。
有关波前技术评估、定量数字和导航网格质量指标的详细信息，请参阅 Hale 的《基于增长的自动生成导航网格的方法》[Hale 11]。
19.6 结论
总体而言，波前算法通过基于四边形的扩展算法生成用于导航网格的快速、高质量分解。这种分解具有较少的可能干扰角色导航的小和退化区域（通常是三角形）。该算法通过执行更少的扩展步骤改进了以前的基于增长的方法，从而减少了必须执行的碰撞测试的数量。这产生了一种算法，其运行时随着世界的复杂性而不是世界的大小而扩展，就像现有的基于增长的方法一样。此外，由于该算法一次只增长一个区域，因此通常由多个区域竞争填充同一凸区域引起的后期处理较少。该算法生成的分解与现有流行算法（例如，Hertel - Melhlorn 或梯形细胞分解）生成的分解相比具有优势。