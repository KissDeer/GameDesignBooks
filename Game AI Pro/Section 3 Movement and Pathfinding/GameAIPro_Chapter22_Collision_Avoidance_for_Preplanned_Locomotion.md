# 三杠六、预规划移动的碰撞避免
**鲍比·安圭洛夫**

## 22.1 引言
对于任何角色移动系统来说，NPC的碰撞避免都是至关重要的组成部分。迄今为止，大多数碰撞避免方法要么基于雷诺兹（Reynold）的开创性转向文章[Reynolds 99]，要么基于众多相互速度障碍技术（RVO）之一[Guy et al. 10, v.d. Berg et al. 08]。为了通过减少脚滑等瑕疵来提高角色移动的视觉保真度，一些开发人员正在从传统的基于转向的移动转向动画驱动移动（ADL）系统与预规划运动相结合。本文讨论了将移动系统转向预规划ADL系统对避免碰撞的影响，以及为什么传统的碰撞避免系统对于预规划运动可能过于复杂。我们介绍了《杀手：赦免》（Hitman: Absolution）中使用的碰撞避免方法，并讨论了如何将该系统适用于任何预规划移动系统。

在传统的转向系统中，角色通常被模拟为移动的球体，角色的轨迹是根据这些球体的当前速度计算的。然后，适当的角色动画被叠加在这个模拟之上，以给人一种角色实际上在移动的错觉。由于动画和模拟之间存在脱节，动画不能保证与模拟完全匹配，导致明显的瑕疵，如脚滑。ADL采取了相反的方法，其中角色的轨迹更新直接从动画中读取，这意味着角色的位置更新和动画是同步的，完全消除了脚滑。不幸的是，在使用ADL时，我们将角色的运动限制在可用的动画集内，从而可能牺牲了转向系统提供的广泛运动范围。此外，ADL系统存在固有的延迟，因为我们只能在脚着地时改变运动，这意味着我们经常需要等待一步完成后才能调整我们的运动。关于这些系统的详细讨论超出了本文的范围，感兴趣的读者可以参考[Anguelov et al. 12]以获取更多信息。

一旦我们让角色移动起来，我们理想情况下希望他们在我们的游戏世界中从一个位置导航到另一个位置。至少在碰撞避免方面，关键的区别在于移动系统中的路径跟随行为。在大多数情况下，路径点只是被视为粗略的目标，转向系统的任务是在它们之间导航。在基于转向的系统中，转向动作产生的路径可能与找到的原始路径有很大偏差。不幸的是，根据ADL运动约束以及ADL延迟，我们可能会陷入问题情况，角色会剪辑角落或可能离开导航网格（navmesh）。

当转向需求对于移动系统来说过于精细，或者移动系统没有考虑ADL延迟时，就会发生这种情况，这在高移动速度下非常成问题。这些问题可以通过对转向系统进行复杂的调整来改善，同时考虑ADL约束以及其他措施，如将角色限制在navmesh内。不幸的是，这种调整的复杂性迅速增加，以至于我们的移动系统变得非常复杂，甚至还没有考虑碰撞避免。现在，这并不是说这种方法不起作用，因为许多开发人员成功地使用了这种方法，但我们认为有一个更简单的解决方案。

我们认为重要的是不要将ADL减少的运动集视为劣势，而应视为优势，因为选项的减少使我们能够为整个路径预规划我们的运动。我们所说的预规划是指在开始移动之前规划到达最终目标的确切路径，以及可能需要的动画集。这意味着对于任何给定的时间点，我们都可以预测智能体的确切位置和速度。有多种方法可以实现这种预规划，读者可以参考[Champandard 09]和[Anguelov 12]以获取更多信息。

正是在这些预规划系统中，传统的避免技术开始失去其适用性，因为我们的移动是精确预计算的。标准的RVO系统通过尝试为角色找到相对于场景中其他角色的局部无碰撞速度来解决碰撞。然后，角色的速度将被调整以匹配无碰撞速度。这一切都是在局部邻域内完成的，只返回即时的无碰撞速度，而不考虑其他任何因素；这可能会导致异常行为，如智能体振荡。讨论RVO的潜在问题超出了本文的范围，我们只是想指出RVO是一个局部避免系统，考虑到我们对智能体移动的全局知识，它可能不是解决避免问题的最佳方法。

## 22.2 预规划移动的碰撞避免
我们构建了一个非常简单但强大的避免系统，使我们能够在比RVO允许的更全局的范围内检测碰撞。我们的解决方案还允许我们在ADL系统的约束内以高保真度解决碰撞。《杀手：赦免》的移动是一个基于预规划ADL的系统，每个角色都精确地遵循平滑路径。这些平滑路径是通过对现有导航网格路径进行后处理创建的，然后将此路径转换为一组连续的二次贝塞尔曲线。感兴趣的读者可以参考安圭洛夫[12]以获取关于HMA中使用的路径后处理的信息。

我们的角色将精确地遵循这些平滑路径，每帧移动的距离从当前选择的动画中读取。简单地说，你可以把我们的角色想象成在轨道上。这些路径是我们避免系统的主要输入，次要输入是角色的当前状态和运动数据，由移动系统填充。

我们的避免系统由三个不同的阶段组成：碰撞检测、简单碰撞解决和非简单碰撞解决。我们的避免系统每帧为每个智能体运行一次，并且每个智能体依次与场景中的每个其他智能体（现在称为碰撞器）进行碰撞检查。碰撞检查的结果要么是速度修改/停止命令，要么是路径重新规划的请求。

第一阶段和我们避免方法的核心是碰撞检测机制。我们的角色（现在称为智能体）被建模为具有固定碰撞半径的碰撞球体，碰撞检测系统的前提是简单地沿着我们的路径滑动我们的球体，并检查它们是否在不与任何其他球体碰撞的情况下到达路径的终点。

在每个智能体的动画/移动程序的帧更新期间，智能体将查询避免系统，以查看其当前路径是否无碰撞。避免系统将执行碰撞检测过程，并尝试简单地解决检测到的碰撞。这个系统的细节太复杂，无法在这里讨论，因为它是围绕我们的移动系统构建的，所以我们不会尝试这样做，而是尽力最好地描述更高层次的概念，以激励您构建类似的系统。

## 22.3 碰撞检测和简单碰撞解决
我们的碰撞检测如下工作：我们首先为我们的智能体计算碰撞检测范围。在我们的情况下，我们确切地知道如果我们必须立即发出停止命令，我们的智能体需要多少时间和距离才能停止。然后，将这个停止距离添加到指定的时间范围长度（以秒为单位）乘以我们当前的速度，结果就是我们智能体的碰撞检测范围（参考图22.1a）。

停止距离很重要，因为我们不想触发“停止”命令，这会导致我们的智能体停在另一个智能体的路径上，或者更糟糕的是，最终停在另一个智能体内部。时间范围窗口允许我们比RVO系统更早地检测到碰撞。在我们的测试中，我们发现只需要提前检查两秒，就可以在性能和保真度之间取得良好的平衡。

在我们实际检查智能体的路径之前，我们对碰撞器进行两次排除检查。我们首先运行一个简单的点积检查，以确定碰撞器是否在智能体相对于运动方向的前方。通过忽略智能体后面的任何碰撞器，我们隐含地将任何可能发生的潜在碰撞的责任委托给那些碰撞器。如果确定碰撞器在我们的运动方向上，我们使用智能体和碰撞器的位置作为球体原点，以及智能体和碰撞器计算的碰撞检测范围作为球体半径，进行简单的球体 - 球体相交测试[Ericson 05a]。如果两个测试都成功，我们然后继续检查智能体的路径与碰撞器的碰撞。

路径检查是通过将智能体沿着其路径移动智能体的碰撞半径（ACR）来执行的。通过以离散间隔沿着其路径移动智能体，我们将我们的连续路径离散化为ACR长度的片段。智能体完成一个ACR长度移动所需的时间（即每次移动的时间或TPM）由智能体的当前速度确定，并用于计算移动的平均速度向量。然后，我们通过计算TPM间隔结束时碰撞器的位置来移动碰撞器，以确保时间一致性；这个位置和时间用于计算碰撞器速度向量。

在我们的情况下，我们的智能体总是以固定速度移动，所以这个计算很简单，但如果您的每个动画剪辑的速度不同，它将变得更加复杂。在图22.1a中可视化了智能体的碰撞球体沿着路径移动4个TPM间隔的过程。一旦我们有了智能体和碰撞器的最终位置以及平均速度向量，我们执行移动球体 - 移动球体检查[Ericson 05b]。

如果我们检测到球体之间的相交，我们需要记录一些关于碰撞的数据以供以后使用。此数据最初包含碰撞点处智能体和碰撞器的位置。我们还通过检查智能体的前进方向与到碰撞器中心的向量之间的角度是否在某个阈值内（在我们的情况下约为10度）来存储碰撞是否是正面碰撞。然后计算并存储两个碰撞球体在该碰撞中潜在重叠百分比的粗略估计。重叠百分比的计算方法是演员碰撞球体直径减去两个球体之间沿其各自路径的最小距离（除以演员碰撞直径）。我们存储的最后一点数据是智能体前进方向的正交向量，远离碰撞器的运动方向。这个正交向量用于稍后的路径修改。图22.1b中可视化了我们为检测到的碰撞存储的所有必要数据。

如果没有检测到碰撞，我们计算下一个TPM间隔的碰撞球体运动，并重复检查，直到我们到达智能体碰撞检测范围的终点。如果我们检测到碰撞，我们立即终止检测阶段并进入简单解决阶段。重要的是要注意，我们的系统只关注检测到的第一次碰撞，因此只尝试解决该碰撞。假设沿着智能体路径的任何进一步碰撞将在后续帧中被检测和解决。

简单解决阶段尝试通过简单的速度修改来解决检测到的碰撞。我们尝试通过以不同的智能体速度执行路径检查算法来实现这一点。如果这个新的智能体速度导致无碰撞路径，那么我们简单地指示智能体改变速度。这种调整是立即的，并且任何后续对避免系统的调用都将使用更新的智能体速度。这意味着任何其他运行避免检查的智能体都将使用更新的智能体速度。

对所有可用速度进行速度修改检查，如果所有速度仍然导致碰撞，那么我们检查我们的停止距离是否无碰撞；如果是，那么我们指示智能体停止并等待，直到它可以继续在无碰撞路径上移动。

这个简单的系统解决了我们游戏中现有的大部分碰撞，但我们需要一个额外的系统来处理无法通过简单速度修改避免的碰撞（例如，静止的智能体或正面碰撞）。这个辅助系统用于我们所谓的非简单碰撞解决，但在我们继续之前，我们需要讨论关于碰撞检测阶段的一些细节。

首先，我们假设我们所有的角色都在移动，但情况并非总是如此。在许多情况下，角色是静止的，要么执行一些特定于关卡或空闲的动作（例如，使用ATM或靠在墙上）。这些静止的角色必须以不同的方式处理，因为它们没有分配路径。碰撞检查以相同的方式进行，除了现在智能体是静止的，所以我们根本不需要为碰撞器计算更新位置。

其次，即使智能体在移动，它们也可能处于开始或停止的过渡动画中。在我们的情况下，我们的智能体以线性速度移动，这大大简化了路径碰撞检查中的数学。在开始或停止时，我们在过渡期间有一个非线性速度，因此我们对这些过渡期间智能体速度和位置的预测相当复杂。我们不想通过在避免代码中对非线性过渡速度进行建模来不必要地增加复杂性，所以我们简单地诉诸于估计这些过渡期间的速度。

过渡期间的智能体速度是通过将过渡的剩余距离除以过渡的时间来估计的。我们还试图确保我们的启动和停止动画尽可能短，进一步减少这种估计的误差。需要记住的是，您的过渡可能有很长一段时间，其中智能体实际上没有移动。例如，我们有一个原地转弯的开始过渡，智能体在过渡的一半以上时间内会转弯，但实际上没有改变位置；这破坏了我们的估计代码，要求我们必须预处理所有动画，以确定动画中实际移动角色的部分。幸运的是，这些非移动间隔通常只在动画的开始或结束，这使得通过简单地减少过渡时间并在该时间内将碰撞器视为静止来处理变得容易。

由于我们的默认避免查询是针对已经移动的智能体，我们还需要考虑静止的智能体并希望开始移动。我们创建了一个自定义的“CheckForCollisionFreeStart”避免查询，它考虑了我们的非线性开始过渡，并确定何时可以安全地开始移动。这个额外的检查允许我们等待其他智能体让开，然后再开始移动。我们向避免系统添加了两个额外的游戏特定查询，用于处理战斗侧步和掩护射击行为。由于我们不希望智能体踏入另一个智能体的路径，我们为战斗程序提供了一个接口，用于在发出任何移动/行动命令之前查询提议的新位置是否无碰撞。

## 22.4 通过路径修改进行非简单碰撞解决
我们的非简单碰撞解决是一个路径修改系统：我们在不需要在路径查找器级别上重新规划的情况下，修改智能体的路径以绕过障碍物。利用在检测阶段存储的碰撞数据，我们计算一个避免点（AP）来解决碰撞，并在原始路径上计算一个重新连接点（RP）。

从智能体的当前位置到RP的整个路径被替换为一条新路径，该路径由两条三次贝塞尔曲线组成，并通过AP。AP计算为沿着碰撞点处智能体前进向量的正交向量的某个距离的点。我们沿着正交向量应用大约5倍智能体碰撞半径的相对较大距离来计算避免点。重要的是要注意，避免点的实际位置并不是那么重要；仅仅通过改变路径的长度，我们也会影响我们到达先前碰撞点的时间，这本身通常足以解决碰撞。

计算避免点后，我们执行导航网格查询，以确保避免点在导航网格上，并且从智能体的碰撞位置可以直线到达。如果该点不在导航网格上，我们只需将该点截断到沿着正交向量的最远导航网格点，该点超过某个最小避免阈值。然后，我们将AP的切线设置为与碰撞点处原始路径的切线相同。这意味着避免点只是作为路径的偏移。如果我们将AP截断到导航网格的外部边缘，我们必须将AP处的切线修改为与导航网格外部边缘的切线相同；这样做将有助于确保三次贝塞尔曲线在AP处保持在导航网格内（参考图22.2b）。

下一步是找到沿着从碰撞点开始的路径最远的直线可达导航网格点；这是RP。重要的是确保AP处的切线和到重新连接点的向量之间的差异通过某个阈值（在我们的情况下为8度），以确保重新连接曲线不会穿过原始路径。最后，我们然后切断智能体当前位置到RP的路径段，并将其替换为通过避免点的两条三次贝塞尔曲线，同时尊重设置的避免点切线。

在我们接受这个修改后的路径之前，有必要对其进行一些验证检查。第一次检查将路径离散化为短直线段，我们对每个段运行导航网格直线可达查询，以确保路径不会离开导航网格。如果路径离开导航网格，它将立即被丢弃。执行的第二次检查是路径碰撞检测检查，与检测阶段完全相同，只是在新修改的路径上以当前智能体速度进行。与检测阶段不同，如果结果是无碰撞或速度修改指令，则此检查被视为成功。如果我们收到速度修改指令，那么我们可以安全地接受路径，因为我们知道在下一帧将收到并执行速度修改指令。

有时修改后的路径会导致不可避免的碰撞；那么在这种情况下我们该怎么办？我们决定尝试通过使用否定的正交碰撞向量计算新的AP来找到替代的修改路径。我们验证这个替代路径，如果它再次导致不可避免的碰撞，那么我们只需在两个修改后的路径中选择导致最低碰撞重叠百分比的路径。

在许多情况下，两个路径都无法解决碰撞，因此我们尝试尽可能减少碰撞。在许多情况下，在对碰撞器运行避免查询并再次尝试最小化碰撞时，您可能会解决它。这正是我们看到几个智能体试图通过狭窄走廊导航时发生的情况。额外的好处是它导致形成流动通道。图22.3说明了通过碰撞最小化解决碰撞的示例。

## 22.5 性能和视觉质量
视觉质量对我们来说非常重要，因此我们在避免系统中添加了一些东西，以帮助提高我们移动的整体视觉保真度。我们注意到，当发送一群智能体去调查事件时，智能体往往会聚集在一起并一起移动。即使智能体没有碰撞，结果看起来也很差。我们决定在碰撞检测阶段结束时添加进一步的检查（如果我们没有检测到任何碰撞），以确保我们与任何与我们同向行走的智能体保持最小距离。我们简单地检查，如果一个智能体与一个碰撞器同向行走，并且智能体与碰撞器的距离小于最小距离，我们就会减速，直到满足最小距离要求。这个简单的检查对我们智能体的视觉质量产生了巨大的影响。我们还有一个问题，我们的AI中的错误有时会发送多个智能体到同一个位置，所以我们利用路径修改来允许我们修改路径的终点，确保智能体不会最终彼此重叠。

总的来说，我们避免系统的视觉保真度非常高，智能体修改速度或简单地停止并等待看起来非常好（在我们看来非常自然），特别是在狭窄的空间内。此外，我们的系统没有表现出RVO家族中非常普遍的任何振荡副作用。由于我们的碰撞检测是沿着智能体的路径进行的，与RVO相比，我们的检测具有绕过角落的额外优势，使我们能够在智能体到达角落之前很好地解决碰撞。

有人建议，RVO的大多数问题可以通过调整参数或算法来改善，但这只会进一步增加这种方法的成本和复杂性，这与我们方法的简单性形成鲜明对比。在性能方面，我们发现我们的系统非常便宜，在我们的生产级别中，我们能够为大约 30 个智能体执行避免查询，在 Playstation 3 上的总成本最高约为帧时间的 1 - 1.5％（0.3 - 0.5 毫秒）。

## 22.6 结论

我们提出了一种非常简单的替代 RVO 的预规划移动碰撞避免方法。该系统利用简单的几何相交测试来执行碰撞检测，并具有两个碰撞解决阶段。简单阶段利用速度修改和停止来解决碰撞，而非简单阶段计算新的路径以试图避免检测到的碰撞。我们讨论了《杀手：赦免》中这样一个系统的高级概念及其结果。该系统能够在复杂环境中处理多个智能体，并导致在狭窄空间中形成涌现的流场。此外，该系统背后的前提非常简单且易于扩展，允许开发人员在将这些概念应用于未来游戏时具有很大的自由度。
