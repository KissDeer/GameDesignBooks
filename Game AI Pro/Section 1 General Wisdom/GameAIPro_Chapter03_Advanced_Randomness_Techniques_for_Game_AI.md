一杠三、游戏人工智能的高级随机技术——高斯随机、过滤随机和柏林噪声
史蒂夫・拉宾、杰伊・戈德布拉特和费尔南多・席尔瓦
3.1 引言
游戏程序员与 rand () 函数有着特殊的关系。我们依靠它来为游戏带来变化，使我们的游戏玩法保持新鲜感，使我们的非玩家角色（NPC）不那么容易被预测。无论是决策、游戏事件还是动画选择，我们最不希望的是重复的角色或可预测的游戏玩法；因此，随机性已成为必不可少的工具。
然而，随机性是一种变幻无常的东西，人类尤其不擅长理解或推理它。这使得很容易误用或误解随机性实际提供的东西。本章将介绍三种高级技术，而我们可靠的老朋友 rand () 根本无法提供这些技术。
第一种技术涉及摒弃均匀随机，采用高斯随机来改变智能体的特征和行为。无论是单位的速度、敌人的反应时间还是枪支的瞄准，在现实生活中，这些生物和物理现象都呈现出正态（高斯）分布，而不是均匀分布。一旦理解了这种差异，您会发现高斯随机在您制作的游戏中有数十种用途。
第二种技术是操纵随机性，使其在短时间内对玩家来说看起来更随机。众所周知，当观察小的孤立随机运行时，随机性看起来并不随机，因此我们将致力于通过过滤随机来解决这个问题。
最后一种技术是使用一种特殊类型的随机，它既不是均匀的也不是高斯的，而是产生一种徘徊的特性，其中连续的随机数相互关联。柏林噪声常用于图形学，可用于行为随时间以平滑方式随机变化的情况。无论是移动、准确性、愤怒、注意力还是只是处于状态中，有许多行为特征可以使用一维柏林噪声随时间变化。
对于这三种技术中的每一种，本书的网站上都有演示和 C++ 库，您可以将其直接应用到您的游戏中。
3.2 技术 1：高斯随机
正态分布（也称为高斯分布或钟形曲线）在我们周围无处不在，隐藏在日常生活的统计数据中。我们在树木的高度、建筑物的高度和人的高度中看到这些分布。我们在购物中心购物者的行走速度、马拉松运动员的跑步速度和高速公路上汽车的速度中看到这些分布。在任何有大量生物或事物的地方，我们都有关于该群体的特征，这些特征呈现出正态分布。
这些分布中存在随机性，但它们不是均匀随机的。例如，一个人长到 6 英尺高的机会与他长到最终身高 5 英尺高或 7 英尺高的机会不同。如果机会相同，那么分布将是均匀随机的。相反，我们看到的正态分布是男性的身高集中在 5 英尺 10 英寸左右，并以钟形曲线的形状在两个方向上逐渐下降。事实上，几乎每一个生理和心理特征都有某种平均值，个体以正态分布的形式偏离平均值。无论是身高、反应时间、视力还是智力，这些特征在给定的群体中都将遵循正态分布。
生活中的一些随机事物确实表现出均匀分布，例如生男孩或女孩的机会。然而，生活中的大多数分布更接近正态分布而不是均匀分布。但为什么呢？
答案非常简单，由中心极限定理解释。基本上，当许多随机变量相加时，结果总和将遵循正态分布。当您掷三个 6 面骰子时可以看到这一点。虽然单个骰子落在任何一面上的机会是均匀的，但掷三个骰子且它们的总和等于最大值 18 的机会与其他结果相比并不是均匀的。例如，三个骰子总和为 18 的概率为 0.5%，而三个骰子总和为 10 的概率为 12.5%。图 3.1 显示，掷三个骰子的总和实际上遵循正态分布。
所以现在我们已经展示了随机变量的相加会导致正态分布，问题仍然存在：为什么生活中的大多数分布都遵循正态分布？答案是，宇宙中的几乎所有事物都有不止一个影响因素，而这些影响因素都有随机的方面。
例如，让我们来看看森林中成熟树木高度的分布。是什么决定了一棵树能长多高？成熟树木的高度受其基因、降水、土壤质量、空气质量、阳光量、温度以及暴露于昆虫或真菌的影响。对于整个森林，每棵树根据其所在的位置（例如在山坡上还是在山谷中）体验到每个质量的不同方面。即使是紧挨着的两棵树，在影响因素方面也会体验到细微的差异。树的最终高度本质上是每个单独因素影响的总和。换句话说，影响树高度的质量的效果是相加的，因此它们导致所有树木高度的正态分布。正如您可能想象的那样，对于生物系统或物理系统的几乎任何其他属性，都可以构建类似的论证。正态分布无处不在。
3.2.1 生成高斯随机
既然我们已经展示了正态分布在现实生活中是多么常见，那么将它们包含在我们的游戏中是有意义的。考虑到这一点，您可能想知道高斯随机性是如何生成的。前面的骰子例子给了我们一个线索。如果我们取三个均匀随机数（例如由 rand () 生成）并将它们相加，我们可以生成具有正态分布的随机数。
更准确地说，中心极限定理指出，在 [–1, 1] 范围内添加均匀随机数将接近均值为零、标准差为 K/3 的正态分布，其中 K 是相加的数字数量。如果我们选择 K 为 3，那么标准差等于 1，我们将得到几乎标准的正态分布。清单 3.1 中的代码展示了创建高斯随机是多么容易。
清单 3.1 中的代码足以在游戏中生成高斯随机。然而，有一些隐藏的细微差别需要解释。真正的正态分布会产生远远超出清单 3.1 提供的 [–3, 3] 范围的尾部值。虽然某些金融或医疗模拟可能需要准确的正态分布（有百万分之一的机会出现–4 的值），但游戏不需要，因此最好保证生成的值将在 [–3, 3] 范围内。
3.2.2 高斯随机的应用
高斯随机在人工智能中有许多用途 ，但在游戏中非常明显的一个用途是射弹的瞄准。虽然许多游戏可能根本不扰动射弹或使用均匀随机来扰动它们，但正确的方法是应用高斯随机。
图 3.2 显示了目标上的均匀和高斯子弹散布（由本书网站上的示例演示生成）。应该很明显，右边的高斯分布看起来更真实，但它是如何生成的呢？诀窍是使用极坐标和均匀随机和高斯随机的混合。首先，生成一个从 0 到 360° 的随机均匀角度。这个值用作极坐标来确定目标中心周围的角度。这个值是均匀的很重要，因为任何角度都应该有相等的机会。其次，生成一个随机高斯数来确定到目标中心的距离。通过组合随机均匀角度和随机高斯距离中心，您可以重现非常逼真的子弹散布。
游戏中高斯随机的其他应用包括 NPC 在群体中应该变化的任何方面。这些可能包括：
・平均或最大速度
・平均或最大加速度
・大小、宽度、高度或质量
・视觉或物理反应时间
・射击或重新装填的开火速率
・治疗或特殊能力的刷新速率或冷却速率
・错过或击中暴击的机会
需要思考的一件事是，您是想在群体成员之间改变特征，还是在每次使用该特征时改变它，或者两者兼而有之。例如，一个单独的士兵可能具有比群体平均水平慢的先天开火速率（在单位创建时使用高斯随机确定），但该单位的任何一次开火实例也可以在单位先天速率周围的正态分布内变化（有时单位开火速度稍快，有时稍慢）。
现在想象一下，一组 30 个单位都向敌人开火。如果每个单位都有一个先天的开火速率（正态分布），并且每个单位都在该速率周围变化（也呈正态分布），那么该群体的涌现行为应该是极其自然的，没有单位会相互同步开火。
均匀分布
高斯分布
50 发子弹
100 发子弹
200 发子弹
400 发子弹
图 3.2 目标上子弹散布的均匀分布和高斯分布。请注意，目标中的每个环代表一个标准差，66.7% 的高斯子弹击中最内环，95.8% 的子弹击中两个最内环。这个演示可以在本书的网站上找到。
3.3 技术 2：过滤随机
让我们直说吧：随机性太随机了（对于游戏中的许多用途来说）。起初，这似乎是一个荒谬的说法，但有大量证据表明，人类认为小的随机运行看起来并不随机。然而，这引出了一个有趣的后续问题：如果人类认为小的随机运行看起来不随机，那么他们实际上认为是什么样的呢？也许他们认为产生序列的东西要么坏了，要么被操纵了，要么在作弊 —— 所有这些都是归因于游戏或人工智能的可怕品质。
3.3.1 小的随机运行看起来不随机
既然我们已经提出了这个离谱的说法，让我们来支持它。首先，让我们确定小的随机运行看起来不随机。拿起一张废纸，开始以 50% 的机会随机写下 O 和 I 的序列 —— 一直写，直到您有一个 100 个数字的列表。继续，真正尝试一下。不，真的，这会让您成为一个更好的人。我们会等……
现在为了使这真正公平，拿出一枚硬币并开始抛它，将正面和反面的序列记录为 0 和 1。抛 100 次，以创建一个与您用头脑创建的列表可比的列表。再次，我们会等。如果您想获得大的回报，您必须实际这样做……
现在我们还可以将您制作的两个列表与由伪随机数生成器（PRNG）如 rand () 生成的列表进行比较，其中 0 或 1 的机会相同，均为 50%。以下是随机生成的 100 次抛硬币的序列。
01101100001100001010000001001011110011100111000110
10101011011111101001011110011111101011111101000011
注意到您手写的列表、抛硬币的列表和 PRNG 生成的列表之间有什么不同吗？很可能硬币翻转和 PRNG 列表更加 “成块”，包含更多的 0 或 1 的长序列，相比于您手写的列表。大多数人没有意识到的是，真正的随机性几乎总是包含这些长序列，这些是非常典型的，也是可以预期的。然而，大多数人根本不相信公平的硬币或真正的随机性会产生这些长时间的正面或反面。事实上，直到您自己实际抛硬币并看到它发生，才很难将这一教训内化（这就是为什么我们希望您实际去做）。
那么这如何应用于游戏呢？许多游戏包括这样的情况，即均匀分布的随机数决定了一些会影响玩家的事情，无论是正面还是负面。如果玩家对某些概率有期望，而游戏在短期内似乎负面地违背了这些概率（特别是结果对玩家有害），那么玩家会认为游戏坏了或作弊 。请记住，我们现在已经进入了心理学领域，暂时离开了数学。如果玩家认为游戏在作弊，那么尽管实际发生的情况并非如此，游戏实际上就是在作弊；当涉及到玩家对游戏的享受时，感知远比现实更重要。
例如，想象一下游戏设计师确定敌人应该有 10% 的几率进行暴击。不幸的是，在 30 小时游戏过程中的许多战斗后，玩家有很高的概率连续三次被暴击击中！游戏设计师曾经希望这种情况发生吗？不！但这就是随机数的现实。在许多情况下，对于游戏设计师实际想要的东西来说，随机性太随机了。
3.3.2 随机性看起来不随机：解决方法
如何迫使随机数对人类来说看起来更随机？真实但无帮助的答案是，以一种非常特殊的方式使数字稍微不那么随机。我们将做的是用非常小的随机性完整性来换取一个对人类来说看起来更随机的序列。
策略非常简单：当生成随机数序列时，如果下一个数会损害随机性的外观，假装您从未看到它并生成一个新的数 。就是这么简单。话虽如此，由于我们在这里处理的是心理学，因此该策略的实际实施是主观的。此外，如果数字的消除过于热心，它可能会损害随机性的完整性，因此实际实施必须仔细考虑。
3.3.3 识别异常
记住核心策略，第一项任务是识别使序列看起来不太随机的事物。事实证明，实际上只有两个主要原因：



1. 序列具有突出的模式，如在硬币翻转序列 11001100 或 111000 中。
2. 序列具有相同数字的长序列，如在硬币翻转序列 01011111110 中。
   我们可以将这两个原因归类为 “异常”，对人类来说看起来是非随机的（奇怪或不寻常）。然后，目标是编写某种规则来识别这些异常。一旦我们有了规则，我们就可以丢弃触发规则的最后一个数字（完成违规模式）。作为一个实现细节，我们的代码必须跟踪每个决策的最后 10 到 20 个生成的数字，以供我们的规则检查。我们将在后面的部分中更深入地探讨这一点。
   那么规则看起来像什么？这取决于生成的随机性类型。硬币翻转的规则将不同于随机范围或高斯随机性的规则。不幸的是，由于我们处理的是主观的人类感受，因此没有简单的方法来解决这个问题。
   3.3.3.1 过滤二进制随机
   如果想要 50% 的机会，就像硬币翻转一样，那么以下规则将以对人类来说看起来更随机的方式过滤随机性。请注意，这是一个有序的规则列表，每次生成新的随机数时都要检查。此外，每个新生成的数字只应允许触发一个规则。
3. 如果最新的值将产生 4 个或更多的连续数字，那么有 75% 的机会翻转最新的值。这并不会使 4 个或更多的连续数字变得不可能，但可能性会逐渐降低（4 个连续数字出现的概率从 1/8 变为 1/128）。可以完全禁止特定长度的连续数字，但这会更负面地影响随机性的完整性。
4. 如果最新的值导致四个值的重复模式，如 11001100，则翻转最后一个值（使序列变为 11001101）。
5. 如果最新的值导致 111000 或 000111 的重复模式，则翻转最后一个值。
   对于文章前面生成的二进制随机序列，过滤前后的情况如下：
   过滤前：
   01101100001100001010000001001011110011100111000110
   10101011011111101001011110011111101011111101000011
   过滤后（下划线数字是从原始序列中切换的）：
   01101100011000101010001001001011110011100111001110
   10101110011101101001011100111001101011101101000110
   3.3.3.2 过滤整数范围
   与二进制随机类似，可以构建规则来过滤出数字范围中出现的异常。以下是可以实施的一系列相当激进的规则。对于这套规则，任何违反规则的情况都会导致重新掷骰子的值，然后再次根据规则进行验证：
6. 重复的数字，如 “7, 7” 或 “3, 3”
7. 由一个数字分隔的重复数字，如 “8, 3, 8” 或 “6, 2, 6”
8. 计数序列为 4 的上升或下降，如 “3, 4, 5, 6”
9. 在最近 N 个值中，范围顶部或底部的太多值，如 “6, 8, 7, 9, 8, 6, 9”
10. 在最近 10 个值中出现的两个数字的模式，如 “5, 7, 3, 1, 5, 7”
11. 在最近 10 个值中，某个特定数字出现太多，如 “9, 4, 5, 9, 7, 8, 9, 0, 2, 9”。
    过滤前：
    22312552222577750677564061448482102435500989388459
    59607889964957780753281574605482138446235103745368
    过滤后（突出显示的数字因为违反规则而被丢弃）：
    22312552222577750677564061448482102435500989388459
    59607889964957780753281574605482138446235103745368
    3.3.3.3 过滤浮点数范围
    为了过滤 [0, 1] 范围内的浮点数，我们必须设计规则来避免类似数字的聚集，并避免增加或减少的序列。如果违反了这些规则中的任何一条，我们将简单地丢弃该值并请求一个新的随机数，该随机数必须通过所有规则。

1. 如果两个连续数字的差异小于 0.02，例如 0.875 和 0.856，则重新掷骰子。
2. 如果三个连续数字的差异小于 0.1，例如 0.345、0.421 和 0.387，则重新掷骰子。
3. 如果有 5 个连续数字的增加或减少序列，例如 0.342、0.572、0.619、0.783 和 0.868，则重新掷骰子。
4. 如果在最近 N 个值中，范围顶部或底部的数字太多，例如 0.325、0.198、0.056、0.432 和 0.216，则重新掷骰子。
   3.3.3.4 过滤高斯范围
   由于高斯数与浮点数非常相似，同样的规则将适用。但是，您可能会引入以下规则来避免高斯数特有的特定异常。
5. 如果有四个连续数字都大于或小于零，则重新掷骰子。
6. 如果有四个连续数字位于第二或第三偏差内，则重新掷骰子。
7. 如果有两个连续数字位于第三偏差内，则重新掷骰子。
   3.3.3.5 随机性完整性
   上一节中概述的规则是任意的，可以更严格或更宽松地更改。然而，规则越严格，结果值的随机性就越低。在极端情况下，非常严格的规则会过度约束序列，以至于可能预测下一个数字，这将违背使用随机数的初衷。
   此时，您应该问自己，过滤随机数的任何数量的规则是否会显著损害随机性的数学完整性。唯一明确回答这个问题的方法是对过滤后的随机数运行基准测试，以测量随机性的质量。开源程序 ENT 将运行各种指标来评估随机性，因此如果您设计自己的规则，建议运行这些基准测试。一般来说，只要规则不会过度约束或预先确定下一个数字，如给出的示例中那样，那么随机性将适合游戏人工智能中的几乎所有用途。
   3.3.4 过滤随机的实现细节
   在实现过滤随机时，必须注意将算法应用于随机的每个特定用途。使用过滤随机的每个独特随机决策都需要保留自己的历史，以便过滤后续的随机数。否则，由于特定用途的数字序列在整个序列中不是连续的，尽管您进行了过滤，纯随机仍可能重新出现。例如，如果您需要玩家暴击的随机机会，该序列必须与敌人暴击的随机机会分开过滤。这两种用途是独立的，因此一个的暴击不应影响另一个后续的暴击机会。这样做的一个优点是，您可以（如果您愿意）为不同的用途更改过滤特性。例如，您可能希望在角色玩扑克或进行某些锻造时允许更多的序列出现，在这种情况下，“幸运连胜” 的感觉可以增强玩家的体验，但仍然强烈限制暴击的序列。
   3.4 技术 3：游戏人工智能的柏林噪声
   如果您熟悉计算机图形学，您可能听说过柏林噪声。这种计算机生成的视觉效果是由肯・柏林（Ken Perlin）于 1983 年开发的，由于其在电影数字效果中的广泛应用，他顺便因该技术获得了奥斯卡奖。柏林噪声通常用作生成有机纹理和几何形状的组件。图 3.3 显示了柏林噪声纹理的典型示例。
   虽然柏林噪声可用于为视觉效果提供有机感（例如，烟雾、火焰或云的程序生成），但不太明显的是您如何将这种技术用于游戏人工智能。关键的认识是，柏林噪声产生一种既不是均匀也不是正态的随机性形式，而是可以描述为连贯的随机性，其中连续的随机数相互关联。这种随机性的 “平滑” 性质意味着我们不会从一个随机数到另一个随机数出现疯狂的跳跃，这是一个非常理想的特性。但这对游戏人工智能有什么用呢？
   第一步是在一维中可视化柏林噪声，如图 3.4 所示。这可以被视为一个随机徘徊的信号（一系列相关的随机数）。我们可以使用这个信号来控制我们的人工智能角色的特定行为特征随时间的移动或变化。以下是游戏人工智能的一些可能性列表。
   ・移动（方向、速度、加速度）
   ・叠加到动画上（为面部运动或注视添加噪声）
   ・准确性（连胜或连败，处于状态，运气或成功）
   ・注意力（警卫警觉性，响应时间）
   ・游戏风格（防御性，进攻性）
   ・情绪（平静，愤怒，快乐，悲伤，沮丧，狂躁，无聊，投入）
   因此，虽然均匀或高斯随机可用于改变群体中个体的物理或行为特征，但柏林噪声可用于随时间改变这些特征。当您有大量角色时，这可以使模拟更加有趣，因为每个特定角色可以在数秒、数分钟或数小时的持续时间内改变他们的行为特征。
   让我们更深入地探讨前面可能的游戏人工智能用途列表中的一些示例。通过随时间改变转向方向和速度，可以实现简单的徘徊。对于任意徘徊，柏林噪声是克雷格・雷诺兹（Craig Reynolds）提出的用于转向行为的特设连贯随机的更好替代方案，因为柏林噪声比雷诺兹的解决方案更具可配置性。
   可以有意地模拟热和冷的连胜，而不是事后偶然发生。这特别有用，因为您可以预测连胜，并可选地在中途让玩家意识到这一点，也许用这样的话：“伙计们，我今晚感觉很幸运！” 虽然均匀随机会有自然的连胜，但柏林噪声可以配置为控制连胜的行为并预测您何时会进入连胜。
   另一个可能的用途是以某种方式改变角色的情绪，例如，沿着平静与愤怒的尺度。虽然您可以想出一个潜在的模拟来生成这些特征或情绪变化中的任何一个，但使用柏林噪声随机生成它们可能会过度杀伤，并且更简单（开发时间和计算上），特别是在大量人群中，当没有一个人被玩家仔细审查时。然而，玩家可能会将注意力集中在一个角色上，在这种情况下，行为偏差背后明显缺乏合理性可能会带来问题。这个问题的一个解决方案是，当确定角色被注意到时，将模拟从柏林噪声转移到更强大的东西。在这个意义上，柏林噪声可以是一个 LOD 级别，当认为它可能导致现实中断时可以被取代 。此外，如果角色现在被玩家观察，可能是时候为人工智能创建一个不在场证明或背景故事，如本书中的另一篇文章所述 。
   3.4.1 生成一维柏林噪声
   既然我们知道为什么需要一维柏林噪声，让我们看看如何生成它并定制输出以满足我们的需求。在我们描述算法时，请注意允许您根据自己的偏好自定义噪声随机性的旋钮和控制。这些对于充分利用算法至关重要。在您探索生成部分时，您可能希望获取本书网站上的演示来跟随并尝试不同的设置。
   虽然由于数学的细微差别，柏林噪声的生成很难解释，但我们将通过使用图形为您提供更直观的视觉解释。请注意，确切的细节可以在演示中的示例代码中看到。
   在一维中，柏林噪声是通过首先决定使用多少个八度来构建的。每个八度在特定尺度上对信号细节做出贡献，更高的八度添加更细粒度的细节。每个八度单独计算，然后它们相互添加以产生最终信号。图 3.5 显示了由四个八度构建的一维柏林噪声。
   为了解释每个八度信号是如何产生的，让我们从第一个开始。第一个八度是通过在 [0, 1] 范围内以两个不同的均匀随机数开始和结束间隔来计算的。中间的信号是通过应用一个在两者之间插值的数学函数来计算的。理想的函数是 S 曲线函数 6t^5 - 15t^4 + 10t^3，因为它具有许多良好的数学性质，例如在一阶和二阶导数中是平滑的。这是理想的，以便更高八度中包含的信号是平滑的。
   对于第二个八度，我们选择三个均匀随机数，将它们等距放置，然后使用我们的 S 形函数在它们之间进行插值。类似地，对于第三个八度，我们选择五个均匀随机数，将它们等距放置，然后在它们之间进行插值。给定八度的均匀随机数的数量等于 2^(n - 1) + 1。图 3.5 显示了四个八度，每个八度内随机选择数字。
   一旦我们有了八度，下一步是用幅度缩放每个八度。这将导致更高的八度逐渐对最终信号中的细粒度方差做出贡献。从第一个八度开始，我们将信号乘以 0.5 的幅度，如图 3.5 所示。第二个八度乘以 0.25 的幅度，第三个八度乘以 0.125 的幅度，依此类推。给定八度的幅度公式为 p^i，其中 p 是持久性值，i 是八度（我们的示例使用的持久性值为 0.5）。持久性值将控制更高八度的影响力，持久性值越高，给更高八度的权重越大（在最终信号中产生更多的高频噪声）。
   现在八度已经被适当地缩放，我们可以将它们相加得到我们最终的一维柏林噪声信号，如图 3.5 的右下角所示。虽然这一切都很好，但重要的是要意识到，对于游戏人工智能的目的，您不会计算和存储整个最终信号，因为没有必要一次拥有整个信号。相反，给定信号上的特定时间，在 x 轴上的 [0, 1] 范围内，您将根据需要计算该特定点以用于您的模拟。因此，如果您想要最终信号中间的点，您将在时间 0.5 计算每个八度中的单个信号，用它们正确的幅度缩放每个八度值，并将它们相加得到一个值。然后，您可以通过请求下一个点，例如 0.500001、0.51 或 0.6，以任何速率运行您的模拟。
   3.4.1.1 控制柏林噪声
   如前一节所暗示的，有几个控制可以让您自定义噪声的随机性。以下是总结。
   ・八度的数量：较低的八度在信号中提供较大的摆动，而较高的八度提供更细粒度的噪声。这也可以在群体中随机化，因此在生成特定行为特征时，某些个体的八度比其他个体多。
   ・八度的范围：您可以有任何范围，例如八度 4 到 8。您不必从八度 1 开始。同样，范围可以在群体中随机化。
   ・每个八度的幅度：每个八度的幅度选择可用于控制最终信号。幅度越高，该八度对最终信号的影响就越大。如果您不希望最终信号超过 1.0，只需确保所有八度的幅度总和不超过 1.0。
   ・插值的选择：S 曲线函数通常用于柏林噪声，原始柏林噪声使用 3t^2 - 2t^3 ，改进的柏林噪声使用 6t^5 - 15t^4 + 10t^3（在二阶导数中平滑）。然而，通过选择不同的公式，您可能会获得其他有趣的效果。
   3.4.1.2 在区间之外采样柏林噪声
   当查看图 3.5 时，您可能会想到一旦我们到达区间的末尾（信号的最右边边缘）就会出现问题。一旦我们在时间 1.0 进行采样，就无处可去，因为信号突然停止。一种解决方案是在时间 0.0 重新开始，但这会导致巨大的不连续性和重复行为。幸运的是，有一个更优雅的解决方案。
   当我们需要在时间 1.0 之后采样时，我们可以生成一个完全新的柏林噪声信号，该信号连接到我们当前信号的末尾。如果我们简单地将每个八度右边缘的所有均匀随机数复制到每个新八度的最左边缘，那么我们的信号将无缝迁移到一个新的柏林噪声信号中（过渡的平滑度取决于使用的特定插值函数）。当然，我们需要为每个新八度中的剩余插槽生成新的均匀随机数，但这是理想的，以便我们开始生成一个完全新的信号。
   3.4.2 游戏人工智能柏林噪声演示
   在本书的网站上，您会找到与本节配套的柏林噪声演示。在演示中，您可以使用各种旋钮来控制噪声生成。柏林噪声用于改变单个智能体的徘徊、速度和攻击性。此外，查看源代码以发现柏林噪声生成的确切细节。
   3.5 结论
   本文介绍了三种高级随机技术，有助于增强我们的老朋友 rand () 函数。虽然均匀随机是游戏中变化的支柱，但高斯随机、过滤随机和柏林噪声等技术可以提供很酷的技巧，而普通的 rand () 本身无法提供这些技巧。
   在追求真实感的过程中，高斯随机为我们提供了正态分布，有助于模仿我们在现实生活中周围的实际变化，无论是生理特征、认知能力、反应时间还是子弹散布的自然变化。为了让玩家满意，我们可以利用过滤随机来确保影响玩家的有影响力的随机决策看起来公平和无偏见。最后，柏林噪声不再仅仅用于图形学。柏林噪声的一维连贯随机性可用于随时间平滑地改变移动、动画和许多其他行为特征。
   最后要注意的是，这三种技术都有相应的代码和演示，可以在本书的网站上找到。