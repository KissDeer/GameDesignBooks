# 五杠三、向环境提出智能问题



作者：Mieszko Zielinski

## 33.1 引言



在像射击游戏这样复杂且动态的环境中找到方向是一项挑战，特别是当你只是一个每帧只有很少 CPU 时间可用的人工智能角色时。生活很艰难。“我怎么知道该去哪里？如果有多个地方，我怎么判断哪个更好？哦！有一个敌人！两个！三个！我先射谁？” 创建一个能以低 CPU 时间成本为人工智能提供所需所有数据，同时又灵活易用的服务是一项棘手的任务。它需要能够寻找不同的事物、对它们进行过滤并打分。在《子弹风暴》中，我们创建了一个系统，它能满足人工智能的所有空间感知需求，且不占用太多 CPU 时间，对设计师来说也很直观。我们专注于创建一个能接受人类容易理解的输入的系统，而不是让人类生成系统难以处理的反直觉数据。

## 33.2 动机



在《子弹风暴》的早期开发中，设计并实现了两个新系统：一个用于人工智能逻辑（我们的行为树实现），另一个用于集中式环境查询。本文将描述后一个系统，我们称之为环境战术查询（简称 ETQ）。



在《子弹风暴》中，环境查询可以有两种形式：对象类型和对象属性。敌人、掩体和位置是对象类型的例子。在导航网格上、对敌人不可见、离领导者有一定距离等是对象属性的例子。这些对象属性也可以采用偏好的形式：偏好不可见的、偏好离我更近的等等。

## 33.3 目标



以下是我们在系统开发过程中追求的目标：



- 思考 “问什么” 而非 “如何问”：创建和提出问题要尽可能简单。我们不想让任何东西阻碍我们的创造力。
- 让非程序员来完成这项工作：我们从一开始就旨在为设计师创建一个专用编辑器，以便每当他们想要改变或调整人工智能选择掩体或敌人的方式时，他们只需点击就能做到。
- 代码可重用性：这是我们的主要编码原则，它使代码非常简洁紧凑。
- 性能：这个系统必须在不影响其他系统性能的情况下履行其职责。
- 异步：尽管 ETQ 系统本身在游戏线程上运行，但我们使其异步，这样提出的问题就不会阻塞游戏。相反，系统会安排在系统的常规更新期间执行查询处理。这也使我们能够对主查询处理循环进行时间切片。

## 33.4 我们的理念



我们希望我们理想化的数据创建者通过问自己简单的问题来编写查询：



- 生成什么？可以是掩体、敌人位置、点 —— 任何在游戏世界中有位置的东西。
- 谁在提问？查询的上下文对象是什么 —— 哪个实体在提出问题。通常是一个人工智能角色，但也可以是关于人工智能正在跟踪的敌人的问题（“他能去哪里？”），例如掩体或出生点。
- 在哪里查找？候选项目的空间限制是什么？我们可以在上下文对象周围的半径内生成项目，或者在对象分配的战斗区域内等等。
- 哪些项目足够好？可接受项目的最低质量是什么？我们可能要求从某个参考对象可见的项目，或者与上下文对象距离不小于 X 的项目等等。这些构成了条件。
- 哪些项目更好？我们如何判断一个项目比另一个更好？我们可以偏好离某物更近或更远的项目，或者偏好具有某些属性的项目，或者某个属性的值低于设定的限制等等。

## 33.5 结构



ETQ 系统是一个数据驱动的解决方案，其大部分功能在于数据表示的设计。我们在使其既灵活又高效方面下了很大功夫。现在是时候更详细地了解我们的设计了。

### 33.5.1 查询



一个查询有三个主要组件：



- 上下文对象：提出问题的游戏实体（或者更准确地说，是代表谁提出问题）。这个查询的空间上下文是什么？这很关键，因为这个角色的属性将用于定义一个主观的世界观，比如，“那个点从这里可见吗？” 和 “它在我的视野范围内吗？” 注意，上下文对象不一定是人工智能角色。
- 查询模板 ID：我们在问用户创建的哪个问题？系统中注册的所有查询模板都有其唯一的 ID，这里就是指明要使用哪个模板的地方。
- 项目：找到的所有项目都作为列表返回。稍后，我们将删除所有未通过后续过滤测试的项目。



要触发查询处理，需要调用 ETQ 系统并提供要运行的查询模板信息以及该查询的空间和游戏上下文。也可以请求立即处理查询，而不是在后台处理。

### 33.5.2 查询模板



既然我们知道了在运行时如何提出问题，那么我们如何定义一个问题呢？我们需要表达我们在寻找什么以及我们希望我们的 “好项目” 具有什么属性。我们可能需要某些属性，同时使用其他属性仅用于项目评分。



一个问题是在编辑器中使用我们创建的特殊工具定义的，并保存为常规资产。这个资产在代码中被引用为查询模板。一个查询模板由一个或多个选项组成，而选项又由几个测试组成。



首先，查询模板定义一个选项，该选项包含有关如何生成将在后续步骤中处理的项目集的信息。这创建了一个代表游戏世界中实体的项目集合。我们实现了许多生成器，例如：



- 上下文对象的敌人：收集给定人工智能意识到的所有敌人。
- 掩体：在上下文对象的参数化半径内生成一组掩体点。
- 网格上的点：在上下文对象周围的可配置网格上生成点。



ETQ 使创建新生成器变得极其容易，有时只需要两三行代码。



一旦设置了查询模板选项的生成器，就会指定过滤和评分这些项目的方法。项目通过测试进行筛选和评分。查看清单 33.1 以了解测试结构的伪代码。一个测试结构指定要测试的属性（测试类型）、测试的引用列表（参考）、比较类型（条件修饰符）和要比较的值（测试值）。如果测试用于评分，我们也可以为其分配权重。



测试的设置顺序无关紧要。系统会根据计算成本对测试进行重新排序。成本由程序员根据测试的相对昂贵程度列表（见 33.7 节）以及它是条件测试还是仅评分测试来估计。即使是最昂贵的测试也会在进行任何评分之前首先执行。这会在评分时减少项目数量，从长远来看可能会节省时间，也可能不会。我们在 33.10 节中通过最终测试来解决这个问题。



如果测试过于严格，没有项目通过条件，我们可能会放宽约束，而不是简单地使整个查询失败。系统支持这种情况。如果一个查询模板有多个选项，那么它们会按顺序处理，直到有一个选项产生一些项目，这些项目就成为查询的结果。

### 33.5.3 有效性测试



在查询模板的选项中声明的测试可以是条件、权重或两者皆是。然而，ETQ 也允许你将某些测试指定为有效性测试。这些测试不会在生成掩体时使用，而是在人工智能移动到那个掩体或坐在里面时使用，以检查掩体是否仍然有效（例如，未暴露在敌人火力下）。当然，一个测试可以同时是常规测试和有效性测试。这样，关于如何选择掩体点以及稍后如何判断它是否仍然良好（通常不是同一回事）的所有配置信息都很好地集中在一个地方。



我们可以通过对有问题的那个项目重新运行查询来实现相同的功能，但这会在进行持续验证时导致许多我们不需要的测试。我们也可以创建一个单独的轻量级查询仅用于有效性测试，但另一方面，每当其中一个查询发生变化时，就需要保持两个查询同步。将一些测试标记为有效性测试是两全其美的方法。在持续测试期间，我们只运行我们需要的测试，同时在一个查询资产中拥有选择项目和进行持续验证的所有逻辑。

### 33.5.4 任何角色的测试



为了对所有测试有一个良好的统一接口，我们决定让每个测试在作为条件和权重这两个角色中都有意义。例如，如果我们使用 “与敌人的距离” 作为条件，我们可以要求它小于或大于 2000 个单位。但如果我们将其用作权重，那么我们将其解释为偏好与敌人的较小或较大距离。我们通过设置测试的权重值来表达我们对测试属性的偏好程度。值越高，对给定属性的需求就越高。表 33.1 给出了更多示例。

## 33.6 核心



ETQ 算法的核心如清单 33.2 中的伪代码所示。

## 33.7 实现细节



在实现即使是最简单的算法时，也总是有一些小技巧可以使用。以下是我们实现的一些优化：



- 从较便宜的测试开始：我们根据预期性能手动对测试类型进行预排序。例如，距离测试比检查角色是否有标签更昂贵，但比检查点是否在导航网格上便宜。
- 快速失败：对于一些测试，可以提前失败，从而节省计算。例如，如果没有导航网格，检查点是否在导航网格上的测试将总是失败。如果测试需要在给定上下文中不存在的引用，例如小队队长或敌人，测试可以更快地失败。
- 归一化测试结果和权重：我们很快发现，试图对距离测试和 “具有属性” 类型的测试进行加权是一项不可能的任务。即使可以用已知的最大距离来做到，一旦我们改变最大值，它就会失效，并且需要重新调整。所以我们决定归一化所有测试结果。在执行测试时，我们存储最大结果值，一旦测试完成，我们用存储的最大值对所有结果进行归一化。在某些情况下，我们也会使用处理选项的项目生成范围。我们还确保权重始终在 [-1, 1] 范围内（通过编辑器），这与归一化结果一起为我们提供了一些良好的数学属性，并允许可靠的查询调整。
- 尽可能进行调试绘制：调试绘制的重要性再怎么强调也不为过。在开发这样的系统时，能够在运行时对任何你选择的目标触发任何查询，并查看结果是至关重要的。无数次我们通过调试绘制查询结果发现了其中的错误，这节省了大量时间。

## 33.8 编辑器



利用虚幻引擎 3 易于创建工具的优势，我们为 ETQ 创建了一个工具。使用这个工具使处理查询资产变得更加愉快。直接的结果是，我们更愿意处理查询、调整它们，并立即查看是否有设置错误的地方。图 33.1 显示了我们编辑器中的一个查询模板，以及选项和测试节点属性的示例。



该工具还提供了以下功能：



- 权重自动缩放：每当测试的权重被更改为 [-1, 1] 范围之外的值时，编辑器会按比例重新缩放给定查询选项中的所有权重，使它们再次符合实现部分中提到的范围。
- 自动排列视觉效果：一个查询被表示为树状结构。所有用于可视化测试的元素都以选项节点为头部排列在列中，以使每个查询无论由谁创建都具有统一的外观。这使得在别人的查询中更容易找到方向。
- 描述性标签：我们让查询资产中的每个测试节点为自己生成一个非程序员也能理解的描述字符串，并在编辑器中的可视化中显示出来。例如，我们有 “领导者到（条件）有直线路径” 或 “到上下文对象的距离，偏好更小（权重）” 这样的标签。这样，即使是未经训练的人也能大致通过查看查询来了解它将生成什么。
- 着色：这一点很明显，但我们将所有设置错误或缺少某些值的内容用黄色着色（与其他所有内容的深色形成对比）。这样，我们一眼就能立即知道给定查询哪里出了问题。

## 33.9 优缺点



ETQ 实现了许多良好的特性。一些例子包括：



- 直观的查询创建：使用我们创建的工具，设计师能够在最少的指导下构建查询。这个想法本身与人们表达这类查询的方式非常接近，即使技术水平较低的设计师也能轻松理解。
- 数据驱动：让数据控制代码的行为是游戏开发的圣杯。例如，程序员不再需要参与人工智能选择敌人或掩体方式的每一次改变。
- 高效：通过对我们的系统进行时间切片，并且设置查询使其不会生成大量的项目，我们能够将 ETQ 平均每帧压缩到 0.02 毫秒以下，同时仍然能够使用非常复杂的查询寻找具有指定属性的游戏实体。
- 灵活：添加新的测试或生成器非常容易，每当有人需要做当前测试或生成器无法提供的事情时，添加一个新的就很简单 —— 在运行时添加很容易且仍然高效（由于时间切片）。



ETQ 的主要问题是可能需要一些时间或经验来调整查询以获得期望的行为。另一方面，处理查询时的迭代非常快（我们也有一些运行时工具），没有经验的用户也能很快培养出所需的直觉。



ETQ 系统也用于《战争机器：审判》。在那个项目中，它出现了一些问题。一个主要问题是在某些情况下它会产生高达 15 毫秒的巨大 CPU 使用峰值。这是由于对大量项目执行昂贵的测试，因为我们对单个项目集的每个测试都是原子性的，并且没有对其进行时间切片。这些峰值是由于查询生成器从关卡放置的实体（在这种情况下是 “目标角色”）读取掩体收集范围，这个值是由关卡设计师设置的。这实际上是数据驱动系统固有的问题，需要注意确保设计师提供的数据不会影响系统性能。快速修复方法是将半径限制为基于经验的最大值。

## 33.10 需要修复和改进的地方



在《子弹风暴》发布的最后阶段，有一些改进我们未能实现。这些包括：



- 合并测试：某些测试往往会成组出现。例如，在查询掩体点时，与敌人的点积大于 X、与敌人的距离大于 Y 以及不是我当前的掩体通常会一起出现。直观地说，有一个能同时做这三件事的特殊测试比依次执行三个单独的测试更有意义。
- 最终测试：通常，即使有大量的过滤器也无法充分减少要测试的项目总数。当系统进行到昂贵的测试时，有太多的项目需要处理，性能很差。最终测试的想法是选择通过该测试的前 N 个所需项目，并停止测试其余项目。最终测试将是最后处理的测试，这样我们可以在不计算所有项目的昂贵测试的情况下获得足够好的结果。
- 反向处理：[Robert 11] 提出了一种快速选择比我们的人工智能当前使用的更好的掩体的方案。同样的方法也可以添加到 ETQ 中。因此，我们可以不进行常规的查询处理，而是先对人工智能的当前掩体点进行评分，然后接受第一个通过查询所有过滤器且得分更高的项目。
- 多生成器：允许一个查询模板使用多个生成器，以便能够对不同项目的集合进行统一测试（例如，一次处理常规点和掩体点）。
- 多线程实现：当时没有必要也没有 CPU 资源在单独的线程中运行 ETQ，但随着 CPU 核心数量的增加，这是一个有前途的未来方向。

## 33.11 结论



尽管所描述的系统设计非常简单，但它被证明是非常强大的。我们在不占用大量 CPU 时间的情况下获得了强大的环境查询能力。通过数据驱动 ETQ，并使用我们的专用创作工具创建查询，使得对人工智能选择敌人或掩体的方式进行快速迭代成为可能，并且通过运行时调试工具进一步增强了这种能力。



还有一个更高层次的收获。从一开始我们就从异步服务的角度考虑 ETQ，这也帮助我们使人工智能系统的其他组件也实现异步。设计和实现异步人工智能需要一种略有不同的思维方式，但它会产生在多核上可良好扩展的解决方案，这是未来几年的一个要求。