# 五杠四、一个简单且健壮的知识表示系统



作者：Phil Carlisle

## 34.1 引言



知识有多种形式，而知识的表示方式会对任何游戏 AI 的效率和开发时间产生重大影响。对于涉及复杂角色的游戏来说，所选的表示方式尤为重要。本章描述了为游戏《永恒天空》创建的一个系统，这是一款面向 PC 和平板设备的独立第一人称探索游戏。



该游戏的目标是突破伙伴式 AI 的界限，让一群角色始终陪伴在玩家身边。这就要求每个角色对世界有深入的了解，并且能够对游戏中的事件、其他角色和物体表现出复杂的态度。所需知识的复杂性导致在数据表示设计上进行了多次迭代，最终形成了一个在灵活性和迭代速度方面优先于内存和 CPU 使用原始效率的系统。

## 34.2 设计要求



在开始之前，我们注意到延长角色的寿命也会增加对支持角色行为的知识的要求。我们专注于需要复杂知识表示的长期伙伴。通常情况下，电子游戏中的非玩家角色寿命相对较短，因此不需要任何形式的复杂知识表示。



话虽如此，该系统的指导设计原则如下：



- 最小化迭代时间（有时可能会牺牲执行速度，我们可以稍后进行优化）。
- 用内存换取效率（作为一款基于 PC 的游戏，内存不是那么受限）。
- 易于与脚本集成。
- 与面向组件的架构灵活协作（稍后会详细介绍）。
- 允许不同类型的知识并且在结构上具有灵活性。



如果我们将逻辑视为简单的 “如果（条件）则执行动作” 子句集合，那么我们必须考虑该子句的条件部分实际意味着什么。为了获得任何形式的复杂行为，任何逻辑子句的条件部分必须包含任意数量的条件，条件的复杂性通常与行为的复杂性成正比。对于从事游戏人工智能工作的人来说，关键的认识是这些条件在很大程度上依赖于知识，并且知识表示可能构成任何复杂行为要求的很大一部分。



《永恒天空》的知识表示在知识的基本结构上经历了多次迭代。第一次迭代涉及一个简单的黑板架构，其中包含一些用于在黑板上添加和检索信息的 get 和 set 函数，脚本也可以使用这些函数。很快就发现，对于具有复杂行为和高预期寿命的角色来说，这不是一种结构良好的知识表示方法。问题在于为每种类型的信息都设置 get 和 set 方法是不可能的。向黑板代码中添加一种新类型的知识所需的时间太长，增加了迭代时间。是时候回去重新思考这个问题了。



我们应该将什么视为知识表示系统的基础呢？



知识通常由以下元素组成：



- 实体属性（位置、速度）
- 存在性
- 分类或类型
- 集合成员关系
- 关系 / 态度
- 对他人的了解
- 语义知识
- 事件知识



让我们更详细地研究这些类型的知识：

### 34.2.1 实体属性



实体属性只是与特定实体相关的数据。它可以是位置、速度、名称、朝向、当前动画等。每个特定角色感知到的实体（稍后会详细介绍）都需要与该实体的有用属性一起存储。这些信息存储在一个实体数组中，这是一个给定角色所知道的所有实体的动态数组。

### 34.2.2 存在性



存在性的概念非常重要，因为通常我们可以通过只考虑角色知道的对象或对象集来提高效率。例如，在战斗中选择合适的敌人作为目标所需的条件逻辑，在考虑哪个敌人最理想之前，需要知道敌人存在。在很多方面，将某物的存在作为主要条件，然后只有在主要条件为真时才深入研究次要条件是很有用的。所以在典型情况下，你可能会看到一个 `is_enemy_seen()` 方法，如果一个敌人被非玩家角色看到，它会返回 `true`，然后这个结果会被用于其他条件，比如从看到的敌人列表中进行选择。这种 “存在” 的概念可以很容易地通过任何特定集合成员的数量来表示，例如，非零值表示敌人集合中存在敌人。

### 34.2.3 分类



在这个例子中，“敌人” 的概念很有趣。我们所说的 “敌人” 是指特定实体属于一组实体，这组实体能从我们的逻辑中引发与该特定分类相关的特定反应。但是仅仅将实体分类为单一类型就足够了吗？想象一下罗密欧与朱丽叶的情况。他们都可以被归类为蒙太古或凯普莱特家族，也可以被归类为男性和女性，还可以都被归类为人类，或者都被归类为恋人。问题是任何给定的实体可能根据上下文属于多个分类。罗密欧可以同时被归类为男性、人类、蒙太古和恋人。如果分类数量相对较少，那么可以使用简单的位标志表示和二进制逻辑来表示它们，但通常更倾向于采用更灵活的方法。

### 34.2.4 集合成员关系



集合可以表示为成员 ID 的简单动态数组。如果我们允许任意数量的集合，每个集合包含任意数量的成员，并且有一种命名集合和查找成员的方法，那么我们就可以处理任意数量的不同分类。

### 34.2.5 关系



关系是集合成员关系的一个稍微复杂的版本。在关系中，我们有成员关系，以及集合中每个成员或整个集合的正值或负值。再次考虑罗密欧与朱丽叶的关系。在这种情况下，蒙太古和凯普莱特家族之间存在总体关系（这意味着罗密欧和朱丽叶是这些集合的成员），但这两个集合之间存在总体负面关系值。



但在罗密欧和朱丽叶自身的具体情况下，他们也有积极的关系，这意味着另一种集合成员关系，其中成员是这对恋人。最终，选择的关系表示方式很简单。每个成员集合表示为一个命名的成员动态数组，成员使用其 ID 值存储。每个实体在一个动态数组中存储它所属的每个集合的名称，这个动态数组基本上形成了一个从最具体到最不具体的成员层次结构。所以第一个元素可能是 “恋人” 集合的成员关系，下一个可能是 “蒙太古”，最后一个集合可能是 “人类”。



每个成员集合也有一个价态值，可以是正的或负的，以表示与该集合的正或负关联。这种扁平化层次结构的原因是，当考虑一种行为时，我们通常希望首先考虑更具体的行为，然后是更普遍的行为。如果我们以这种方式存储集合成员关系，我们只需从左到右读取数组，并根据适当情况考虑每个集合成员关系的行为。例如，如果我们发现自己在 “恋人” 集合中，我们可能会选择表达爱意。然而，如果我们不是这个集合的成员，那么我们可能是 “蒙太古” 的成员，随后选择表现出支配地位，最后的 “人类” 作为默认情况，当没有其他成员关系可用时使用。

### 34.2.6 态度



态度使用与关系完全相同的结构来处理（在这个意义上，态度只是与简单对象或事件的关系，而不是与角色的关系）。

### 34.2.7 对他人的了解



如果我们为伙伴创建行为，我们需要他们看起来好像也有周围人所知道的模型。在这种情况下，我们可以为每个实体简单地存储一组 “伙伴”，然后在需要时通过查找查询他们的知识。

### 34.2.8 语义知识



也许知识表示中最棘手的问题是语义知识的概念。假设我们有一个喜欢水果的角色；当我们在探索时，遇到一个我们以前从未遇到过的物体。它看起来像这个角色熟悉的一种水果，所以这个角色决定尝试吃它。问题是，是什么让这个角色决定尝试吃它呢？是这种新物体 “像” 水果的语义知识。



像 “像” 和 “是” 这样的术语是有趣的概念。土豆不是水果，但它是可食用的。它与 “食物” 概念有 “是” 的关系，就像水果与食物概念有 “是” 的关系一样。为了允许这种推断，我们需要考虑表示语义知识。我们注意到经验表明，绝大多数游戏 AI 行为不需要这样的语义知识；因此，我们将尝试这种语义知识留作读者的练习。

### 34.2.9 事件



这些是与角色相关的任何事件的记录；它们可能是诸如 “刚刚听到手榴弹落地” 到 “刚刚看到罗密欧亲吻朱丽叶” 之类的事件。事件知识对于需要立即关注的事物的快速反应很有用，并且它们也可用作影响情绪等方面的汇总统计数据。例如，它们可以用于改变表示战斗疲劳的值或改变随时间汇总战斗经验的值。



总之，我们需要一个系统，它允许在任意数据结构中存储任意信息，同时能够高效地检索和查询，并且还允许从脚本和决策逻辑的条件语句中自动访问知识表示。

## 34.3 实现



在《永恒天空》中，每个实体都由一个唯一的实例整数值表示，这允许通过将实体 ID 用作哈希表中的哈希值来快速查找实体。实体本身使用 `GameObject` 类表示，这是一个简单的容器，包含从 `GameComponent` 派生的类的扁平列表。有关基于组件的架构的更多信息，参考 Jason Gregory 的优秀著作《游戏引擎架构》[Gregory 09] 可能会有所帮助，但一般来说，你可以将组件视为处理特定功能的狭窄范围的类。



基于组件的架构的优点是，你可以通过简单地添加或删除组件来组合实体，并获得截然不同的行为。游戏中的所有实体在运行时都是从一个命名的 XML 模板组成的，该模板描述了实体的所有组件。关卡在另一个 XML 文件中描述，其中包含游戏中每个实体的实体模板名称、唯一 ID 和其他相关属性。



参考第一本《AI 游戏编程智慧》中关于黑板的章节 [Isla 和 Blumberg 02] 可能会有所帮助。一般来说，黑板是一个带有相应访问方法的简单数据存储库。最初，在设计《永恒天空》的知识表示时，使用了一个简单的黑板，其中包含一些命名整数、浮点数和 ID 值的列表，以及用于从每个列表检索信息的成员函数。此外，它还有一些浮点和整数值，用于表示诸如情绪状态和拥有物品的数量等知识。这种方法的缺点是，每一条新信息都必须有一些设置和获取该信息的方法添加到黑板类中，同时还要定义脚本访问的接口等。最终发现这过于复杂，对于游戏玩法原型设计来说不是特别有用。最终，决定使用变体类型数据，它允许存储任意数据，同时也简化了本地代码和脚本代码的接口。实际上，在性能和可访问性之间总是存在权衡，使用变体数据类型被认为是一个合理的折衷方案。



在本章描述并可在本书网站（[http://www.gameaipro.com](http://www.gameaipro.com/)）上获取的知识表示系统中，你会发现一个基于黑板概念的系统。然而，它已经被修改为看起来非常类似于基于属性的系统，因为它以变体格式存储任意命名的数据，允许按名称查询数据，同时也可以以合理的转换以任何合适的格式检索数据。数据本身存储在变体中，变体有一个名称字符串和一个名义上的 “类型”，以及转换为其他常见类型的方法。实际上，这意味着大多数数据以原生类型存储，无需转换，但具有将字符串传递给脚本等常见转换非常简单的优点。



虽然这个系统不如简单的整数或浮点数列表高效，但在易用性和访问自动化方面是高效的；这种权衡对于一个旨在随着行为设计适应游戏玩法要求而变化的系统来说是合适的。这种方法的主要注意事项是，并不总是能够从一种类型的数据转换为另一种类型的数据。例如，不可能从任意字符串转换为数字格式。《永恒天空》处理不匹配数据类型访问的方式是使用 POCO 类库的异常处理例程；然而，在非原型游戏环境或已发布的游戏中，简单地断言数据访问并修复错误访问或存储数据的代码会更有意义。



因为这是一个独立项目，并且我们通常支持开源代码，所以实现是使用 POCO C++ 类库 [Applied Informatics 12] 提供的开源变体实现构建的。特别是变体类型 `poco::dynamicany` 允许存储无类型的变体数据，就像动态类型语言允许变量存储一样。



示例代码中使用的变体系统在三个方面进行了扩展。首先，我们添加了变体类型的层次结构。这意味着每个变体可以存储单个值或其他变体的动态数组，这使得任何单个数据访问都能够访问单个值和作为访问一部分的完整层次结构之间的任何内容。其次，我们为变体添加了一个 “名称” 属性，以便可以按名称查询变体，这对于脚本访问很有用。最后，我们添加了一个方法来描述变体数据的过期值。这个过期值为零表示数据不会过期，或者任何非零值，在黑板更新期间会递减。变体系统要求任何变体数据访问通过模板参数指定返回的数据类型。变体数据通过黑板类进行存储和访问。

## 34.4 执行



在《永恒天空》中，一个 AI 组件在其中存储一个黑板实例，并且还允许访问其他 “命名” 黑板。AI 组件还存储一个行为树实例，在 AI 组件更新期间会调用其 `Execute` 方法。这个执行方法会传递一个指向 AI 组件的指针以及经过的时间。当行为树执行时，它可以通过 AI 组件接口访问黑板，以及添加 AI 组件要执行的动作。通过这种方式，行为树类的决策逻辑与 AI 组件的动作执行逻辑是分离的。



在 AI 组件更新期间，黑板本身会随着经过的时间进行更新，这允许清理黑板数据，因为过期数据可以从数据集中删除。这种过期处理只是对实体列表进行循环。非零值会减去经过的时间，任何导致零或负值的值都被视为已过期并从列表中删除。请注意，这个过期系统允许任何单个数据在聚合级别过期，例如单个实体及其所有属性的情况，或者在实体的特定特征（如位置或速度）的属性级别过期。在这次更新期间，另一个方法允许使用评估类聚合新的事件数据。这个类是特定于游戏的，允许聚合事件和其他通常用于实现角色情感和情绪等功能的知识。

## 34.5 感知



数据可以在实体构建期间通过 XML 文件引用添加到黑板中，也可以在游戏更新循环中通过感知系统添加。当每个实体被感知时，它会与一些常见属性（如位置、方向、速度等）一起添加到黑板中。如果一个实体被感知且已经在黑板中，如果合适的话，该实体的变体将用新的过期时间以及任何可能已更改的新属性进行更新。

## 34.6 处理事件



事件在从称为 `MessageManager` 的中央事件处理系统接收时被添加，并被解析为变体结构，以便使用 `AddEventMemory` 成员函数添加到黑板类的 `Events` 变体数组中。

## 34.7 访问知识



可以通过命名元素或索引值（如果存储了变体数组）来访问各种知识表示。通常，访问形式如下：
`<type> variable = blackboard<type>[elementname];`
其中 `<type>` 是任何支持的数据类型，`elementname` 是给元素指定的字符串名称。



对于已知存储其他变体数组的变体，可以使用整数索引代替 `elementname`。布尔成员函数 `IsArray()` 可用于确定变体存储中是否存储了数组。无符号整数成员函数 `Count()` 返回数组中的元素数量。



建议读者参考源代码中可用的各种条件节点，以获取访问各种变体数据类型的示例。

## 34.8 调试、脚本和序列化



变体方法的主要优点之一是将数据暴露给其他系统变得很简单。每个变体都知道如何将自身序列化为任何给定的数据流，无论是用于调试、日志记录还是实体序列化。所以这个过程是一个递归过程，你只需在最顶层的变体上调用一个函数，并让它自动序列化自身及其子层次结构。因为每个变体都有一个名称，所以在流中直观地理解每个值代表什么相对容易。例如，在《永恒天空》中，这个功能用于将黑板序列化为 JSON 格式，以便在通过嵌入式网络服务器访问的网络浏览器中显示。脚本接口也同样简化了，因为可以编写一个简单的函数，通过使用变体名称进行字符串转换，将给定的命名变体暴露给脚本引擎以允许访问。存储数组的变体类型在支持它们的脚本语言（如 LUA）中通常表示为表。

## 34.9 结论



在开发游戏行为时，减少实现任何单个行为所需的迭代时间至关重要。所描述的知识表示系统基于黑板的概念，并添加了一种更动态的数据表示形式，更易于应对不断变化的要求。虽然这允许灵活的数据表示，但在性能方面确实存在一些可能在最终发布产品中不理想的权衡。值得指出的是，这个系统具有动态类型语言的许多优点和缺点。解决这些缺点的一个好方法是在知道最终行为实现需要什么之后优化表示，并在确定之后允许特定类型的数据访问。

虽然我们没有探索语义知识的使用，但这也许是《永恒天空》构建完全自适应和可信角色所需的最后一个开发领域。考虑语义知识在自己的游戏中的用途留作读者的练习。