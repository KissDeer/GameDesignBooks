# 四杠一、战术位置选择：架构与查询语言
**马修·杰克**

## 26.1 引言
在任何游戏中，智能体的移动都是AI最明显的方面，对于射击游戏来说尤其如此。在位置之间进行选择，以及首先生成要考虑的这些位置，对于这些游戏的成功至关重要。这不仅是智能体在战斗中有效性的关键，而且还能明显地传达它在战斗中的角色和状态。更广泛地说，在游戏中，智能体的移动有助于定义它的个性，并且通常是核心游戏玩法的重要组成部分。

在本文中，我们描述了一种选择移动位置的完整架构，作为复杂AI行为的一部分。我们概述了指定这些位置的查询语言，考虑了位置选择如何与我们的行为集成，并提供了一些具体的构建块和最佳实践，使我们能够快速开发查询并达到最佳效果。性能受到特别关注，以确保我们的结果能够进入最终游戏，并允许我们使用更强大的查询标准。我们还讨论了处理群体移动行为的技术和有效开发所需的工具。

为《孤岛危机2》和其他即将推出的游戏中使用的CryEngine组件——战术位置选择（TPS）系统开发的技术，构成了本章的核心[Crytek 11]。我们还补充了其他游戏中看到的一些方法，以及未来工作的有前途的方向。

## 26.2 动机
任何用于选择移动位置的系统都面临来自多方面的设计压力。它必须灵活且具有表现力，因为它将定义我们的智能体可能的移动。它必须能够快速、迭代地开发，并且必须包括强大的工具，因为这些将限制我们最终行为的质量。最后，由于它经常被使用并且需要对玩家做出反应，它必须是一个快速高效的主力，在几帧内提供结果，同时始终保持在CPU预算内。

战术位置选择的核心问题归结为设计师在使用您的行为时会问您的问题：“他为什么移动到这里，而常识是他应该移动到那里？”这是您在测试AI时应该问自己的问题，因为这也是玩家会问自己的问题。

对这种“常识”进行建模是使这个问题如此棘手的原因。事实上，许多射击游戏决定使用触发器和脚本来编排AI的移动，让设计师在每种情况下提供人类的判断 - 这可能非常有效。然而，这是一个耗时的过程，不适合所有开发周期，本质上仅限于线性游戏玩法，并且不适合开放的沙盒游戏。

通过正确的抽象和高效的处理，我们可以描述我们的智能体在其将遇到的一系列上下文中的人类直觉，并在规范和即兴创作之间取得强大的平衡。在此过程中，我们大大加快了行为原型设计和开发的速度，并获得了一个适用于广泛游戏玩法应用的多功能工具。

## 26.3 基础
这类系统的核心通常采用基于效用的方法[Mark 09, Graham 13]，根据特定智能体的需求评估一组点的适合度，以确定最佳候选点。这些点的来源将在“生成”部分讨论，但它们可能由设计师放置、自动生成，或两者的组合。通常，我们会在开始评估之前收集或生成智能体当前位置指定半径内的点。

评估将首先根据威胁的最小距离和提供掩护的方向等标准过滤掉不合适的点。然后，它将根据可取性标准对剩余点进行评分，例如它们与目标点的接近程度或它们暴露于多个威胁的程度。

然后，我们选择得分最高的有效点作为结果，并将其用作我们智能体的移动目标。通过以不同方式组合各种标准并权衡它们对得分的影响，我们可以为不同的智能体类型、环境和行为生成有效的查询。我们还可以将同一系统用于其他应用，例如射击目标或生成位置。战术位置选择的良好示例在以前的工作中已经给出[Sterren 01, Straatman et al. 06]，并且在本书中也有[Zielinski 13]。

## 26.4 架构
我们的战术位置选择系统由多个子系统组成，并且还必须与AI框架的其余部分集成。图26.1显示了架构的总体结构。

### 26.4.1 查询规范语言
表达常识性的空间推理不是C ++或任何常见脚本语言的设计目的。领域特定语言（DSL）的案例在游戏开发者大会上已经得到了有力的论证[Evans 11]，在这里，一种强大的表达手段使我们能够专注于内在问题并实现快速迭代。成功的位置选择查询语言的关键属性是：
- **抽象**：如果我们能够以新的方式重新应用现有的标准（关键字），我们将获得很大的力量。
- **可读性**：开发人员应该尽可能容易地理解查询的意图。
- **可扩展性**：应该很容易向语言添加新的标准。
- **效率**：语言本身不应给评估过程增加开销。

许多DSL是在现有语言的基础上构建的。在Crytek开发战术位置选择的查询语言时，我们利用Lua表提供基本结构，但随后将内容解析为类似字节码的格式，以便系统在运行时不使用Lua。以下是该语法的一个简单示例。

清单26.1显示了一个由两个子查询组成的查询，称为“选项”。第一个选项是首选，但如果失败，将按照指定的顺序尝试后续选项，然后报告失败。在这个例子中，第一个选项将收集针对当前攻击目标有效的隐藏点，距离智能体15米以内，丢弃距离智能体小于5米的任何点，并丢弃任何比智能体本身更接近攻击目标的点。在剩余的点中，它将更喜欢任何硬掩护而不是软掩护，并更喜欢最近的点。第二个选项（后备）生成一个网格点，以远离或横向移动远离目标，并更喜欢阻挡视线的点。两个选项都有一个目标，即移动到一个新的、安全的位置，距离至少为5米。因此，这个查询可能用于响应手榴弹落在智能体脚下的情况。

每个选项的“生成”部分指定了我们候选点的来源。“条件”部分包含在评估过程中应该应用的过滤器，只有当所有条件都通过时，一个点才是有效的。“权重”部分告诉AI如何对这些有效点的适合度进行评分。

这些部分中的每一行都是一个Lua表条目，由一个字符串和一个值组成。在我们的DSL语法中，字符串由一系列由下划线连接的关键字组成，在解析时可以轻松地解析回关键字本身。通常，最重要的关键字排在第一位 - 例如，hidespots或distance - 并指定我们要应用的评估或生成方法。这可以称为标准。

标准通常采用一个对象，这允许以不同的方式应用相同的方法。例如，我们没有使用distanceFromTarget这样的关键字，而是允许使用相同的关键字与许多不同的对象，如puppet（请求智能体）、referencePoint（通用位置）、player（在单人游戏环境中）、leader等，特别是target（如果有攻击目标，则为我们正在攻击的智能体）。对象是将一组参数转换为多功能查询语言的关键。一些标准不接受任何对象 - 例如，softCover，它只是该点的一个属性。

min和max关键字可以前缀一个标准字符串，如distance，表示浮点值。这会改变标准的应用方式和使用位置。如果没有min或max关键字，它将简单地作为权重应用，但使用这些关键字，我们会根据实际值是否高于或低于指定限制产生一个布尔结果。这允许我们根据需要在“权重”或“条件”部分使用相同的标准。例如，在上面的示例中，min_distance_from_puppet = 5用于指定点必须距离请求智能体至少5米。

还有一组“粘合”关键字，如from、to、at和the，它们必须放在标准和其对象之间，只是为了产生更具人类可读性的句子 - 如distance_from_puppet。用户可以自由选择在每种情况下形成最自然表达的单词；在解析过程中，粘合词将被简单地丢弃。

每个关键字都使用类型标记进行注册，以确定它可以在哪里使用。这允许我们在解析过程中检测并拒绝无效查询，并提供有用的调试输出。

虽然Lua在Crytek代码库中是最自然的选择，但JSON、XML或简单的自定义格式也可以是这种语言的合理载体。当然，查询可以在游戏运行时更改，在这种情况下，可以通过编辑和重新加载相应的脚本文件来实现。在Unreal 3下，使用Kismet风格的图形界面实现了类似的语言[Zielinski 13]。

Crytek TPS系统的文档可以在网上找到[Crytek 11]，并且可以在CryEngine Free SDK中使用[Crytek 12]。如果您尝试本文中的任何查询，请注意，常见的关键字target在这里被缩短了；正确的关键字是attentionTarget。

### 26.4.2 上下文和查询库
正如我们在“动机”部分中讨论的那样，我们的智能体面临着一个复杂和动态的世界，玩家期望智能体始终做出与他们自己相似的判断。在我们游戏的各种环境中实现可信的、反应性的移动行为的一种方法是构建一个非常复杂的“超级查询”。然而，如果我们将其分解为小块，每个小块由我们希望在特定环境（如茂密的森林或后末日的纽约街道）中执行的特定行为（如侧翼、撤退或提供掩护火力）组成，那么问题就会变得更容易处理。我们将行为和环境的每一种组合称为一个上下文，并可以形成这样的查询库。

如果我们对环境做出假设，就更容易准确地描述移动的位置。例如，虽然我们可以调整查询，直到它允许我们在茂密的森林中在树木之间以及在城市街道上的汽车之间有效地前进，但如果我们分别考虑它们，那么我们的单独查询就会变得简单得多。实际上，有了合适的标准，查询构建对开发人员来说就变得非常可预测，并且通过一些思考，我们可以在不花费大量时间调整查询的情况下获得良好的结果。我们将在“最佳实践和特定标准”部分进一步讨论这个问题。

### 26.4.3 与行为选择集成
为了利用特定于上下文的查询库 - 行为和环境的组合 - 我们必须能够在任何给定时间选择合适的上下文。这可以通过将每个行为视为具有核心移动查询并将当前环境类型作为我们行为选择框架的一部分来实现。这与“第一代”行为树很好地映射，例如Crytek使用的行为树[Martins 11]，基本上由一个决策树组成，行为作为叶子；不同的环境可以形成树的分支。或者，相同的行为在不同的环境中可能使用不同的查询；哪种方式最好将取决于环境之间共享的行为有多少。在People Can Fly的FPS游戏《子弹风暴》中，使用了类似的系统，并使用了更复杂的行为树[Zielinksi 13]，也可以使用其他架构来实现。

我们当前环境的基本知识可以基于简单的高级线索，例如每个级别的设置、设计师体积或触发器。然而，行为选择框架也可以接收我们运行的查询的反馈，并使用它来指导行为的选择，并对我们的环境做出反应性的通知。这种反馈采取失败查询的形式 - 返回无有效结果的查询 - 这可能由于几种不同的原因发生。

一种失败可能发生的方式是，我们为常见情况设计了查询，但这是一个不寻常的例子。例如，我们的行为和因此我们的查询可能是为茂密的森林设计的，但障碍物或路径可能意味着当地区域的树木很少。这可能是一个级别设计问题，但我们可以选择为这种情况提供一个后备 - 查询中的第二个“选项”。

后备通常会放松过滤器和/或扩展查询半径，特别是如果我们使用较小的半径仅仅是出于性能原因。它也可能使用不同的生成标准：也许在我们周围生成一些没有掩护的点，并寻找至少一个阻挡了我们对目标视线的点。后备基本上隐藏了行为选择的失败，并在这种情况下降低了我们的质量标准，以使我们顺利度过这个棘手的点。

然而，还有一种更具信息性的情况：我们的上下文与我们的想法不同，我们正在尝试做的事情对于这种情况是错误的。如果我们正确设计了查询，它不仅会按偏好顺序对所有点进行排名，而且还会消除所有不合适的点。例如，如果我们在森林中围绕目标向左侧翼，失败表明我们的左侧没有合适的位置 - 我们已经用完了掩护或我们的道路被阻挡。我们可以承认这一点 - 例如，通过在我们的黑板上标记这个状态 - 以便选择不同的行为，或者在小队环境中，通知盟友一个小组行动可能必须中止。在Crytek系统中，查询规范可以包括在失败时发送的特定信号或设置的黑板状态。

### 26.4.4 形成输入点数据库
大多数游戏将形成一个用于考虑的隐藏点的静态数据库，这些构成了评估候选点的主要来源。这些可能是由设计师放置的 - 例如，《孤岛惊魂》和《孤岛危机》中定向的“隐藏锚点”，它指示了点的位置以及提供掩护的方向锥。它们可以自动嵌入某些对象中，例如树木；手动嵌入静态或动态对象中，例如车辆；或在复杂对象周围自动生成。所有这些都在Crytek的游戏中结合使用 - 《孤岛危机2》引入了基于设计师提示的自动生成[Martins 11]。值得注意的是，《杀戮地带3》使用自动过程预先生成了它的隐藏点[Mononen 11]，而《边缘战士》没有这样的静态数据库，完全依赖于动态生成的点[Nelson 11]。

一般来说，这样的数据库允许更多的时间用于离线处理或设计师工作，并为TPS系统提供了可靠点的廉价资源作为输入。当然，数据库可以包含除了（或代替）隐藏位置之外的其他类型的位置。表示瓶颈点、门口、狙击点、有利位置、重生点等的位置也可以用作候选点，使用特定的标准来生成特定类型或区分它们。这代表了设计师对环境的丰富提示。

### 26.4.5 收集和生成
评估任何查询的第一步是形成一组候选点，无论是从数据库中收集还是在运行时生成。通常，我们的主要来源是从上面描述的静态数据库中收集它们，使用我们示例中的标准：
Generation = {hidespots_from_target_around_puppet = 15}
这将从目标中找到隐藏点，并说明了此阶段的三个关键参数：查询的中心 - 这里是puppet对象，即智能体本身；收集/生成的半径 - 15米；以及一个对象，对于这个标准，它代表我们希望隐藏的主要目标 - 在这种情况下，是target对象。

高效查询的最佳基础是在我们实际感兴趣的特定位置或位置生成点，并在尽可能小的距离内；中心和半径的选择应考虑到这一点。以请求智能体为中心并不总是最佳选择：例如，当进入近距离战斗时，我们可能会以我们的目标或小队的中心为中心（我们将在“群体技术”部分讨论）。设计师控制的一种常见技术是将智能体的移动限制在一个区域内 - 例如，防御、巡逻或前进。我们可以根据相关的点或多边形为其提供生成标准，而不是依赖于条件。

如果我们提供一个主要的隐藏目标（在这种情况下是target，当前的攻击目标），这将启用一系列强大而高效的生成标准。在《孤岛惊魂》和《孤岛危机》中，通过在隐藏目标的对面生成隐藏点，很好地处理了树木周围的隐藏点。这些全方位的隐藏点也很有用，因为它们会在每次隐藏请求时刷新，随着隐藏目标的移动，智能体可以在障碍物周围移动。隐藏目标还允许我们有效地使用定向隐藏点 - 使用点积测试立即拒绝对于此隐藏目标方向不正确的掩护点。

除了从我们的数据库中收集，我们还可以根据需要生成点 - 例如，正如我们在上面查询的后备选项中所做的那样：
Generation = {grid_around_puppet = 10}
在这种情况下，我们在智能体周围的10米见方的网格中生成候选位置。然后，可以分析这些任意点作为掩护或其他属性的潜力。例如，如果附近没有明确的掩护，我们可能仍然试图阻挡对我们目标的视线；我们可能只是想逃避压倒性的威胁，例如手榴弹，或者具体地移动到开阔地带。

《边缘战士》通过同心圆生成点来动态找到所有的掩护[Nelson 11]。我们可以使用类似以下的查询来模拟类似的情况（这将找到距离智能体最近的阻挡对目标视线的点）：
Generation = {circles_around_puppet = 10}, Conditions = {visible_from_target = false},
Weights = {distance_from_puppet = -1.0},
《孤岛危机2》中使用的掩护轨道是一个相对较新的发展，它避免将掩护表示为离散点，而是存储一条路径，智能体可以在任何地方沿着该路径进行掩护或在掩护中移动。根据需要，我们在轨道上生成位置用于战术位置选择。例如，这允许我们在轨道上生成至少一个最接近智能体的位置，或者使用轨道上与其他智能体的最佳间距生成位置。

鉴于这些不同类型点的好处，这个阶段的作用是从所有这些可能的来源收集或生成相关的候选点，并以统一的方式将它们呈现给过程的其余部分。虽然明确的隐藏点可能带有诸如高或低掩护、掩护质量或方向等标志的属性，但网格点将没有这些属性，但理想情况下，我们仍然能够在我们的条件和权重中以相同的方式对待它们。

### 26.4.6 过滤器
过滤器（或条件）是检查点有效性的标准，然后可能会拒绝它。我们可以认为它们在逻辑上形成了过程的第二阶段，但实际上，出于性能原因，将它们与权重交错可能是有意义的（我们将在“性能”部分讨论）。

过滤器可能只是一个点的属性，例如它是否提供高或低掩护、软掩护或硬掩护。它们也可能涉及对某个对象或位置的某种评估，例如光线投射，以检查从相关的射击姿势我们是否能够射击我们的目标。我们可以要求这些标准为真或假
例如，找到从目标可见的点或找到不可见的点可能是有用的。
当点从多个来源生成时，某些过滤器可能对某些点没有意义。例如，条件 providesHighCover 只是查找收集的隐藏点中的布尔标志，而在开放空间中生成的点根本没有直接掩护的概念。Crytek 系统通过让标准返回最直观意义上的值来处理这种情况 - 例如，非掩护点对于 providesHighCover 返回 false - 但系统也可以结构为跳过与给定点无关的标准。
26.4.7 权重
权重是对点的得分有贡献的标准。在大多数这样的系统中，评估本身返回的值乘以用户定义的权重，允许平衡贡献与其他权重。在 Crytek 系统中，所有此类标准返回的值首先归一化为 0 - 1 范围，这使得平衡更加直观。我们乘以这些值的用户指定权重可以在任何范围内，可以是正的或负的。结果求和，最佳点是得分最高或最不负的点。
最常见的是，返回连续值的标准，例如表示距离的标准，将用作权重，但布尔标准也可以使用，只返回 0 或 1。这允许我们以易于平衡的方式为点提供固定的优势或劣势，例如基于高或低掩护。
许多权重基于距离，在这里，将其限制在已知的范围内对于轻松指定查询非常重要。如果我们简单地返回从目标点或最近的敌人的原始距离，那么最大值是未知的，虽然我们可能会针对常见情况（例如 0 - 20 米）进行调整，但当出现不太常见的情况时，我们的分数可能会非常不平衡。我们可以通过为我们的游戏选择合适的最大有用范围（例如 30 米）并将其限制在该范围内来避免这个问题，将该范围内的所有距离标准归一化。这意味着我们可以在选择乘数并将其与查询中其他权重的预期效果进行比较时，自信地预测值的范围。
为了实现这一点，每个返回连续值的标准都声明了其输出的限制，因此当用作权重时，所有这些标准的输出都归一化为 [0 - 1] 范围。这也有助于我们在 “性能” 部分中讨论的一些优化。当 min 或 max 应用于使其成为条件时，我们不应用这些限制；相反，我们使用原始的、未归一化的值。
26.4.8 返回结果
我们已经考虑了我们的上下文并选择了相关的查询，为该查询生成了适当的候选点，应用条件将它们过滤到可接受的点，并评估它们的权重以对它们的适合度进行评分。现在我们可以获取最佳点并将它们作为查询的结果返回。
在理想情况下，我们只对一个点感兴趣：我们的智能体现在将移动到的点。然而，有充分的理由返回多个结果，例如有助于解决隐藏点竞争问题，我们将在后面讨论。一般来说，我们不需要为后续系统返回一组点来选择；如果我们的 API 或查询语言足够灵活，我们应该能够在我们的系统内完成。此外，返回的每个点都迫使我们完全评估其标准，并失去我们将在 “性能” 部分中讨论的潜在优化。
我们可以通过返回不仅仅是位置向量来扩大系统的适用性。例如，我们可以返回点的类型（即，掩护点、在开放空间中生成的点等）以及任何特定类型的元数据。如果该点是来自数据库的隐藏点，我们可以指定此点并给出其唯一 ID，在标记隐藏点被占用时非常有用。在 Crytek 系统中，可以在特定类型的所有实体的位置生成点，并且我们返回原始实体 ID。将结果视为世界中的对象，而不仅仅是点，允许我们考虑将该架构重用于许多其他 AI 和游戏玩法应用：从选择向我们的哪个小队成员发出协助信号，到在目标选择中对对手进行优先级排序，再到找到附近的对象进行交互。
26.5 最佳实践和特定标准
为了从您的战术定位系统中获得出色的结果，您不仅需要一个良好的架构，还需要适合手头任务的强大标准，并且需要有效地使用这些标准。在这里，我们讨论一些在 Crytek 或其他地方的游戏开发中已被证明有效的标准和方法。
26.5.1 权重和平衡
可以通过使用大量权重并调整和优化它们，直到获得所需的结果来构建查询。然而，通过更喜欢将标准用作条件而不是权重，利用后备选项，并进一步分解我们的查询以使其更特定于上下文，可以实现更快速和稳健的开发。
例如：当我们想要向左侧翼时，不要根据 “左侧性” 对所有点进行加权，而是使任何不在当前位置左侧的点无效；而不是在硬 / 软掩护和距离之间进行权衡调整，而是编写一个只考虑硬掩护的选项，然后是一个只考虑软掩护的后备选项。
将权重的数量保持在较低水平 - 理想情况下为一两个 - 可以使查询在给定上下文中具有可预测的结果，并节省大量的调整时间。
有效的标准也将帮助您保持查询简单 - 我们现在检查一些示例。
26.5.2 直接性
当接近目标时，我们查询的一个明显基础是基于到目标的反距离的权重：
Weights = {distance_from_referencePoint = -1.0}
然而，在许多情况下，我们不希望直接到达目标，而是希望通过一系列跳跃来接近它 - 例如，沿途从一个掩护点冲到另一个掩护点。在这种情况下，到目标的纯距离很快变得难以处理和平衡其他权重。它鼓励我们尽可能接近目标，而我们真正寻找的是一系列精心选择的路径点。换句话说，我们真正需要的是朝着目标前进的度量，距离需要单独指定。
直接性是衡量一个点将我们带到目标的距离与我们行进的距离相比的接近程度。

使用公式 26.1，如果我们距离目标 50 米，一个距离我们 10 米且距离目标 45 米的点在直接性上的得分将为 0.5。这个度量非常可预测：越接近直线到我们的目标，得分越高，无论距离如何。我们可以忽略距离，只要求最接近直线到目标的点：
Weights = {directness_to_referencePoint = 1.0}
甚至更简单，而不是将其用作权重，我们可以将其作为条件，只需指定它应该是正的，所以我们总是会朝着目标前进，无论多么小，或者它应该至少为 0.5，这样对于我们每移动 10 米，我们将至少接近目标 5 米。这些都很容易理解，并且与我们可能引入的其他标准正交，因此我们可以将其应用于现有查询，而无需长时间的重新调整。
Conditions = {min_directness_to_referencePoint = 0.5}
此外，这个简单的直接性度量实际上提供了超越目标寻求的强大功能。我们当然可以通过使用负权重或要求负直接性来以同样的方式远离目标：
Conditions = {max_directness_to_referencePoint = -0.5}
然而，我们也可以从相同的标准中获得截然不同的行为。通过制定一个条件，即权重必须落在围绕零的设定范围内 - 例如 [-0.1, 0.1] - 我们指定了通过移动到这些位置，我们对目标没有真正的进展或远离目标的位置。这是侧翼的一个很好的基础，我们可以将其指定为如下（请注意，此查询并不意味着任何特定方向 - 我们可以轻松添加）：
Generation = {hidespots_from_target_around_puppet = 15},
Conditions = {min_directness_to_target = -0.1, max_directness_to_target = 0.1},
Weights = {distance_from_puppet = -1.0}
直接性也可以带来之字形运动。在 Crytek 项目的核心游戏玩法中，有一个例子是设计师希望智能体通过森林快速接近玩家，从一个掩护点冲到另一个掩护点，通常不停顿。如果他们直接接近，他们的运动将非常可预测，并且成为太容易的目标。在这里，我们可以将直接性作为条件，同时具有最大值和负权重：
Generation = {hidespots_from_target_around_puppet = 15},
Conditions = {min_directness_to_target = 0.5}, Weights = {directness_to_target = -1.0}
因此，我们采取尽可能间接的路线，同时始终保持每行进 2 米至少向玩家前进 1 米的最小进展，不规则放置的树木和玩家的运动提供了一个 “随机” 因素。结果是之字形运动迅速向玩家收敛。
26.5.3 CanReachBefore
如果一个智能体朝着一个隐藏点跑去，结果却被对手先占据，这会对我们造成两次伤害：首先，智能体似乎没有预料到对手，其次，它会被困在开阔地带，并突然改变方向朝向其他掩护点。
通过一些规定很容易防止这种情况。最简单的方法是关注我们当前的主要对手，并丢弃任何比我们更接近敌人的点，有效地假设两个智能体将以相同的速度移动。我们可以将其实现为一个简单的条件，例如：
Conditions = {canReachBefore_the_target = true}
这个经验法则对于良好的行为非常普遍，在《孤岛危机 1》的隐藏系统中，它不是可选的；您可以将其作为所有查询的默认值。
这只关注一个对手。《孤岛惊魂》和《孤岛危机》还利用了对所有智能体正在移动的隐藏点的完美知识，从不选择另一个智能体已经占据的隐藏点。在这里，建议进行突出的视觉调试，因为来自一个行为或智能体的查询可能与其他行为或智能体产生不明显的交互。
26.5.4 CurrentHidepoint
通常，生成我们已经选择的点是有用的，无论是为了调整它还是验证它是否仍然足够好。
有时，一个点的精确位置将根据需求确定 - 例如，前面提到的《孤岛危机》中树木的隐藏点，总是会在隐藏目标的对面生成。如果我们使用掩护轨道，我们可能只是想调整我们在轨道上的位置，以反映我们目标的移动或保持与共享轨道的附近小队成员的分离。
一旦我们开始朝着一个点移动，我们通常希望在这个决定背后表现出一定的惯性：如果它变得稍微不那么理想，就改变方向，或者当一个稍微更好的点可用时，通常对玩家来说看起来很不自然。然而，如果情况发生了很大的变化 - 例如，由于手榴弹的降落或敌人的移动使一个位置明显暴露 - 我们确实需要做出反应。
因此，一旦我们选择了一个点，我们可以定期用一个简化的查询来检查它，该查询只生成这一个点，其中权重无关紧要，只使用关键条件 - 使其更便宜、更简单，并且比原始查询更具容忍性。这个查询是为了验证该点仍然 “足够好”。当这失败时，我们可以回退到查询的完整版本，以相同的标准选择一个新点，或者回到我们的行为树重新评估我们的上下文。如果情况发生巨大变化 - 例如，由于手榴弹的存在 - 我们依靠行为树将我们切换到不同的行为，从而切换到不同的查询。
《子弹风暴》使用了类似的对选定隐藏点的验证，但将其实现为单个查询中的特定类型的标准，而不是单独的版本 [Zielinksi 13]。
26.6 群体技术
到目前为止，我们已经讨论了单个智能体如何对自己的移动做出最佳决策。当我们开始考虑智能体作为群体或小队的成员，或者实际上是同伴时，新的标准可以帮助我们构建他们的行为，同时应对这种增加的复杂性。
26.6.1 空间连贯性 - 小队中心
在考虑一个小队时，我们最基本的属性是空间连贯性 - 即保持小队在一起。我们可以通过为小队定义一个中心来实现这一点 - 例如，它当前的平均位置 - 以便每个成员的查询可以指定他们应该靠近该点。我们可以通过使用新对象 squadCenter 重新应用我们现有的标准来实现这一点。
也许最明显的方法是对我们的查询进行加权，以反比于它们与中心的距离来偏好点。
Weights = {distance_to_squadCenter = -1.0}
当我们的小队需要收敛（可能是对被包围的反应）或相反地分散开（可能是受到迫击炮威胁）时，这非常有用。然而，作为一个构建块，它存在一个问题，即它是一个权重，必须与我们查询中的任何其他权重平衡。连贯性本身不是一种行为，而是我们希望展示的所有其他行为的属性 - 因此，理想情况下，我们应该以与其他标准正交的方式指定这一点。
实现这一点的简单方法是简单地限制最大距离。然后，我们的成员可以完全自由地在小队中心的半径内移动，随着成员的进展，小队中心将与小队一起移动 [Champandard et al. 11]。请注意，我们可以通过将我们的收集 / 生成中心设置在小队中心并适当地设置半径来非常有效地实现这一点。
Generation = {hidespots_from_target_around_squadCenter = 10}
结果具有一些非常好的属性。如果我们的小队中的一些成员在朝着目标前进时落后 - 例如，由于分散的起始配置或一些成员绕过障碍物走了很长的路 - 那么前面的成员会发现他们的查询返回没有新的有效点，因为唯一朝着目标前进的点在小队中心的范围之外。在这种情况下，他们应该通过等待来处理这种 “失败”，直到后面的成员赶上并且小队中心向前移动。这会导致一种松散的交替行为，而无需明确考虑小队成员的相对位置。
在这里，我们通常假设我们朝着前进的目标是整个小队共同的目标 - 通过适当地选择该目标的位置，我们可以将其呈现为小队的前进或后退，甚至可以让设计师直接控制目标，允许他们根据脚本事件指导小队。
然而，个体也可以选择完全不同的行为并独立移动一段时间而不会破坏群体。例如，如果一个个体正在避免手榴弹或收集附近的弹药，他可能会忽略该查询中的群体连贯性标准。虽然他可能看起来离开了群体，但他仍然为小队中心做出贡献，因此他们不会在没有他的情况下前进太远，允许他赶上。
26.6.2 隐藏点竞争
每当我们在保持空间凝聚力的同时在群体中操作时，对于可用隐藏点的竞争就会增加。这会带来行为和架构上的问题。
每当个体负责位置的选择时，他们只能根据自己的偏好和当前可用的点来优化选择。因此，步枪手占据了榴弹兵理想的位置，或者智能体为自己占据了最近的可用掩护，让他的小队成员尴尬地绕过他才能到达任何掩护。
这可以通过在小队级别而不是个体级别执行查询来解决，维护一个中央点集，在考虑整个小队的情况下分配给小队成员。这种方法在《孤岛危机》的群体行为中得到了有效应用。然而，这可能导致紧密耦合的行为，难以扩展。
还有一个问题是，如果我们同时在多个智能体上进行查询 - 例如，在多个线程上并行运行 - 它们可能都试图占据同一个点，我们必须以某种方式解决这个问题。一种方法是为每个查询返回多个结果，这样就有其他点可以作为后备。正如我们将在 “性能” 部分中指出的，返回结果的完整列表意味着我们无法利用一些重要的优化 - 但是一个或两个额外的结果通常就足够了，并且可以仅以查询成本的增量增加来生成。
26.6.3 同伴和小队成员
在游戏 AI 中，设计一个与玩家密切互动的 NPC 是最大的挑战之一。当 NPC 与玩家共享移动位置，如隐藏点时，他们的移动选择必须像机器中的齿轮一样紧密配合玩家不可预测的移动，如果我们要避免齿轮痛苦的碰撞。
在第一人称和第三人称游戏中，这个问题尤其尖锐，因为我们面临着相互冲突的需求，既要留在玩家的视野中，让她意识到我们的移动和活动，又要避免妨碍或从玩家那里窃取位置；在射击游戏中，我们还必须避开玩家的视线（LOF）…… 这样的例子不胜枚举。有一些特定的标准可以帮助我们找到解决方案：
cameraCenter 返回一个值，指示该点在玩家视锥体中的位置。它从中心的 1 插值到边缘的 0，以及屏幕外的负值，允许我们控制指定朝向我们视野边缘的位置或只是屏幕外的位置。这种变化可以特别偏好左侧或右侧的位置。
crossesLineOfFire 接受一个对象来指定要考虑其 LOF 的对象，通常是本地玩家。我们的实现使用一个简单的 2D 线相交测试，将从指定对象到候选位置的线与玩家的前向向量进行比较，尽管更复杂的实现当然是可能的。
使用这两个标准，我们可以形成一个简单的小队成员查询：
这个查询是针对一个我们已经有一个目标正在攻击的上下文，并尝试从该目标找到一个掩护点，坚持它必须不穿过玩家的 LOF 才能到达那里，并且它必须在屏幕上，但尽可能靠近玩家的视野边缘，并在保持尽可能靠近玩家的同时平衡这一点。
当然，这只是一个漫长的设计和开发过程的起点。例如，玩家的视野随着他的环顾而不断变化，我们的同伴不应该来回奔跑以保持在视野中；玩家在任何给定时刻的前向向量也不总是代表他可能的视线。我们可以通过在一段时间内平均这些向量，考虑代表可能通过关卡的移动流的 “黄金路径”，并考虑玩家可能射击的目标来开始解决这些问题。
当我们尝试这些新想法时，我们可以将它们作为新的标准添加，利用我们查询系统的快速原型能力来帮助我们快速有效地尝试所有的排列。
26.7 性能
在开发这种系统时，对其性能的工作必须与扩展其功能和使用并行。系统越高效，对昂贵标准的处理越精细，我们就越能自由地使用该系统，并能将更强大的标准添加到我们的工具集中。战术位置选择是我们可以利用 AI 周期的最有成效的用途之一，但除非我们控制好性能，否则我们的想法将无法进入最终的产品。在这里，我们讨论降低和管理查询成本的方法。
26.7.1 收集和生成成本
从数据库中收集点时，为缓存一致性设计的高效查找结构在控制台上至关重要。否则，收集点的成本很可能超过评估它们的成本。Crytek 游戏使用了各种存储点和隐藏点的方案，包括将它们存储在导航图中、使用空间哈希以及按类型分离它们。我们也可以只维护与游戏本节相关的点集，就像交换未使用的导航图部分一样将它们换出。
在动态生成点或验证收集点的掩护时，应尽可能便宜地生成候选点，并推迟任何昂贵的测试 - 例如，对于来自目标的遮挡，直到评估过程的后期，我们可能能够完全避免它们的成本。
26.7.2 最小化光线投射
光线投射通常用于许多目的，包括确定您是否被特定目标隐藏，或确定您是否可以使用特定姿势射击特定目标。在许多游戏中，它们是位置选择或整个 AI 系统的主要成本，因此值得特别考虑。
物理光线投射操作总是昂贵的，并且通常会遍历大量内存位置。如果它是同步执行的，在缓存未命中、缓存破坏以及与任何物理线程的可能同步成本方面，这将是痛苦的；在控制台上，这是非常禁止的。异步操作允许批处理和将工作平滑地卸载到其他核心，如 PS3 的 SPU。因此，TPS 系统应该更喜欢异步 API，即使只是为了有效地处理基于光线投射的标准。
我们可能能够在数据库中形成点，以便我们可以假设从某些方向的遮挡并完全避免光线投射。在静态环境中，我们可以使用一种非常简单的隐含方向方法，如《孤岛危机》中的 “隐藏锚点”。然后，我们可以简单地测试目标是否落在隐藏点方向的锥体内。在动态环境中，我们可能还需要定期检查掩护对象是否仍然有效。更进一步，《孤岛危机 2》的掩护生成系统实际上映射了相关掩护对象的轮廓，并能够在破坏时重新映射它们 [Martins 11]。这允许我们在不进行光线投射的情况下，根据附近的几何形状测试从一个点的遮挡。
当最小化智能体从多个目标的暴露时，我们需要能够从多个角度考虑掩护，并考虑其他几何形状可能会阻挡视线，这意味着我们可能需要光线投射。然而，在许多游戏中，对这种暴露的关注并不是必需的，并且在许多情况下，就可信度、数字表演和游戏玩法而言，专注于很好地隐藏在我们积极参与的单个对手面前，而不是试图隐藏在多个对手面前，可能会更有效。
一个很难避免的光线投射来源是那些验证我们是否可以从一个位置有效地射击目标的光线投射，通常是通过瞄准或绕过我们的掩护几何形状。毕竟，当我们请求一个隐藏的地方时，我们通常真正的意思是一个有掩护的射击位置；如果游戏玩法要有意思，我们必须验证我们是否可以射击或接近我们的目标。
我们的系统需要尽可能高效地处理我们必须执行的光线投射。这意味着我们应该将基于光线投射的条件留到位置选择过程的后期，以便其他条件能够筛选出尽可能多的候选点。我们还应该限制每帧启动的光线投射数量，以避免峰值，并允许光线投射异步运行。在许多系统中，出于这个原因，光线投射测试被特别处理 - 这可能足以满足您的需求。在 Crytek 系统和本讨论中，我们将它们视为我们希望在标准中支持的一系列昂贵和 / 或异步操作的一个示例。

### 26.7.3 评估顺序

我们可以做的最简单的事情，对性能产生很大影响的是注意我们评估标准的顺序。评估顺序的经验法则是：
先评估便宜的过滤器，尽早丢弃点
评估权重，以便我们对点进行排序
评估昂贵的过滤器，从得分最高的点开始，直到一个点通过
许多标准可以被合理地归类为 “便宜”，因为许多标准由简单的布尔或浮点运算组成，数据上的缓存未命中可能是主要成本。这些过滤器应该首先运行，因为它们可以用于快速消除候选点，从而避免更昂贵的标准。另一方面，一些标准可能成本高出许多数量级（如光线投射）。我们应该尽可能推迟这些测试，以减少我们必须为其运行的候选点数量。通过使用便宜的过滤器快速丢弃点，然后评估权重，然后对剩余的点按从得分最高到最低的顺序执行昂贵的过滤器，一旦一个点通过，我们就可以停止评估，返回正确的结果，但通常成本会大大降低。
我们注意到，在这种方法中，我们对昂贵的权重（如相对暴露计算或准确的路径距离）几乎无能为力；此外，在最坏的情况下，在找到有效点之前，我们将完全评估所有点，或者没有找到有效点。

### 26.7.4 动态评估策略

如果我们能够跳过昂贵的权重以及条件，这将使我们在开发和使用这些标准时拥有更大的自由度。例如，我们可以测量对多个目标的相对暴露，或者使用准确的路径长度而不是直线距离。当然，我们希望确保返回的结果与进行完整评估时相同。在这里，我们提出一种允许这样做的方法。
我们首先注意到，一般来说，我们不需要知道一个点的最终得分来确定它比其他点更好。为了说明这一点，考虑两个返回浮点值的标准，归一化为 0 - 1 范围：A，在这个查询中被分配权重 2/3，B，被分配权重 1/3。如果一个点在权重 A 上获得满分，而第二个点的得分不到一半，那么就没有理由在这两个点上评估权重 B；B 能提供的最高得分仍然不会导致第二个点的得分高于第一个点。
基于这个观察，我们应该将评估重点放在当前所有考虑的点中潜在得分最高的点上。为了做到这一点，我们需要知道每个点已经评估了多少个标准，以及每个点可能达到的最高得分。我们可以使用一个结构体来保存这个元数据和点本身：
我们使用一个二叉堆 [Cormen et al. 01] 来在我们进行评估时根据 maxScore 值维护这些结构体的部分排序。堆通常用于优先队列，确保最大元素始终保持在堆的顶部，开销最小。在二叉堆中，删除顶部元素（pop_heap）是一个 O (log n) 操作，并且通常在一个内存块中实现，如 STL 向量，它们也相对缓存友好。
尽管如此，我们之前注意到许多标准的评估成本很低，在这种情况下，堆维护的开销将与评估本身相当。因此，我们在形成堆之前，以与上一节中讨论的类似的直接方式处理这些 “便宜” 标准：我们评估所有便宜的条件并丢弃任何失败的点，然后根据便宜的权重对剩余的点进行评分 - 即，将它们的归一化返回值与用户指定的乘数（权重）的乘积相加。
这使我们留下一组减少的点来评估更昂贵的条件和权重。下一步是确定每个剩余点在评估所有权重时可能达到的最小和最大可能得分。由于所有权重都将被归一化为返回 [0 - 1] 范围内的值，我们可以通过参考用户定义的乘数来做到这一点。我们将查询中负用户定义乘数（权重）的值相加，以找到它们可以从总分中减去的最大量。我们对正用户定义乘数执行相同的操作，以找到它们可以添加到总分中的最大量。然后，我们遍历每个点，并将这些量添加到我们评估便宜权重时计算的实际得分中，找到该点的最低和最高潜在得分 - 上面描述的 minScore 和 maxScore 元数据。
在有效地处理了便宜的标准并确定了潜在得分后，我们从这些结构体创建堆，如上所述填充，并基于该数据结构进行所有进一步的评估。现在我们详细查看核心评估循环。本节中的代码块可以组合起来描述整个循环，但我们将其分成部分，以便我们可以解释过程中的每一步。
每次迭代开始时，检查我们是否已经用尽了所有候选点，在这种情况下，这个查询选项失败。否则，我们从堆中取出顶部点并检查它是否已经完全评估。如果是，我们有一个最终结果，并立即返回（如下所示）或从堆中删除该点并继续评估以找到多个结果。
在决定标准的评估顺序时，我们可以自由地交错权重和条件。按成本增加的顺序排序是一种合理的策略，但我们也可以更早地评估最大的权重，同样地，对于实际上通常失败的条件也是如此。根据分析和反馈，在性能方面有很大的提升空间。
这种方法在我们有希望避免评估的昂贵权重的情况下，比简单的方法有所改进。如果我们没有这样的权重，它执行的评估将与上一节中描述的方法相同。在最坏的情况下，当没有点有效时，它可能能够表现得更好，因为评估顺序可以更自由地调整，如上所述。但是，如果我们要确保返回任何存在的有效点，这种最坏情况当然需要我们检查至少足够的条件来丢弃每个点，无论我们采取什么方法来做到这一点。
当一个查询由于昂贵的标准或对大量点的最坏情况评估而需要大量时间来评估时，我们必须能够在多个帧上分布评估。在多个智能体之间共享评估时间也可能是有用的，以避免所有活跃智能体等待单个缓慢的查询。如上所述，描述的堆结构适合在任何阶段暂停评估以稍后继续 - 我们将在下一节中利用这一点。

### 26.7.5 异步评估和时间分片

同步方法，即在单个函数调用中返回结果，是最简单的执行模型，对开发人员来说最方便，但随着我们对系统施加更大的负载并提供更强大的标准，同步查询很容易导致处理时间的不可接受的峰值。此外，某些标准可能依赖于异步操作 - 例如，高效的光线投射，如前所述。因此，我们几乎肯定需要支持查询被异步处理的能力。
为了更好地处理异步查询，我们使用一个调度程序，它将跟踪哪些请求正在等待，哪些正在当前处理。《孤岛危机 2》使用了一个简单的先到先服务的调度程序，任何时候都只处理一个查询 - 然而，一个在智能体之间共享时间的调度程序将是一个有用的改进。有了调度程序，我们可以对我们的评估进行时间分片，在执行期间定期检查评估时间，并在我们为该帧分配的预算到期时放弃控制。
Crytek 系统在一个过程中执行整个生成阶段，并评估所有便宜的权重和条件，然后检查评估时间。由于设计上这些阶段成本较低，我们预计到此时不会大大超出预算，并且只支持同步操作，因此我们不需要等待任何操作完成。一旦完成，系统形成堆，这与时间分片兼容。
当我们继续评估堆时，我们在具有最高潜在得分的点上评估单个标准 - 无论是权重还是条件 - ，然后在继续下一步或搁置堆直到下一帧之前检查经过的时间。由于根据定义，在这个堆阶段评估的所有标准都非常昂贵，检查 CPU 时钟和堆操作的开销是可以接受的。
相同的基础设施为处理使用异步操作（如光线投射）的标准提供了基础。每当我们到达其中一个时，我们在搁置堆之前启动该延迟操作，就好像我们已经用完了我们的时间片一样。在下一帧，我们以与之前几乎相同的状态重新评估堆 - 除了这次我们发现我们的延迟操作正在等待结果，现在应该可用。然后，我们可以完成该点上该标准的结果，就像它是同步的一样 - 然后继续下一步。
使用异步操作的标准导致的延迟是显著的，并且可能限制它们在我们查询中的使用。我们可以通过多种方式解决这个问题。首先，我们应该为每个候选点最后评估异步标准，以便我们能够避免它们。其次，如果我们有剩余时间，我们可以继续评估另一个查询，增加我们的吞吐量。最后，我们可以同时在堆顶部附近的其他一些点上推测性地启动延迟标准。

### 26.8 工具

与所有此类系统一样，我们的 TPS 系统只有在我们为其构建的工具和围绕它开发的工作流程的情况下才有效。查询语言是这样的工具之一，但如果我们要有效地开发和调整查询并追踪问题，我们还需要能够可视化查询结果。
Crytek 系统允许我们实时在世界中为特定智能体渲染查询结果。为每个候选点绘制一个球体，颜色指示其状态：白色表示得分最高的点，绿色表示通过所有条件的点，红色表示未通过条件的点，蓝色表示仅部分评估的点。每个球体上方显示最终得分。同时，解析后的查询的表示输出到日志中，以确认使用了哪个查询，并允许我们再次检查评估中使用了哪些标准。
虽然我们确实尝试通过颜色的等级来表示相对得分，但我们发现得分的差异通常很小 - 尽管很重要 - 因此很难在视觉上判断。
一些标准有自定义的调试渲染。例如，包括光线投射的标准在游戏世界中绘制相应的线，更复杂的动态生成标准可以绘制关于它们在哪里以及如何考虑生成点的指示。
《子弹风暴》使用了类似的视觉调试方法，但也用一个短文本字符串注释每个无效点，指示失败的具体条件 [Zielinksi 13]。

### 26.9 未来工作

有一些未来工作的途径特别有前途。
随着行业对高效导航网格解决方案的标准化，一系列强大的新标准在 TPS 系统中变得可行。与我们理所当然的欧几里得距离相比，单个智能体在位置之间的准确路径距离将全面提供微妙改进的移动选择，并且对划分障碍物（如墙壁和围栏）具有更大的鲁棒性。点的生成可以仅在与我们的智能体相连的导航多边形中进行，确保在开放空间中生成的点（如所述的网格方法）始终可到达。导航光线投射对于在群体中保持视线非常有用，并且在某些情况下可以对完整的物理光线投射进行廉价的近似。
游戏环境继续变得更加丰富、动态，并且越来越多地使用程序内容生成。所有这些趋势都对传统搜索方法构成了可扩展性挑战。人们对使用随机采样的兴趣越来越大，如《Love》[Steenberg 11] 中所见，这可能会更好地扩展。这带来了错过明显位置的风险，在可信度和沉浸感方面的成本通常在当前的 AAA 级游戏中是不可接受的，但这样的游戏可以调整以使其非常罕见，或者这些点可以用于补充传统的点数据库。
最后，在开发基于小队的游戏时，目前在个体位置选择（提供不同角色的小组成员之间的解耦交互）和集中式位置选择（可以协调点的分配以有利于整个小组，但以紧密耦合的行为代码为代价）之间存在着鲜明的选择。朝着分散式查询之间的协调工作将是作者特别感兴趣的领域。

### 26.10 结论

战术位置选择是射击游戏 AI 的基石，也是 AI 和游戏玩法编程的潜在瑞士军刀。当我们摆脱严格的评估方法并提供一种表达性的查询语言时，我们可以仅通过小的数据更改来驱动各种各样的行为。通过创建特定于环境和期望行为的查询库，并考虑最佳实践并使用特定的构建块，我们可以保持查询简单并快速创建它们。我们的查询结果对我们的行为和查询选择的反馈允许我们的 AI 在情况发生变化时进行适应。
我们讨论了如何构建这样一个系统，从查询规范到最终结果，以及如何将其与我们的行为集成。我们考虑了性能和调试工具，以帮助确保我们在最终发布的产品中充分利用该系统。特别是，我们参考了《孤岛危机 2》中使用的系统的细节。